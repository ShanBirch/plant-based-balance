<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>FitGotchi Arena - Battle Mode</title>
<meta name="description" content="Battle your friends in the FitGotchi Arena! Your fitness powers your fighter.">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet"/>
<link href="manifest.json" rel="manifest"/>
<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.1.0/model-viewer.min.js"></script>
<style>
  :root {
    --arena-bg: #0a0e1a;
    --arena-accent: #10b981;
    --arena-accent-glow: rgba(16, 185, 129, 0.4);
    --arena-secondary: #8b5cf6;
    --arena-danger: #ef4444;
    --arena-warning: #fbbf24;
    --arena-text: #f1f5f9;
    --arena-muted: rgba(255,255,255,0.5);
    --arena-surface: rgba(255,255,255,0.06);
    --arena-border: rgba(255,255,255,0.1);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', sans-serif;
    background: var(--arena-bg);
    color: var(--arena-text);
    overflow: hidden;
    height: 100vh;
    height: 100dvh;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }

  /* â”€â”€ HUD â”€â”€ */
  .arena-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    padding: 12px 16px;
    padding-top: calc(12px + env(safe-area-inset-top, 0px));
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(180deg, rgba(10,14,26,0.95) 0%, transparent 100%);
    pointer-events: none;
  }
  .arena-hud > * { pointer-events: auto; }

  .hud-left { display: flex; align-items: center; gap: 10px; }
  .hud-back {
    width: 36px; height: 36px; border-radius: 50%;
    background: var(--arena-surface); border: 1px solid var(--arena-border);
    color: var(--arena-text); font-size: 1.1rem;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .hud-title {
    font-size: 0.85rem; font-weight: 800;
    color: var(--arena-accent);
    text-shadow: 0 0 20px var(--arena-accent-glow);
    text-transform: uppercase; letter-spacing: 1px;
  }

  .hud-stats {
    display: flex; gap: 8px;
  }
  .hud-stat {
    background: var(--arena-surface);
    border: 1px solid var(--arena-border);
    border-radius: 20px; padding: 5px 12px;
    font-size: 0.75rem; font-weight: 700;
    display: flex; align-items: center; gap: 4px;
  }

  /* â”€â”€ Canvas â”€â”€ */
  #arena-canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
  }

  /* â”€â”€ Virtual Joystick â”€â”€ */
  .joystick-zone {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 50%;
    height: 40%;
    z-index: 50;
    touch-action: none;
  }
  .joystick-base {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.06);
    border: 2px solid rgba(255,255,255,0.15);
    display: none;
    pointer-events: none;
  }
  .joystick-thumb {
    position: absolute;
    width: 50px; height: 50px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(16,185,129,0.6), rgba(16,185,129,0.2));
    border: 2px solid rgba(16,185,129,0.5);
    display: none;
    pointer-events: none;
  }

  /* â”€â”€ Visible D-Pad hint â”€â”€ */
  .dpad-hint {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 110px;
    height: 110px;
    z-index: 45;
    pointer-events: none;
    opacity: 0.35;
    transition: opacity 0.3s;
  }
  .dpad-hint.active {
    opacity: 0.6;
  }
  .dpad-center {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 32px; height: 32px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 1.5px solid rgba(255,255,255,0.25);
  }
  .dpad-arrow {
    position: absolute;
    width: 0; height: 0;
    border: 10px solid transparent;
  }
  .dpad-arrow.up {
    top: 4px; left: 50%;
    transform: translateX(-50%);
    border-bottom: 12px solid rgba(255,255,255,0.35);
    border-top: none;
  }
  .dpad-arrow.down {
    bottom: 4px; left: 50%;
    transform: translateX(-50%);
    border-top: 12px solid rgba(255,255,255,0.35);
    border-bottom: none;
  }
  .dpad-arrow.left {
    left: 4px; top: 50%;
    transform: translateY(-50%);
    border-right: 12px solid rgba(255,255,255,0.35);
    border-left: none;
  }
  .dpad-arrow.right {
    right: 4px; top: 50%;
    transform: translateY(-50%);
    border-left: 12px solid rgba(255,255,255,0.35);
    border-right: none;
  }


  /* â”€â”€ Action Button â”€â”€ */
  .action-zone {
    position: fixed;
    bottom: 30px;
    right: 20px;
    z-index: 50;
  }
  .action-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: 3px solid rgba(255,255,255,0.2);
    color: white;
    font-size: 0.7rem; font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    box-shadow: 0 0 30px var(--arena-accent-glow);
    transition: transform 0.1s, box-shadow 0.2s;
    display: flex; align-items: center; justify-content: center;
  }
  .action-btn:active { transform: scale(0.92); }
  .action-btn.battle-ready {
    background: linear-gradient(135deg, var(--arena-danger), #dc2626);
    box-shadow: 0 0 30px rgba(239,68,68,0.5);
    animation: pulse-battle 1s infinite;
  }
  @keyframes pulse-battle {
    0%,100% { box-shadow: 0 0 20px rgba(239,68,68,0.4); }
    50% { box-shadow: 0 0 40px rgba(239,68,68,0.7); }
  }

  /* â”€â”€ Players Alive Counter â”€â”€ */
  .players-alive {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 0.75rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(10px);
  }

  /* â”€â”€ Battle Overlay â”€â”€ */
  .battle-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .battle-overlay.active {
    display: flex;
    animation: battleIn 0.4s ease;
  }
  @keyframes battleIn {
    0% { opacity: 0; transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
  }

  .battle-vs {
    display: flex;
    align-items: center;
    gap: 30px;
    margin-bottom: 30px;
  }
  .battle-fighter {
    text-align: center;
  }
  .battle-fighter canvas {
    border-radius: 16px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.05);
  }
  .battle-fighter-name {
    margin-top: 8px;
    font-weight: 800;
    font-size: 0.9rem;
  }
  .battle-fighter-stats {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 4px;
  }
  .battle-vs-text {
    font-size: 2.5rem;
    font-weight: 900;
    color: var(--arena-danger);
    text-shadow: 0 0 30px rgba(239,68,68,0.5);
  }

  /* â”€â”€ Battle Combat Zone (stacks viewport + info panel) â”€â”€ */
  .battle-combat-zone {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  /* â”€â”€ Battle Viewport (matches tamagotchi widget: 420px) â”€â”€ */
  .battle-viewport {
    position: relative;
    width: 100%;
    height: 420px;
    min-height: 320px;
    background: #1a1a2e;
    overflow: hidden;
    flex-shrink: 0;
  }

  .battle-viewport .dojo-bg {
    position: absolute;
    inset: 0;
    background: url('./assets/battle_dojo_bg.jpeg') center center / cover no-repeat;
    z-index: 0;
  }
  .battle-viewport .dojo-bg::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.15);
    pointer-events: none;
  }

  .battle-viewport model-viewer {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: -30%;
    z-index: 3;
    --poster-color: transparent;
    background: transparent;
    transform: scale(0.75);
    transform-origin: center center;
  }

  .battle-viewport .battle-overlay-text {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
    background: rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .battle-viewport .battle-overlay-text.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
  }
  .battle-viewport .battle-overlay-text .battle-text {
    color: white;
    font-size: 2.5rem;
    font-weight: 900;
    text-shadow: 0 0 20px rgba(255,0,0,0.8), 0 4px 20px rgba(0,0,0,0.7);
    font-family: 'Inter', sans-serif;
    text-transform: uppercase;
    text-align: center;
    line-height: 1.3;
  }

  /* â”€â”€ HP bars (overlaid on viewport) â”€â”€ */
  .battle-hp-container {
    position: absolute;
    top: 12px;
    left: 12px;
    right: 12px;
    display: none;
    justify-content: space-between;
    z-index: 150;
    pointer-events: none;
  }
  .battle-hp-container.active {
    display: flex;
  }
  .battle-hp-box {
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(6px);
    border-radius: 10px;
    padding: 6px 10px;
    min-width: 120px;
    border: 1px solid rgba(255,255,255,0.15);
  }
  .battle-hp-box.enemy {
    text-align: right;
  }
  .battle-hp-name {
    font-size: 0.6rem;
    font-weight: 700;
    color: rgba(255,255,255,0.8);
    margin-bottom: 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .battle-hp-bar-bg {
    height: 6px;
    background: rgba(255,255,255,0.15);
    border-radius: 6px;
    overflow: hidden;
  }
  .battle-hp-bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.4s ease-out;
  }
  .battle-hp-bar-fill.player {
    background: linear-gradient(90deg, #2ecc71, #4ecdc4);
  }
  .battle-hp-bar-fill.enemy {
    background: linear-gradient(90deg, #e74c3c, #ff6b6b);
  }
  .battle-hp-text {
    font-size: 0.5rem;
    font-weight: 800;
    color: rgba(255,255,255,0.7);
    margin-top: 2px;
    font-family: 'Inter', sans-serif;
  }

  /* â”€â”€ Mana bar (above action buttons, bottom of viewport) â”€â”€ */
  .battle-mana-container {
    position: absolute;
    bottom: 95px;
    left: 12px;
    right: 12px;
    z-index: 150;
    pointer-events: none;
    display: none;
  }
  .battle-mana-container.active {
    display: block;
  }
  .battle-mana-label {
    font-size: 0.5rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
  }
  .battle-mana-bar-bg {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    overflow: hidden;
  }
  .battle-mana-bar-fill {
    height: 100%;
    border-radius: 8px;
    background: linear-gradient(90deg, #3498db, #45b7d1, #9b59b6);
    transition: width 0.2s linear;
    box-shadow: 0 0 8px rgba(52,152,219,0.4);
  }
  .battle-mana-bar-fill.full {
    animation: manaReady 0.5s ease-in-out infinite alternate;
  }
  @keyframes manaReady {
    0% { box-shadow: 0 0 8px rgba(52,152,219,0.4); }
    100% { box-shadow: 0 0 20px rgba(155,89,182,0.8); }
  }

  /* â”€â”€ Info Panel (below viewport) â”€â”€ */
  .battle-info-panel {
    flex: 1;
    width: 100%;
    padding: 16px 20px;
    overflow-y: auto;
    background: linear-gradient(180deg, #0d1117 0%, #0a0e1a 100%);
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .battle-info-title {
    text-align: center;
    font-size: 0.65rem;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--arena-accent);
    margin-bottom: 12px;
    opacity: 0.8;
  }
  .battle-info-opponent {
    display: flex;
    align-items: center;
    gap: 14px;
    background: rgba(255,255,255,0.04);
    border-radius: 14px;
    padding: 12px 16px;
    border: 1px solid rgba(255,255,255,0.06);
    margin-bottom: 12px;
  }
  .battle-info-opponent canvas {
    border-radius: 10px;
    background: rgba(255,255,255,0.03);
    flex-shrink: 0;
  }
  .battle-info-opponent-details {
    flex: 1;
    min-width: 0;
  }
  .battle-info-opponent-name {
    font-size: 1rem;
    font-weight: 800;
    color: white;
    margin-bottom: 2px;
  }
  .battle-info-opponent-level {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--arena-muted);
    margin-bottom: 6px;
  }
  .battle-info-stat-row {
    display: flex;
    gap: 12px;
  }
  .battle-info-stat {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.65rem;
    font-weight: 700;
    color: rgba(255,255,255,0.5);
  }
  .battle-info-stat span:first-child {
    color: rgba(255,255,255,0.3);
  }
  .battle-info-stat-val {
    color: rgba(255,255,255,0.8) !important;
  }

  .battle-info-round-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 0;
  }
  .battle-round-info {
    font-size: 0.75rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
  }
  .battle-round-score {
    display: inline-flex;
    gap: 6px;
    font-size: 0.85rem;
    font-weight: 900;
    margin-left: 8px;
  }
  .round-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: inline-block;
  }
  .round-dot.player-win { background: #2ecc71; }
  .round-dot.enemy-win { background: #ff4444; }

  .battle-timer {
    font-size: 1.6rem;
    font-weight: 900;
    color: var(--arena-warning);
    font-family: 'Inter', monospace;
  }

  /* â”€â”€ Action buttons (overlaid at bottom-right, dashboard style) â”€â”€ */
  .battle-action-container {
    position: absolute;
    bottom: 12px;
    right: 12px;
    z-index: 200;
    display: none;
    pointer-events: none;
  }
  .battle-action-container.active {
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: auto;
  }

  .battle-bash-btn {
    width: 80px;
    height: 80px;
    border: none;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff6b4a, #e63946);
    color: white;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    box-shadow: 0 4px 20px rgba(230,57,70,0.5), inset 0 2px 4px rgba(255,255,255,0.2);
    transition: transform 0.05s;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-bash-btn:active {
    transform: scale(0.88);
    box-shadow: 0 2px 10px rgba(230,57,70,0.7), inset 0 2px 4px rgba(0,0,0,0.2);
  }
  .battle-bash-btn .bash-icon { font-size: 1.5rem; line-height: 1; }
  .battle-bash-btn .bash-label { font-size: 0.55rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }

  .battle-bash-btn .bash-progress-ring {
    position: absolute;
    inset: -4px;
    pointer-events: none;
  }
  .battle-bash-btn .bash-progress-ring svg {
    width: 100%;
    height: 100%;
  }
  .bash-ring-bg {
    fill: none;
    stroke: rgba(255,255,255,0.15);
    stroke-width: 3;
  }
  .bash-ring-fill {
    fill: none;
    stroke: #FFD700;
    stroke-width: 3;
    stroke-dasharray: 163.36;
    stroke-dashoffset: 163.36;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.1s;
    transform: rotate(-90deg);
    transform-origin: center;
  }

  .battle-bash-btn.attack-ready {
    animation: bashReady 0.3s ease-in-out infinite alternate;
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff8c00);
  }
  @keyframes bashReady {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.5); transform: scale(1); }
    100% { box-shadow: 0 0 30px rgba(255,215,0,0.9); transform: scale(1.05); }
  }

  .battle-action-btn {
    width: 64px;
    height: 64px;
    border: none;
    border-radius: 50%;
    color: white;
    cursor: pointer;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-action-btn.visible {
    display: flex;
    animation: actionBtnAppear 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  .battle-action-btn .action-btn-icon { font-size: 1.3rem; line-height: 1; }
  .battle-action-btn .action-btn-label { font-size: 0.5rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }
  .battle-action-btn:active { transform: scale(0.85); }

  .battle-fire-btn {
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff6b00);
    box-shadow: 0 0 20px rgba(255,215,0,0.7), 0 0 40px rgba(255,107,0,0.4);
    animation: firePulse 0.5s ease-in-out infinite alternate;
  }
  @keyframes firePulse {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(255,215,0,0.9); transform: scale(1.08); }
  }

  .battle-block-btn {
    background: radial-gradient(circle at 30% 30%, #60a5fa, #2563eb);
    box-shadow: 0 0 20px rgba(96,165,250,0.7), 0 0 40px rgba(37,99,235,0.4);
    animation: blockPulse 0.4s ease-in-out infinite alternate;
  }
  @keyframes blockPulse {
    0% { box-shadow: 0 0 15px rgba(96,165,250,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(96,165,250,0.9); transform: scale(1.08); }
  }

  @keyframes actionBtnAppear {
    0% { transform: scale(0) rotate(-20deg); opacity: 0; }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
  }

  /* â”€â”€ Fireball projectile â”€â”€ */
  .fireball {
    position: absolute;
    pointer-events: none;
    z-index: 100;
    will-change: transform;
  }
  .fireball img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: auto;
  }

  /* â”€â”€ Hit flash â”€â”€ */
  .battle-hit-flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 210;
    animation: hitFlash 0.3s ease-out forwards;
  }
  @keyframes hitFlash {
    0% { background: rgba(255,68,68,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.blocked { animation-name: blockFlash; }
  @keyframes blockFlash {
    0% { background: rgba(59,130,246,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.super-hit { animation-name: superFlash; }
  @keyframes superFlash {
    0% { background: rgba(251,191,36,0.4); }
    100% { background: transparent; }
  }

  /* â”€â”€ Screen shake â”€â”€ */
  @keyframes battleShake {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-4px, 2px); }
    40% { transform: translate(4px, -2px); }
    60% { transform: translate(-2px, 4px); }
    80% { transform: translate(2px, -4px); }
  }
  .battle-shake { animation: battleShake 0.3s ease; }

  @keyframes roundTextPop {
    0% { transform: scale(0.3); opacity: 0; }
    60% { transform: scale(1.15); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  /* â”€â”€ Battle Result â”€â”€ */
  .battle-result {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }
  .battle-result.active { display: flex; }
  .battle-result-text {
    font-size: 2rem;
    font-weight: 900;
    text-transform: uppercase;
  }
  .battle-result-text.win { color: var(--arena-accent); text-shadow: 0 0 30px var(--arena-accent-glow); }
  .battle-result-text.lose { color: var(--arena-danger); }
  .battle-reward {
    font-size: 0.85rem;
    color: var(--arena-warning);
    font-weight: 700;
  }
  .battle-continue-btn {
    margin-top: 10px;
    padding: 12px 40px;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
  }

  /* â”€â”€ Lobby / Start Screen â”€â”€ */
  .lobby-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: linear-gradient(135deg, #0a0e1a 0%, #1a0e2e 50%, #0e1a2e 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top, 0px));
  }
  .lobby-overlay.hidden { display: none; }

  .lobby-title {
    font-size: 2.2rem;
    font-weight: 900;
    background: linear-gradient(135deg, var(--arena-accent), var(--arena-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }
  .lobby-subtitle {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 40px;
    max-width: 300px;
  }

  .lobby-avatar-preview {
    margin-bottom: 30px;
  }
  .lobby-avatar-preview canvas {
    border-radius: 20px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.03);
  }

  .lobby-customize {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 30px;
    max-width: 340px;
  }
  .lobby-color-btn {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: transform 0.15s, border-color 0.15s;
  }
  .lobby-color-btn:hover { transform: scale(1.15); }
  .lobby-color-btn.selected { border-color: white; transform: scale(1.15); }

  .lobby-start-btn {
    padding: 16px 50px;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 1.1rem;
    font-weight: 800;
    cursor: pointer;
    box-shadow: 0 4px 30px var(--arena-accent-glow);
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: transform 0.15s;
  }
  .lobby-start-btn:active { transform: scale(0.95); }

  .lobby-mode-select {
    display: flex;
    gap: 10px;
    margin-bottom: 24px;
  }
  .lobby-mode-btn {
    padding: 10px 20px;
    border-radius: 12px;
    border: 2px solid var(--arena-border);
    background: var(--arena-surface);
    color: var(--arena-text);
    font-size: 0.8rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
  }
  .lobby-mode-btn.selected {
    border-color: var(--arena-accent);
    background: rgba(16,185,129,0.15);
    color: var(--arena-accent);
  }

  /* â”€â”€ Game Over â”€â”€ */
  .gameover-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: rgba(0,0,0,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding-top: env(safe-area-inset-top, 0px);
  }
  .gameover-overlay.active { display: flex; animation: battleIn 0.5s ease; }
  .gameover-place {
    font-size: 4rem;
    font-weight: 900;
    margin-bottom: 8px;
  }
  .gameover-place.first {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .gameover-label {
    font-size: 1.3rem;
    font-weight: 800;
    color: var(--arena-text);
    margin-bottom: 4px;
  }
  .gameover-sub {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 30px;
  }
  .gameover-rewards {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  .gameover-reward {
    text-align: center;
  }
  .gameover-reward-val {
    font-size: 1.5rem;
    font-weight: 900;
    color: var(--arena-warning);
  }
  .gameover-reward-label {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 2px;
  }

  /* â”€â”€ Notifications â”€â”€ */
  .arena-notification {
    position: fixed;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 150;
    background: rgba(10,14,26,0.9);
    border: 1px solid var(--arena-accent);
    border-radius: 12px;
    padding: 10px 20px;
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--arena-accent);
    backdrop-filter: blur(10px);
    animation: notifIn 0.3s ease, notifOut 0.3s ease 2.5s forwards;
    white-space: nowrap;
  }
  @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
  @keyframes notifOut { to { opacity: 0; transform: translateX(-50%) translateY(-10px); } }

  /* â”€â”€ Powerup indicator â”€â”€ */
  .powerup-active {
    position: fixed;
    bottom: 120px;
    right: 20px;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .powerup-badge {
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 0.7rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 5px;
    animation: notifIn 0.3s ease;
  }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOBBY SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="lobby-overlay" id="lobby">
  <div class="lobby-title">FitGotchi Arena</div>
  <div class="lobby-subtitle">Your fitness powers your fighter. Battle your way to the top!</div>

  <div class="lobby-avatar-preview">
    <canvas id="lobby-avatar" width="140" height="160"></canvas>
  </div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Choose Your Color</div>
  <div class="lobby-customize" id="color-picker"></div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Arena Size</div>
  <div class="lobby-mode-select">
    <button class="lobby-mode-btn selected" onclick="selectMode(this,4)">4 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,6)">6 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,8)">8 Players</button>
  </div>

  <button class="lobby-start-btn" onclick="startGame()">Enter Arena</button>
  <div style="margin-top:12px;font-size:0.65rem;color:var(--arena-muted);">WASD / Arrow keys or touch joystick to move</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME CANVAS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<canvas id="arena-canvas"></canvas>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HUD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="arena-hud" id="hud" style="display:none;">
  <div class="hud-left">
    <button class="hud-back" onclick="exitArena()">&#8249;</button>
    <div class="hud-title">FitGotchi Arena</div>
  </div>
  <div class="hud-stats">
    <div class="hud-stat"><span>&#9876;</span> <span id="hud-kills">0</span></div>
    <div class="hud-stat"><span>&#9829;</span> <span id="hud-hp">3</span></div>
  </div>
</div>

<div class="players-alive" id="players-alive" style="display:none;">
  <span style="color:var(--arena-accent);">&#9679;</span>
  <span id="alive-count">8</span> alive
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VIRTUAL JOYSTICK â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="joystick-zone" id="joystick-zone">
  <div class="joystick-base" id="joystick-base"></div>
  <div class="joystick-thumb" id="joystick-thumb"></div>
</div>
<div class="dpad-hint" id="dpad-hint" style="display:none;">
  <div class="dpad-center"></div>
  <div class="dpad-arrow up"></div>
  <div class="dpad-arrow down"></div>
  <div class="dpad-arrow left"></div>
  <div class="dpad-arrow right"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTION BUTTON â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="action-zone" id="action-zone" style="display:none;">
  <button class="action-btn" id="action-btn" onclick="handleAction()">SCAN</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTIVE POWERUPS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="powerup-active" id="powerup-active"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BATTLE OVERLAY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="battle-overlay" id="battle-overlay">
  <div class="battle-vs" id="battle-vs"></div>
  <div class="battle-combat-zone" id="battle-combat-zone" style="display:none;">
    <!-- Battle Viewport (same as tamagotchi) -->
    <div class="battle-viewport" id="battle-viewport">
      <div class="dojo-bg"></div>
      <model-viewer
        id="arena-battle-model"
        camera-orbit="0deg 85deg 22m"
        field-of-view="55deg"
        min-field-of-view="20deg"
        max-field-of-view="120deg"
        shadow-intensity="1.5"
        shadow-softness="0.8"
        exposure="0.9"
        environment-image="neutral"
        interaction-prompt="none"
        disable-zoom
        disable-pan
        loading="eager"
        style="background: transparent;">
      </model-viewer>
      <!-- HP bars overlaid -->
      <div id="bc-hp-container" class="battle-hp-container">
        <div class="battle-hp-box player">
          <div class="battle-hp-name">YOU</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-player" class="battle-hp-bar-fill player" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-player-text" class="battle-hp-text">100 / 100</div>
        </div>
        <div class="battle-hp-box enemy">
          <div class="battle-hp-name" id="bc-enemy-name">OPPONENT</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-enemy" class="battle-hp-bar-fill enemy" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-enemy-text" class="battle-hp-text">100 / 100</div>
        </div>
      </div>
      <!-- Battle text overlay -->
      <div class="battle-overlay-text" id="bc-overlay-text">
        <div class="battle-text" id="bc-text-inner">BATTLE!</div>
      </div>
      <!-- Mana bar (above action buttons) -->
      <div id="bc-mana-container" class="battle-mana-container">
        <div class="battle-mana-label">SPECIAL <span id="bc-mana-pct">0%</span></div>
        <div class="battle-mana-bar-bg">
          <div id="bc-mana-fill" class="battle-mana-bar-fill" style="width: 0%;"></div>
        </div>
      </div>
      <!-- Action buttons (overlaid at bottom-right) -->
      <div id="bc-action-container" class="battle-action-container">
        <button id="bc-block-btn" class="battle-action-btn battle-block-btn" ontouchstart="combatBlock(event)" onmousedown="combatBlock(event)">
          <span class="action-btn-icon">ğŸ›¡ï¸</span>
          <span class="action-btn-label">BLOCK</span>
        </button>
        <button id="bc-bash-btn" class="battle-bash-btn" ontouchstart="combatBash(event)" onmousedown="combatBash(event)">
          <span class="bash-icon">ğŸ‘Š</span>
          <span class="bash-label">BASH!</span>
          <div class="bash-progress-ring">
            <svg viewBox="0 0 60 60">
              <circle cx="30" cy="30" r="26" class="bash-ring-bg"/>
              <circle cx="30" cy="30" r="26" class="bash-ring-fill" id="bash-ring-fill"/>
            </svg>
          </div>
        </button>
        <button id="bc-fire-btn" class="battle-action-btn battle-fire-btn" ontouchstart="combatFire(event)" onmousedown="combatFire(event)">
          <span class="action-btn-icon">ğŸ”¥</span>
          <span class="action-btn-label">FIRE!</span>
        </button>
      </div>
    </div>
    <!-- Info Panel (below viewport) -->
    <div class="battle-info-panel" id="battle-info-panel">
      <div class="battle-info-title">Arena Battle Mode</div>
      <div class="battle-info-opponent" id="battle-info-opponent">
        <canvas id="battle-info-avatar" width="56" height="64"></canvas>
        <div class="battle-info-opponent-details">
          <div class="battle-info-opponent-name" id="bc-info-name">Opponent</div>
          <div class="battle-info-opponent-level" id="bc-info-level">Level ??</div>
          <div class="battle-info-stat-row" id="bc-info-stats">
            <div class="battle-info-stat"><span>STR</span> <span class="battle-info-stat-val" id="bc-info-str">?</span></div>
            <div class="battle-info-stat"><span>HP</span> <span class="battle-info-stat-val" id="bc-info-hp">?</span></div>
            <div class="battle-info-stat"><span>DEF</span> <span class="battle-info-stat-val" id="bc-info-def">?</span></div>
          </div>
        </div>
      </div>
      <div class="battle-info-round-row">
        <div class="battle-round-info">
          ROUND <span id="bc-round">1</span> / 3
          <span class="battle-round-score" id="bc-round-dots">
            <span class="round-dot" id="rd1"></span>
            <span class="round-dot" id="rd2"></span>
            <span class="round-dot" id="rd3"></span>
          </span>
        </div>
        <div class="battle-timer" id="bc-timer">30</div>
      </div>
    </div>
  </div>
  <div class="battle-result" id="battle-result"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME OVER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="gameover-overlay" id="gameover-overlay">
  <div class="gameover-place first" id="gameover-place">#1</div>
  <div class="gameover-label" id="gameover-label">Victory!</div>
  <div class="gameover-sub" id="gameover-sub">You outlasted everyone in the arena</div>
  <div class="gameover-rewards">
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-coins">+50</div>
      <div class="gameover-reward-label">Coins</div>
    </div>
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-xp">+25</div>
      <div class="gameover-reward-label">XP</div>
    </div>
  </div>
  <button class="lobby-start-btn" onclick="returnToLobby()">Play Again</button>
  <button style="margin-top:10px;padding:10px 30px;border-radius:10px;background:var(--arena-surface);border:1px solid var(--arena-border);color:var(--arena-text);font-size:0.85rem;font-weight:600;cursor:pointer;" onclick="exitArena()">Exit</button>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FITGOTCHI ARENA - Battle Mode Proof of Concept
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ CONFIG â”€â”€
const ARENA_W = 4000;
const ARENA_H = 3000;
const TILE_SIZE = 60;
const PLAYER_RADIUS = 18;
const PLAYER_SPEED = 3;
const BOT_SPEED = 1.6;
const BATTLE_RANGE = 44;
const POWERUP_RADIUS = 14;

const BEAN_COLORS = [
  { name: 'Emerald',  body: '#10b981', dark: '#059669', visor: '#a7f3d0' },
  { name: 'Violet',   body: '#8b5cf6', dark: '#7c3aed', visor: '#c4b5fd' },
  { name: 'Coral',    body: '#ef4444', dark: '#dc2626', visor: '#fca5a5' },
  { name: 'Ocean',    body: '#3b82f6', dark: '#2563eb', visor: '#93c5fd' },
  { name: 'Amber',    body: '#f59e0b', dark: '#d97706', visor: '#fde68a' },
  { name: 'Rose',     body: '#ec4899', dark: '#db2777', visor: '#f9a8d4' },
  { name: 'Cyan',     body: '#06b6d4', dark: '#0891b2', visor: '#a5f3fc' },
  { name: 'Lime',     body: '#84cc16', dark: '#65a30d', visor: '#d9f99d' },
  { name: 'Slate',    body: '#64748b', dark: '#475569', visor: '#cbd5e1' },
  { name: 'White',    body: '#e2e8f0', dark: '#cbd5e1', visor: '#f8fafc' },
];

const POWERUP_TYPES = [
  { type: 'protein', icon: 'ğŸ¥¤', label: 'Protein Shake', effect: 'speed', duration: 6000, color: '#a78bfa' },
  { type: 'broccoli', icon: 'ğŸ¥¦', label: 'Shield Up', effect: 'shield', duration: 8000, color: '#10b981' },
  { type: 'dumbbell', icon: 'ğŸ‹ï¸', label: 'Power Up', effect: 'power', duration: 5000, color: '#ef4444' },
  { type: 'apple', icon: 'ğŸ', label: 'Heal', effect: 'heal', duration: 0, color: '#f59e0b' },
];

// Map obstacle tiles (1 = wall, 2 = table/equipment)
const MAP_OBSTACLES = [];

// â”€â”€ STATE â”€â”€
let canvas, ctx;
let gameState = 'lobby'; // lobby | playing | battle | gameover
let playerCount = 4;
let selectedColorIdx = 0;
let camera = { x: 0, y: 0 };
let player = null;
let bots = [];
let powerups = [];
let particles = [];
let battleState = null;
let inputDir = { x: 0, y: 0 };
let keys = {};
let joystickActive = false;
let joystickOrigin = { x: 0, y: 0 };
let frameCount = 0;
let lastTime = 0;
let eliminationOrder = [];

// Simulated fitness stats (would come from Supabase in prod)
// In production these are loaded from localStorage.battleStats + users table
let fitnessStats = {
  fitnessLevel: 65,
  energyLevel: 72,
  weeklyWorkoutCount: 4,
  level: 23,
  title: 'Growing',
  // Battle stats (STR/HP/MANA) - from the dashboard stat allocation system
  str: 15,   // Increases attack damage
  hp: 12,    // Increases max health pool (100 + hp*5)
  mana: 8,   // Reduces taps needed for special (max(10, 30 - mana/5))
};

// â”€â”€ INIT â”€â”€
function init() {
  canvas = document.getElementById('arena-canvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Read query params from dashboard launch
  const params = new URLSearchParams(window.location.search);
  if (params.get('players')) {
    playerCount = parseInt(params.get('players')) || 4;
    // Update lobby mode buttons
    document.querySelectorAll('.lobby-mode-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.textContent.trim() === playerCount + ' Players') btn.classList.add('selected');
    });
  }

  // Input
  window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.key] = false; });
  setupJoystick();

  // Color picker
  buildColorPicker();
  drawLobbyAvatar();

  // Generate map obstacles
  generateMap();

  // Start loop
  requestAnimationFrame(gameLoop);
}

function resizeCanvas() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

// â”€â”€ ROOM DEFINITIONS â”€â”€
const WALL = 16;
const DOOR = 100; // doorway gap size
const ROOMS = [
  { name: 'Kitchen',     x: 40,   y: 40,   w: 1200, h: 940,  floor: '#1a1f14', accent: '#2d4a1e', wallColor: '#2a3d1e', wallHighlight: '#3a5530', floorType: 'checker-tile', tileColor1: '#1e2818', tileColor2: '#242e1c', trimColor: '#4a6a35' },
  { name: 'Cafeteria',   x: 1300, y: 40,   w: 1400, h: 940,  floor: '#1a1420', accent: '#3d1e4a', wallColor: '#2e1a3a', wallHighlight: '#42284e', floorType: 'linoleum', tileColor1: '#1e1628', tileColor2: '#221a2c', trimColor: '#6a3a8a' },
  { name: 'Living Room', x: 2760, y: 40,   w: 1200, h: 940,  floor: '#1a1a28', accent: '#1e2d4a', wallColor: '#1e2540', wallHighlight: '#283558', floorType: 'wood', tileColor1: '#1e1e30', tileColor2: '#222238', trimColor: '#3a5088' },
  { name: 'Bathroom',    x: 40,   y: 1040, w: 900,  h: 920,  floor: '#141a1a', accent: '#1e3a4a', wallColor: '#1a2e35', wallHighlight: '#244048', floorType: 'small-tile', tileColor1: '#182224', tileColor2: '#1c2628', trimColor: '#2a5a6a' },
  { name: 'Hallway',     x: 1000, y: 1040, w: 2000, h: 920,  floor: '#18181f', accent: '#333340', wallColor: '#252530', wallHighlight: '#353545', floorType: 'metal', tileColor1: '#1a1a24', tileColor2: '#1e1e28', trimColor: '#555568' },
  { name: 'Bedroom',     x: 3060, y: 1040, w: 900,  h: 920,  floor: '#201a1a', accent: '#4a1e2d', wallColor: '#381a28', wallHighlight: '#4c2838', floorType: 'carpet', tileColor1: '#241c1c', tileColor2: '#281e1e', trimColor: '#7a3050' },
  { name: 'Gym',         x: 40,   y: 2020, w: 1200, h: 940,  floor: '#1f1a14', accent: '#4a3a1e', wallColor: '#352a18', wallHighlight: '#4a3a24', floorType: 'rubber', tileColor1: '#221c14', tileColor2: '#282018', trimColor: '#7a5a2a' },
  { name: 'Garden',      x: 1300, y: 2020, w: 1400, h: 940,  floor: '#142014', accent: '#1e4a28', wallColor: '#1a3018', wallHighlight: '#264524', floorType: 'grass', tileColor1: '#162216', tileColor2: '#1a2a1a', trimColor: '#3a7a40' },
  { name: 'Garage',      x: 2760, y: 2020, w: 1200, h: 940,  floor: '#1a1a1a', accent: '#3a3a3a', wallColor: '#282828', wallHighlight: '#383838', floorType: 'concrete', tileColor1: '#1e1e1e', tileColor2: '#222222', trimColor: '#555555' },
];

// â”€â”€ NON-COLLISION FLOOR DECORATIONS â”€â”€
const FLOOR_DECORATIONS = [];

// â”€â”€ MAP GENERATION â”€â”€
function generateMap() {
  MAP_OBSTACLES.length = 0;

  // Helper: add a wall segment
  function wall(x, y, w, h) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'wall' });
  }
  // Helper: add furniture
  function furniture(x, y, w, h, icon, label) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'furniture', icon, label });
  }

  // â”€â”€â”€ ROOM WALLS (with doorways) â”€â”€â”€

  // Kitchen walls
  wall(40, 40, 1200, WALL);              // top
  wall(40, 40, WALL, 940);               // left
  wall(40, 980 - WALL, 500, WALL);       // bottom-left
  wall(500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(1240 - WALL, 40, WALL, 400);      // right-top
  wall(1240 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Cafeteria walls
  wall(1300, 40, 1400, WALL);            // top
  wall(1300, 980 - WALL, 600, WALL);     // bottom-left
  wall(1300 + 600 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(2700 - WALL, 40, WALL, 400);      // right-top
  wall(2700 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Living Room walls
  wall(2760, 40, 1200, WALL);            // top
  wall(3960 - WALL, 40, WALL, 940);      // right
  wall(2760, 980 - WALL, 500, WALL);     // bottom-left
  wall(2760 + 500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right

  // Bathroom walls
  wall(40, 1040, WALL, 920);             // left
  wall(40, 1040, 900, WALL);             // top (shared)
  wall(40, 1960 - WALL, 400, WALL);      // bottom-left
  wall(400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right
  wall(940 - WALL, 1040, WALL, 400);     // right-top
  wall(940 - WALL, 1040 + 400 + DOOR, WALL, 520 - DOOR - WALL); // right-bottom

  // Hallway (open area, just top/bottom walls with doorways)
  wall(1000, 1040, 800, WALL);           // top-left section
  wall(1000 + 800 + DOOR, 1040, 1100 - DOOR, WALL); // top-right section
  wall(1000, 1960 - WALL, 700, WALL);    // bottom-left
  wall(1000 + 700 + DOOR, 1960 - WALL, 1200 - DOOR, WALL); // bottom-right

  // Bedroom walls
  wall(3060, 1040, 900, WALL);           // top
  wall(3960 - WALL, 1040, WALL, 920);    // right
  wall(3060, 1960 - WALL, 400, WALL);    // bottom-left
  wall(3060 + 400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right

  // Gym walls
  wall(40, 2020, WALL, 940);             // left
  wall(40, 2020, 1200, WALL);            // top
  wall(40, 2960 - WALL, 1200, WALL);     // bottom
  wall(1240 - WALL, 2020, WALL, 400);    // right-top
  wall(1240 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garden walls
  wall(1300, 2020, 600, WALL);           // top-left
  wall(1300 + 600 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(1300, 2960 - WALL, 1400, WALL);   // bottom
  wall(2700 - WALL, 2020, WALL, 400);    // right-top
  wall(2700 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garage walls
  wall(2760, 2020, 500, WALL);           // top-left
  wall(2760 + 500 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(3960 - WALL, 2020, WALL, 940);    // right
  wall(2760, 2960 - WALL, 1200, WALL);   // bottom

  // â”€â”€â”€ FURNITURE â”€â”€â”€

  // Kitchen (much more detailed)
  furniture(100, 100, 200, 60, 'ğŸ³', 'Stove');
  furniture(100, 200, 70, 140, 'ğŸ§Š', 'Fridge');
  furniture(350, 100, 300, 50, 'ğŸ”ª', 'Counter');
  furniture(750, 100, 120, 50, 'ğŸ½ï¸', 'Sink');
  furniture(950, 100, 100, 50, 'ğŸ”ª', 'Counter');
  furniture(500, 480, 200, 110, 'ğŸª‘', 'Table');
  furniture(900, 400, 80, 80, 'ğŸ—‘ï¸', 'Bin');
  furniture(100, 400, 100, 60, 'ğŸ§Š', 'Dishwasher');
  furniture(250, 100, 80, 50, 'ğŸ½ï¸', 'Microwave');
  furniture(100, 700, 60, 80, 'ğŸ“‹', 'Pantry');
  furniture(800, 700, 120, 50, 'ğŸ”ª', 'Counter');
  furniture(400, 750, 100, 60, 'ğŸ“‹', 'Spice Rack');
  furniture(700, 300, 80, 60, 'ğŸ§¹', 'Mop Bucket');

  // Cafeteria (more tables, food service area)
  furniture(1450, 180, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 180, 200, 80, 'ğŸª‘', 'Table');
  furniture(1450, 450, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 450, 200, 80, 'ğŸª‘', 'Table');
  furniture(2050, 300, 200, 80, 'ğŸª‘', 'Table');
  furniture(1450, 720, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 720, 200, 80, 'ğŸª‘', 'Table');
  furniture(2350, 150, 80, 200, 'ğŸ¥¤', 'Vending');
  furniture(2500, 150, 80, 200, 'ğŸ¥¤', 'Vending');
  furniture(2050, 100, 200, 50, 'ğŸ½ï¸', 'Food Counter');
  furniture(2350, 600, 100, 60, 'ğŸ—‘ï¸', 'Bin');
  furniture(1350, 100, 80, 50, 'ğŸ“‹', 'Menu Board');
  furniture(2100, 700, 80, 80, 'ğŸ§¹', 'Mop Bucket');
  furniture(2500, 700, 60, 60, 'ğŸ’¡', 'Lamp');

  // Living Room (cozy, full of stuff)
  furniture(2900, 180, 300, 70, 'ğŸ›‹ï¸', 'Couch');
  furniture(3350, 80, 140, 100, 'ğŸ“º', 'TV');
  furniture(2880, 480, 130, 70, 'ğŸª‘', 'Armchair');
  furniture(3100, 420, 120, 70, 'â˜•', 'Coffee Table');
  furniture(3550, 480, 80, 140, 'ğŸ“š', 'Bookshelf');
  furniture(3700, 180, 60, 60, 'ğŸª´', 'Plant');
  furniture(3550, 80, 80, 60, 'ğŸ”Š', 'Speaker');
  furniture(2830, 80, 50, 50, 'ğŸ’¡', 'Lamp');
  furniture(3300, 500, 100, 60, 'ğŸª‘', 'Armchair');
  furniture(3100, 700, 180, 100, 'ğŸ“‹', 'Rug Display');
  furniture(2900, 700, 80, 60, 'ğŸ“‹', 'Side Table');
  furniture(3700, 400, 60, 60, 'ğŸª´', 'Plant');
  furniture(3680, 700, 80, 80, 'ğŸ“¦', 'Storage Ottoman');

  // Bathroom (more fixtures)
  furniture(100, 1120, 120, 100, 'ğŸš¿', 'Shower');
  furniture(100, 1380, 80, 60, 'ğŸª¥', 'Sink');
  furniture(350, 1120, 60, 60, 'ğŸš½', 'Toilet');
  furniture(570, 1100, 140, 70, 'ğŸ›', 'Bathtub');
  furniture(570, 1600, 70, 70, 'ğŸ§º', 'Laundry');
  furniture(350, 1300, 60, 60, 'ğŸ§»', 'Toilet Paper');
  furniture(100, 1550, 70, 100, 'ğŸ“‹', 'Medicine Cabinet');
  furniture(250, 1700, 80, 60, 'ğŸ§¹', 'Mop Bucket');
  furniture(700, 1350, 60, 60, 'ğŸª', 'Mirror');
  furniture(500, 1700, 70, 70, 'ğŸ§º', 'Laundry');
  furniture(350, 1500, 50, 50, 'ğŸ§¹', 'Plunger');

  // Hallway (industrial feel, signs, vents, panels)
  furniture(1150, 1180, 60, 60, 'ğŸª´', 'Plant');
  furniture(1700, 1320, 120, 50, 'ğŸ–¼ï¸', 'Bench');
  furniture(2350, 1180, 60, 60, 'ğŸª´', 'Plant');
  furniture(1450, 1580, 80, 80, 'ğŸ—„ï¸', 'Cabinet');
  furniture(2000, 1130, 60, 60, 'ğŸ’¡', 'Lamp');
  furniture(1300, 1600, 60, 60, 'ğŸ“‹', 'Fire Extinguisher');
  furniture(2600, 1600, 80, 60, 'ğŸ“‹', 'Wall Panel');
  furniture(1900, 1600, 60, 60, 'ğŸ—‘ï¸', 'Bin');
  furniture(2700, 1300, 80, 60, 'ğŸ“‹', 'Control Panel');
  furniture(1600, 1180, 70, 50, 'ğŸ“‹', 'Sign Post');
  furniture(2200, 1580, 60, 60, 'ğŸ’¡', 'Lamp');
  furniture(1100, 1450, 60, 60, 'ğŸ“‹', 'Emergency Light');
  furniture(2800, 1450, 60, 60, 'ğŸ“‹', 'Emergency Light');

  // Bedroom (lived-in feel)
  furniture(3200, 1130, 220, 130, 'ğŸ›ï¸', 'Bed');
  furniture(3620, 1130, 110, 80, 'ğŸ’»', 'Desk');
  furniture(3620, 1480, 90, 130, 'ğŸ‘”', 'Wardrobe');
  furniture(3130, 1480, 60, 60, 'ğŸª´', 'Plant');
  furniture(3770, 1330, 60, 60, 'ğŸª', 'Mirror');
  furniture(3130, 1130, 50, 50, 'ğŸ“‹', 'Nightstand');
  furniture(3450, 1130, 50, 50, 'ğŸ“‹', 'Nightstand');
  furniture(3750, 1130, 60, 50, 'ğŸ“‹', 'Bookshelf Small');
  furniture(3450, 1500, 80, 60, 'ğŸ“¦', 'Boxes');
  furniture(3200, 1700, 80, 60, 'ğŸ§º', 'Laundry');
  furniture(3500, 1700, 60, 60, 'ğŸ’¡', 'Lamp');

  // Gym (packed with equipment)
  furniture(180, 2130, 150, 65, 'ğŸ‹ï¸', 'Bench Press');
  furniture(480, 2130, 110, 65, 'ğŸ‹ï¸', 'Weights');
  furniture(180, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(360, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(550, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(680, 2260, 130, 65, 'ğŸ’ª', 'Dumbbells');
  furniture(900, 2460, 85, 85, 'ğŸ¥Š', 'Punching Bag');
  furniture(680, 2620, 110, 55, 'ğŸ§˜', 'Yoga Mat');
  furniture(900, 2130, 100, 65, 'ğŸ‹ï¸', 'Weights');
  furniture(1050, 2300, 80, 80, 'ğŸ’ª', 'Kettlebells');
  furniture(180, 2700, 100, 60, 'ğŸ“‹', 'Gym Mirror');
  furniture(400, 2700, 80, 80, 'ğŸ“‹', 'Water Cooler');
  furniture(1050, 2500, 80, 60, 'ğŸ“‹', 'Foam Roller');
  furniture(850, 2700, 110, 55, 'ğŸ§˜', 'Yoga Mat');

  // Garden (lush and full)
  furniture(1420, 2180, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(1780, 2120, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(2180, 2380, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(2450, 2600, 100, 100, 'ğŸŒ³', 'Tree');
  furniture(1480, 2530, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(1950, 2580, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(2350, 2200, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(1680, 2380, 130, 80, 'â›²', 'Fountain');
  furniture(2450, 2180, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(1400, 2400, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(2100, 2150, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(1600, 2700, 80, 80, 'ğŸ“‹', 'Garden Bench');
  furniture(2300, 2700, 80, 80, 'ğŸ“‹', 'Bird Bath');
  furniture(1350, 2750, 80, 60, 'ğŸŒ¿', 'Bush');
  furniture(2550, 2450, 60, 60, 'ğŸª´', 'Plant');
  furniture(2000, 2250, 80, 60, 'ğŸ“‹', 'Flower Pot');

  // Garage (workshop feel)
  furniture(2880, 2180, 240, 130, 'ğŸš—', 'Car');
  furniture(3280, 2130, 90, 210, 'ğŸ”§', 'Workbench');
  furniture(3530, 2130, 130, 65, 'ğŸ§°', 'Toolbox');
  furniture(2880, 2530, 110, 90, 'ğŸ›¢ï¸', 'Barrel');
  furniture(3180, 2580, 110, 90, 'ğŸ“¦', 'Boxes');
  furniture(3620, 2480, 65, 110, 'ğŸªœ', 'Ladder');
  furniture(3530, 2350, 100, 60, 'ğŸ§°', 'Toolbox');
  furniture(2880, 2750, 100, 80, 'ğŸ›¢ï¸', 'Barrel');
  furniture(3450, 2750, 80, 60, 'ğŸ“¦', 'Boxes');
  furniture(3700, 2130, 80, 60, 'ğŸ“‹', 'Shelving');
  furniture(3700, 2300, 80, 80, 'ğŸ“‹', 'Oil Can');
  furniture(3200, 2800, 80, 50, 'ğŸ“‹', 'Floor Jack');

  // â”€â”€â”€ FLOOR DECORATIONS (non-collision) â”€â”€â”€
  FLOOR_DECORATIONS.length = 0;
  function decor(x, y, w, h, type, extra) {
    FLOOR_DECORATIONS.push({ x, y, w, h, type, ...extra });
  }

  // Kitchen floor decorations
  decor(300, 600, 200, 150, 'rug', { color: 'rgba(80,120,60,0.1)', border: 'rgba(100,140,80,0.08)' });
  decor(700, 600, 40, 20, 'vent', {});

  // Cafeteria vents and floor marks
  decor(1600, 350, 50, 30, 'vent', {});
  decor(2200, 250, 50, 30, 'vent', {});
  decor(1400, 850, 100, 8, 'floor-mark', { color: 'rgba(255,200,0,0.04)' });
  decor(2400, 850, 100, 8, 'floor-mark', { color: 'rgba(255,200,0,0.04)' });

  // Living Room rug
  decor(2950, 350, 250, 180, 'rug', { color: 'rgba(60,60,120,0.12)', border: 'rgba(80,80,150,0.1)' });
  decor(3400, 350, 80, 20, 'cable', { color: 'rgba(40,40,40,0.15)' });

  // Bathroom puddle and drain
  decor(280, 1250, 60, 40, 'puddle', {});
  decor(500, 1500, 20, 20, 'drain', {});
  decor(200, 1700, 100, 60, 'mat', { color: 'rgba(60,100,100,0.12)' });

  // Hallway: vents, warning stripes, cables
  decor(1100, 1350, 60, 30, 'vent', {});
  decor(1500, 1250, 60, 30, 'vent', {});
  decor(2100, 1350, 60, 30, 'vent', {});
  decor(2600, 1250, 60, 30, 'vent', {});
  decor(1050, 1700, 200, 12, 'warning-stripes', {});
  decor(2700, 1700, 200, 12, 'warning-stripes', {});
  decor(1350, 1300, 80, 40, 'cable', { color: 'rgba(200,50,50,0.08)' });
  decor(2300, 1400, 100, 30, 'cable', { color: 'rgba(50,100,200,0.08)' });
  decor(1800, 1150, 100, 10, 'floor-mark', { color: 'rgba(255,200,0,0.03)' });

  // Bedroom rug
  decor(3200, 1320, 200, 140, 'rug', { color: 'rgba(100,40,60,0.1)', border: 'rgba(130,60,80,0.08)' });

  // Gym floor markings
  decor(100, 2350, 1100, 8, 'floor-mark', { color: 'rgba(255,255,255,0.02)' });
  decor(600, 2100, 8, 600, 'floor-mark', { color: 'rgba(255,255,255,0.02)' });
  decor(300, 2350, 80, 50, 'mat', { color: 'rgba(60,30,80,0.12)' });
  decor(700, 2500, 40, 20, 'vent', {});

  // Garden path stones (some extra)
  decor(1500, 2450, 60, 40, 'mat', { color: 'rgba(100,90,80,0.08)' });
  decor(2100, 2500, 60, 40, 'mat', { color: 'rgba(100,90,80,0.08)' });

  // Garage: tire marks, oil, warning stripes
  decor(2850, 2400, 200, 300, 'tire-marks', {});
  decor(2800, 2900, 400, 14, 'warning-stripes', {});
  decor(3500, 2600, 50, 30, 'vent', {});
  decor(3300, 2450, 60, 40, 'mat', { color: 'rgba(40,40,40,0.15)' });
}

// â”€â”€ COLOR PICKER â”€â”€
function buildColorPicker() {
  const container = document.getElementById('color-picker');
  container.innerHTML = BEAN_COLORS.map((c, i) => `
    <button class="lobby-color-btn ${i === 0 ? 'selected' : ''}"
      style="background:${c.body};"
      onclick="selectColor(${i})"
      title="${c.name}"></button>
  `).join('');
}

function selectColor(idx) {
  selectedColorIdx = idx;
  document.querySelectorAll('.lobby-color-btn').forEach((btn, i) => {
    btn.classList.toggle('selected', i === idx);
  });
  drawLobbyAvatar();
}

function selectMode(btn, count) {
  playerCount = count;
  document.querySelectorAll('.lobby-mode-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
}

// â”€â”€ DRAW BEAN CHARACTER â”€â”€
function drawBean(ctx, x, y, color, scale = 1, facingLeft = false, name = '', isShielded = false, isPowered = false) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);
  if (facingLeft) ctx.scale(-1, 1);

  // Walking bob animation
  const time = frameCount / 60;
  const isMoving = Math.abs(inputDir.x) > 0.1 || Math.abs(inputDir.y) > 0.1;
  const walkBob = isMoving ? Math.sin(time * 12) * 1.5 : 0;
  const legPhase = isMoving ? Math.sin(time * 12) * 3 : 0;

  // Ground shadow (dynamic size based on movement)
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(0, 24, 16 + (isMoving ? 1 : 0), 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Shield glow (enhanced with pulsing)
  if (isShielded) {
    const shieldPulse = Math.sin(time * 4) * 0.15 + 0.85;
    ctx.strokeStyle = `rgba(16,185,129,${0.5 * shieldPulse})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, -2, 28, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = `rgba(16,185,129,${0.15 * shieldPulse})`;
    ctx.lineWidth = 8;
    ctx.stroke();
    // Shield hexagon pattern
    ctx.strokeStyle = `rgba(16,185,129,${0.1 * shieldPulse})`;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 6; i++) {
      const a1 = (i / 6) * Math.PI * 2;
      const a2 = ((i + 1) / 6) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a1) * 26, -2 + Math.sin(a1) * 26);
      ctx.lineTo(Math.cos(a2) * 26, -2 + Math.sin(a2) * 26);
      ctx.stroke();
    }
  }

  // Power glow (enhanced with particles effect)
  if (isPowered) {
    ctx.shadowColor = 'rgba(239,68,68,0.6)';
    ctx.shadowBlur = 18;
    // Power aura
    ctx.fillStyle = 'rgba(239,68,68,0.06)';
    ctx.beginPath();
    ctx.arc(0, -2, 24, 0, Math.PI * 2);
    ctx.fill();
  }

  // Apply walk bob to whole character
  ctx.translate(0, walkBob * 0.5);

  // Backpack (Among Us style - more detailed)
  ctx.fillStyle = color.dark;
  ctx.beginPath();
  ctx.roundRect(-22, -10, 12, 24, 5);
  ctx.fill();
  // Backpack detail line
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-22, -2); ctx.lineTo(-10, -2);
  ctx.stroke();
  // Backpack highlight
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(-21, -9, 3, 10);

  // Body (bean shape - enhanced with gradient)
  const bodyGrd = ctx.createLinearGradient(-14, -24, 14, 24);
  bodyGrd.addColorStop(0, color.body);
  bodyGrd.addColorStop(0.7, color.body);
  bodyGrd.addColorStop(1, color.dark);
  ctx.fillStyle = bodyGrd;
  ctx.beginPath();
  ctx.moveTo(-14, 20);
  ctx.lineTo(-14, -8);
  ctx.quadraticCurveTo(-14, -24, 0, -24);
  ctx.quadraticCurveTo(14, -24, 14, -8);
  ctx.lineTo(14, 20);
  ctx.quadraticCurveTo(14, 24, 8, 24);
  ctx.lineTo(3, 24);
  ctx.lineTo(3, 20);
  ctx.lineTo(-3, 20);
  ctx.lineTo(-3, 24);
  ctx.lineTo(-8, 24);
  ctx.quadraticCurveTo(-14, 24, -14, 20);
  ctx.fill();

  // Body outline
  ctx.strokeStyle = color.dark;
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-14, 20);
  ctx.lineTo(-14, -8);
  ctx.quadraticCurveTo(-14, -24, 0, -24);
  ctx.quadraticCurveTo(14, -24, 14, -8);
  ctx.lineTo(14, 20);
  ctx.stroke();

  // Body highlight (left side shine)
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.moveTo(-12, 10);
  ctx.lineTo(-12, -6);
  ctx.quadraticCurveTo(-12, -20, -4, -22);
  ctx.lineTo(-8, -20);
  ctx.quadraticCurveTo(-10, -16, -10, -4);
  ctx.lineTo(-10, 10);
  ctx.closePath();
  ctx.fill();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // Visor (Among Us style - enhanced with depth)
  // Visor shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(6, -5, 10.5, 8.5, 0.15, 0, Math.PI * 2);
  ctx.fill();
  // Visor main
  const visorGrd = ctx.createRadialGradient(8, -8, 2, 6, -6, 10);
  visorGrd.addColorStop(0, '#fff');
  visorGrd.addColorStop(0.3, color.visor);
  visorGrd.addColorStop(1, color.dark);
  ctx.fillStyle = visorGrd;
  ctx.beginPath();
  ctx.ellipse(6, -6, 10, 8, 0.15, 0, Math.PI * 2);
  ctx.fill();

  // Visor shine (two spots for realism)
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.beginPath();
  ctx.ellipse(9, -9, 3.5, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath();
  ctx.ellipse(4, -3, 2, 1.5, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Legs (with walking animation)
  ctx.fillStyle = color.dark;
  ctx.fillRect(-10, 20 - legPhase * 0.3, 6, 6 + Math.abs(legPhase) * 0.2);
  ctx.fillRect(4, 20 + legPhase * 0.3, 6, 6 + Math.abs(legPhase) * 0.2);

  // Feet (with walking step)
  ctx.fillStyle = color.body;
  ctx.beginPath();
  ctx.roundRect(-12, 24 - legPhase * 0.3, 10, 5, [0, 0, 3, 3]);
  ctx.fill();
  ctx.beginPath();
  ctx.roundRect(2, 24 + legPhase * 0.3, 10, 5, [0, 0, 3, 3]);
  ctx.fill();

  // Bone (belly marking - subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-4, 6); ctx.lineTo(4, 6);
  ctx.stroke();

  if (facingLeft) ctx.scale(-1, 1);

  // Name tag (enhanced with background)
  if (name) {
    ctx.font = '600 9px Inter, sans-serif';
    ctx.textAlign = 'center';
    const tw = ctx.measureText(name).width;
    // Name background
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(-tw / 2 - 4, -37, tw + 8, 13, 3);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText(name, 0, -28);
  }

  ctx.restore();
}

function drawLobbyAvatar() {
  const c = document.getElementById('lobby-avatar');
  const lctx = c.getContext('2d');
  lctx.clearRect(0, 0, c.width, c.height);
  drawBean(lctx, 70, 90, BEAN_COLORS[selectedColorIdx], 2.5, false, '');
}

// â”€â”€ GAME START â”€â”€
function startGame() {
  document.getElementById('lobby').classList.add('hidden');
  document.getElementById('hud').style.display = '';
  document.getElementById('players-alive').style.display = '';
  document.getElementById('action-zone').style.display = '';
  document.getElementById('dpad-hint').style.display = '';
  gameState = 'playing';

  // Create player
  player = {
    x: ARENA_W / 2,
    y: ARENA_H / 2,
    color: BEAN_COLORS[selectedColorIdx],
    name: 'You',
    hp: 3,
    kills: 0,
    speed: PLAYER_SPEED,
    facingLeft: false,
    alive: true,
    powerups: [],
    invincibleUntil: 0,
  };

  // Create bots
  bots = [];
  const botNames = ['FitFrog', 'GymRat', 'IronChef', 'CardioKing', 'FlexBot', 'GainzGuru', 'RunBuddy', 'LiftLord'];
  const usedColors = [selectedColorIdx];

  for (let i = 0; i < playerCount - 1; i++) {
    let colorIdx;
    do { colorIdx = Math.floor(Math.random() * BEAN_COLORS.length); }
    while (usedColors.includes(colorIdx));
    usedColors.push(colorIdx);

    const angle = (Math.PI * 2 * i) / (playerCount - 1);
    const dist = 400 + Math.random() * 300;
    bots.push({
      x: ARENA_W / 2 + Math.cos(angle) * dist,
      y: ARENA_H / 2 + Math.sin(angle) * dist,
      color: BEAN_COLORS[colorIdx],
      name: botNames[i % botNames.length],
      hp: 3,
      alive: true,
      facingLeft: false,
      speed: BOT_SPEED,
      powerups: [],
      invincibleUntil: 0,
      // AI state
      ai: {
        targetX: 0, targetY: 0,
        nextDecision: 0,
        state: 'wander', // wander | chase | flee | powerup
        targetEntity: null,
      },
      fitnessLevel: 30 + Math.floor(Math.random() * 50),
    });
  }

  // Spawn powerups
  spawnPowerups(8);

  eliminationOrder = [];
  showNotification('Arena started! Find and battle opponents!');
}

function spawnPowerups(count) {
  for (let i = 0; i < count; i++) {
    const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    let x, y, valid;
    // Ensure powerup doesn't overlap obstacles
    do {
      x = 80 + Math.random() * (ARENA_W - 160);
      y = 80 + Math.random() * (ARENA_H - 160);
      valid = !MAP_OBSTACLES.some(o =>
        x > o.x - 20 && x < o.x + o.w + 20 &&
        y > o.y - 20 && y < o.y + o.h + 20
      );
    } while (!valid);

    powerups.push({
      x, y, ...type,
      bobPhase: Math.random() * Math.PI * 2,
      alive: true,
    });
  }
}

// â”€â”€ JOYSTICK â”€â”€
function setupJoystick() {
  const zone = document.getElementById('joystick-zone');
  const base = document.getElementById('joystick-base');
  const thumb = document.getElementById('joystick-thumb');
  const dpadHint = document.getElementById('dpad-hint');

  zone.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    const t = e.touches[0];
    joystickActive = true;
    joystickOrigin = { x: t.clientX, y: t.clientY };
    base.style.display = 'block';
    base.style.left = (t.clientX - 60) + 'px';
    base.style.top = (t.clientY - 60) + 'px';
    thumb.style.display = 'block';
    thumb.style.left = (t.clientX - 25) + 'px';
    thumb.style.top = (t.clientY - 25) + 'px';
    if (dpadHint) dpadHint.classList.add('active');
  }, { passive: false });

  zone.addEventListener('touchmove', e => {
    e.preventDefault();
    e.stopPropagation();
    if (!joystickActive) return;
    const t = e.touches[0];
    const dx = t.clientX - joystickOrigin.x;
    const dy = t.clientY - joystickOrigin.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    const maxDist = 50;
    const clampDist = Math.min(d, maxDist);
    const angle = Math.atan2(dy, dx);

    const thumbX = joystickOrigin.x + Math.cos(angle) * clampDist;
    const thumbY = joystickOrigin.y + Math.sin(angle) * clampDist;
    thumb.style.left = (thumbX - 25) + 'px';
    thumb.style.top = (thumbY - 25) + 'px';

    inputDir.x = (clampDist / maxDist) * Math.cos(angle);
    inputDir.y = (clampDist / maxDist) * Math.sin(angle);
  }, { passive: false });

  const endJoystick = () => {
    joystickActive = false;
    inputDir = { x: 0, y: 0 };
    base.style.display = 'none';
    thumb.style.display = 'none';
    if (dpadHint) dpadHint.classList.remove('active');
  };
  zone.addEventListener('touchend', endJoystick);
  zone.addEventListener('touchcancel', endJoystick);

  // Also listen on canvas itself for taps on right side â†’ tap-to-move
  canvas.addEventListener('touchstart', e => {
    if (gameState !== 'playing' || !player) return;
    const t = e.touches[0];
    // Only if tapping right half (joystick zone is left half)
    if (t.clientX > window.innerWidth * 0.5) {
      e.preventDefault();
      const worldX = t.clientX + camera.x;
      const worldY = t.clientY + camera.y;
      // Set a move target the player walks toward
      player._moveTarget = { x: worldX, y: worldY };
    }
  }, { passive: false });
}

// â”€â”€ GAME LOOP â”€â”€
function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 16.67, 3); // normalize to ~60fps
  lastTime = timestamp;
  frameCount++;

  if (gameState === 'playing') {
    updateInput();
    updatePlayer(dt);
    updateBots(dt);
    checkCollisions();
    updatePowerups(dt);
    updateParticles(dt);
    updateCamera();
    checkGameOver();
  }

  render();
  requestAnimationFrame(gameLoop);
}

// â”€â”€ INPUT â”€â”€
function updateInput() {
  if (joystickActive) return; // joystick takes priority

  inputDir = { x: 0, y: 0 };
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) inputDir.x = -1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) inputDir.x = 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) inputDir.y = -1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) inputDir.y = 1;

  // Normalize
  const len = Math.sqrt(inputDir.x ** 2 + inputDir.y ** 2);
  if (len > 1) {
    inputDir.x /= len;
    inputDir.y /= len;
  }
}

// â”€â”€ PLAYER UPDATE â”€â”€
function updatePlayer(dt) {
  if (!player || !player.alive) return;

  let moveX = inputDir.x;
  let moveY = inputDir.y;

  // Tap-to-move: walk toward target if no joystick/keyboard input
  if (moveX === 0 && moveY === 0 && player._moveTarget) {
    const dx = player._moveTarget.x - player.x;
    const dy = player._moveTarget.y - player.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > 5) {
      moveX = dx / d;
      moveY = dy / d;
    } else {
      player._moveTarget = null;
    }
  }

  const speed = player.speed * (hasActivePowerup(player, 'speed') ? 1.6 : 1) * dt;
  let nx = player.x + moveX * speed;
  let ny = player.y + moveY * speed;

  // Facing direction
  if (moveX < -0.1) player.facingLeft = true;
  if (moveX > 0.1) player.facingLeft = false;

  // Bounds
  nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
  ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

  // Obstacle collision
  if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
    player.x = nx;
    player.y = ny;
  } else if (!collidesWithObstacle(nx, player.y, PLAYER_RADIUS)) {
    player.x = nx;
  } else if (!collidesWithObstacle(player.x, ny, PLAYER_RADIUS)) {
    player.y = ny;
  }

  // Cancel tap-to-move on manual input
  if (inputDir.x !== 0 || inputDir.y !== 0) player._moveTarget = null;

  // Powerup expiry
  player.powerups = player.powerups.filter(p => Date.now() < p.expires);
  updatePowerupUI(player);
}

// â”€â”€ BOT AI â”€â”€
function updateBots(dt) {
  const now = Date.now();
  bots.forEach(bot => {
    if (!bot.alive) return;

    const ai = bot.ai;

    // Decision timer
    if (now > ai.nextDecision) {
      ai.nextDecision = now + 1500 + Math.random() * 2000;

      // Find nearest alive entity
      let nearestBot = null;
      let nearestDist = Infinity;
      const allTargets = [player, ...bots].filter(e => e !== bot && e.alive);

      allTargets.forEach(target => {
        const d = dist(bot, target);
        if (d < nearestDist) {
          nearestDist = d;
          nearestBot = target;
        }
      });

      // Find nearest powerup
      let nearestPU = null;
      let nearestPUDist = Infinity;
      powerups.forEach(pu => {
        if (!pu.alive) return;
        const d = dist(bot, pu);
        if (d < nearestPUDist) {
          nearestPUDist = d;
          nearestPU = pu;
        }
      });

      // Decide behavior
      if (bot.hp <= 1 && nearestDist < 200) {
        // Low HP - flee from nearest
        ai.state = 'flee';
        ai.targetEntity = nearestBot;
      } else if (nearestPU && nearestPUDist < 300 && bot.powerups.length === 0) {
        // Go for nearby powerup
        ai.state = 'powerup';
        ai.targetX = nearestPU.x;
        ai.targetY = nearestPU.y;
      } else if (nearestBot && nearestDist < 350) {
        // Chase nearby opponent
        ai.state = 'chase';
        ai.targetEntity = nearestBot;
      } else {
        // Wander
        ai.state = 'wander';
        ai.targetX = 100 + Math.random() * (ARENA_W - 200);
        ai.targetY = 100 + Math.random() * (ARENA_H - 200);
      }
    }

    // Move based on AI state
    let tx, ty;
    if (ai.state === 'flee' && ai.targetEntity && ai.targetEntity.alive) {
      const dx = bot.x - ai.targetEntity.x;
      const dy = bot.y - ai.targetEntity.y;
      const d = Math.sqrt(dx * dx + dy * dy) || 1;
      tx = bot.x + (dx / d) * 200;
      ty = bot.y + (dy / d) * 200;
    } else if (ai.state === 'chase' && ai.targetEntity && ai.targetEntity.alive) {
      tx = ai.targetEntity.x;
      ty = ai.targetEntity.y;
    } else {
      tx = ai.targetX;
      ty = ai.targetY;
    }

    const dx = tx - bot.x;
    const dy = ty - bot.y;
    const d = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = bot.speed * (hasActivePowerup(bot, 'speed') ? 1.5 : 1) * dt;

    if (d > 5) {
      let nx = bot.x + (dx / d) * speed;
      let ny = bot.y + (dy / d) * speed;

      nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
      ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

      if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
        bot.x = nx;
        bot.y = ny;
      } else if (!collidesWithObstacle(nx, bot.y, PLAYER_RADIUS)) {
        bot.x = nx;
      } else if (!collidesWithObstacle(bot.x, ny, PLAYER_RADIUS)) {
        bot.y = ny;
      }

      bot.facingLeft = dx < 0;
    }

    // Bot powerup expiry
    bot.powerups = bot.powerups.filter(p => Date.now() < p.expires);
  });
}

// â”€â”€ COLLISIONS â”€â”€
function checkCollisions() {
  if (!player || !player.alive) return;
  const now = Date.now();

  // Player vs bots
  bots.forEach(bot => {
    if (!bot.alive) return;
    if (now < player.invincibleUntil || now < bot.invincibleUntil) return;

    const d = dist(player, bot);
    if (d < BATTLE_RANGE) {
      startBattle(bot);
    }
  });

  // Bot vs bot
  for (let i = 0; i < bots.length; i++) {
    for (let j = i + 1; j < bots.length; j++) {
      if (!bots[i].alive || !bots[j].alive) continue;
      if (now < bots[i].invincibleUntil || now < bots[j].invincibleUntil) continue;
      const d = dist(bots[i], bots[j]);
      if (d < BATTLE_RANGE) {
        resolveBotBattle(bots[i], bots[j]);
      }
    }
  }

  // Player vs powerups
  powerups.forEach(pu => {
    if (!pu.alive) return;
    const d = dist(player, pu);
    if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
      collectPowerup(player, pu);
    }
  });

  // Bots vs powerups
  bots.forEach(bot => {
    if (!bot.alive) return;
    powerups.forEach(pu => {
      if (!pu.alive) return;
      const d = dist(bot, pu);
      if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
        collectPowerup(bot, pu);
      }
    });
  });
}

function collidesWithObstacle(x, y, r) {
  return MAP_OBSTACLES.some(o =>
    x + r > o.x && x - r < o.x + o.w &&
    y + r > o.y && y - r < o.y + o.h
  );
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

// â”€â”€ POWERUPS â”€â”€
function collectPowerup(entity, pu) {
  pu.alive = false;

  if (pu.effect === 'heal') {
    entity.hp = Math.min(entity.hp + 1, 5);
    if (entity === player) {
      showNotification(`${pu.icon} Health restored!`);
      document.getElementById('hud-hp').textContent = player.hp;
    }
  } else {
    entity.powerups.push({
      type: pu.effect,
      icon: pu.icon,
      label: pu.label,
      expires: Date.now() + pu.duration,
    });
    if (entity === player) {
      showNotification(`${pu.icon} ${pu.label} activated!`);
    }
  }

  // Spawn particles
  for (let i = 0; i < 8; i++) {
    particles.push({
      x: pu.x, y: pu.y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 1,
      color: pu.color,
      size: 3 + Math.random() * 3,
    });
  }

  // Respawn a new powerup after delay
  setTimeout(() => {
    if (gameState === 'playing') spawnPowerups(1);
  }, 5000 + Math.random() * 5000);
}

function hasActivePowerup(entity, type) {
  return entity.powerups.some(p => p.type === type && Date.now() < p.expires);
}

function updatePowerups(dt) {
  // Bob animation handled in render
}

function updatePowerupUI(entity) {
  if (entity !== player) return;
  const container = document.getElementById('powerup-active');
  const active = entity.powerups.filter(p => Date.now() < p.expires);
  container.innerHTML = active.map(p => {
    const remaining = Math.ceil((p.expires - Date.now()) / 1000);
    return `<div class="powerup-badge">${p.icon} ${p.label} ${remaining}s</div>`;
  }).join('');
}

function updateParticles(dt) {
  particles = particles.filter(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= 0.03 * dt;
    p.vy += 0.1 * dt;
    return p.life > 0;
  });
}

// â”€â”€ BATTLE SYSTEM (Exact match to dashboard.html) â”€â”€
// Uses model-viewer, fireball.png sprites, dojo background

const ROUND_DURATION = 30000;
const BASH_THRESHOLD_BASE = 30;
const AUTO_ATTACK_INTERVAL = 2500;
const BLOCK_WINDOW = 400;

let combat = null;

function startBattle(opponent) {
  if (gameState !== 'playing') return;
  gameState = 'battle';

  // Hide movement controls during battle
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';

  const overlay = document.getElementById('battle-overlay');
  overlay.classList.add('active');

  // Load model for battle viewport
  setupBattleModel();

  // VS screen
  const vsDiv = document.getElementById('battle-vs');
  vsDiv.innerHTML = `
    <div class="battle-fighter">
      <canvas id="battle-player-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${player.color.body}">You</div>
      <div class="battle-fighter-stats">STR ${fitnessStats.str || 10} / HP ${fitnessStats.hp || 10} / MANA ${fitnessStats.mana || 5}</div>
    </div>
    <div class="battle-vs-text">VS</div>
    <div class="battle-fighter">
      <canvas id="battle-opponent-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${opponent.color.body}">${opponent.name}</div>
      <div class="battle-fighter-stats">Lv.${opponent.fitnessLevel || '??'}</div>
    </div>
  `;

  setTimeout(() => {
    const pc = document.getElementById('battle-player-canvas');
    const oc = document.getElementById('battle-opponent-canvas');
    if (pc) drawBean(pc.getContext('2d'), 40, 50, player.color, 1.5);
    if (oc) drawBean(oc.getContext('2d'), 40, 50, opponent.color, 1.5, true);
  }, 50);

  battleState = { opponent, phase: 'intro' };

  // After VS intro, start combat
  setTimeout(() => {
    if (battleState) {
      vsDiv.style.display = 'none';
      initCombat(opponent);
    }
  }, 1500);
}

function initCombat(opponent) {
  const stats = fitnessStats;
  const playerSTR = stats.str || 10;
  const playerHP_stat = stats.hp || 10;
  const playerMANA = stats.mana || 5;

  const botLevel = opponent.fitnessLevel || 40;
  const botSTR = Math.floor(botLevel * 0.3);
  const botHP_stat = Math.floor(botLevel * 0.25);

  const playerMaxHP = 100 + (playerHP_stat * 5);
  const enemyMaxHP = 100 + (botHP_stat * 5);

  combat = {
    opponent,
    round: 1,
    playerRoundWins: 0,
    enemyRoundWins: 0,
    playerHP: playerMaxHP,
    playerMaxHP,
    enemyHP: enemyMaxHP,
    enemyMaxHP,
    playerSTR,
    enemySTR: botSTR,
    playerMANA,
    bashCount: 0,
    bashThreshold: Math.max(10, BASH_THRESHOLD_BASE - Math.floor(playerMANA / 5)),
    superReady: false,
    blockReady: false,
    blockSuccess: false,
    roundOver: false,
    timerEnd: Date.now() + ROUND_DURATION,
    autoAttackTimer: null,
    botAttackTimer: null,
    timerInterval: null,
  };

  // Show combat UI
  document.getElementById('battle-combat-zone').style.display = '';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Show HP bars + action container (mana bar hidden like dashboard)
  document.getElementById('bc-hp-container').classList.add('active');
  document.getElementById('bc-action-container').classList.add('active');

  // Play battle model animation
  const mv = document.getElementById('arena-battle-model');
  if (mv && mv.availableAnimations && mv.availableAnimations.length > 0) {
    const anims = mv.availableAnimations;
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a)) || anims[0];
    mv.animationName = attackAnim;
    mv.play({ repetitions: Infinity });
  }

  // Show BASH! overlay briefly
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.textContent = 'BASH!';
  overlayText.classList.add('active');
  setTimeout(() => overlayText.classList.remove('active'), 1000);

  // Update UI
  document.getElementById('bc-enemy-name').textContent = opponent.name.toUpperCase();
  updateCombatUI();
  updateRoundDots();

  // Populate info panel
  document.getElementById('bc-info-name').textContent = opponent.name;
  document.getElementById('bc-info-level').textContent = `Level ${botLevel}`;
  document.getElementById('bc-info-str').textContent = botSTR;
  document.getElementById('bc-info-hp').textContent = botHP_stat;
  document.getElementById('bc-info-def').textContent = Math.floor(botLevel * 0.2);
  // Draw opponent avatar in info panel
  const infoCanvas = document.getElementById('battle-info-avatar');
  if (infoCanvas && opponent.color) {
    drawBean(infoCanvas.getContext('2d'), 28, 36, opponent.color, 1.2, true);
  }

  // Start timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);

  // Player auto-attacks (fires normal fireballs)
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  // Bot attacks
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);

    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

function combatBash(e) {
  e.preventDefault();
  if (!combat || combat.roundOver) return;

  combat.bashCount++;
  if (navigator.vibrate) navigator.vibrate(30);

  // Bash button feedback
  const btn = document.getElementById('bc-bash-btn');
  btn.style.transform = 'scale(0.88)';
  setTimeout(() => { if (btn) btn.style.transform = ''; }, 50);

  // Update mana/charge bar + SVG ring
  const progress = Math.min(1, combat.bashCount / combat.bashThreshold);
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = (progress * 100) + '%';
  manaPct.textContent = Math.floor(progress * 100) + '%';

  // Update SVG ring (circumference = 2 * PI * 26 = 163.36)
  if (ringFill) {
    ringFill.style.strokeDashoffset = 163.36 * (1 - progress);
  }

  if (progress >= 1) {
    manaFill.classList.add('full');
    btn.classList.add('attack-ready');
  }

  // Check if super is charged
  if (combat.bashCount >= combat.bashThreshold && !combat.superReady) {
    combat.superReady = true;
    const fireBtn = document.getElementById('bc-fire-btn');
    fireBtn.classList.add('visible');
    if (navigator.vibrate) navigator.vibrate([50, 30, 50]);

    // Auto-reset if not fired in 2s
    combat.superTimeout = setTimeout(() => {
      if (combat && combat.superReady) {
        combat.superReady = false;
        combat.bashCount = 0;
        fireBtn.classList.remove('visible');
        manaFill.classList.remove('full');
        btn.classList.remove('attack-ready');
        manaFill.style.width = '0%';
        manaPct.textContent = '0%';
        if (ringFill) ringFill.style.strokeDashoffset = 163.36;
      }
    }, 2000);
  }
}

function combatFire(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.superReady) return;

  combat.superReady = false;
  combat.bashCount = 0;
  clearTimeout(combat.superTimeout);

  // Fire damage (full power) + triple fireball
  const dmg = Math.floor((10 + combat.playerSTR) * 1.0);
  dealDamageToEnemy(dmg, true);

  // Play attack animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv) {
    const anims = mv.availableAnimations || [];
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a));
    if (attackAnim) {
      mv.animationName = attackAnim;
      mv.play({ repetitions: 1 });
    }
  }

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const fireBtn = document.getElementById('bc-fire-btn');
  const bashBtn = document.getElementById('bc-bash-btn');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  manaPct.textContent = '0%';
  fireBtn.classList.remove('visible');
  bashBtn.classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;

  if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
}

function combatBlock(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.blockReady) return;

  combat.blockSuccess = true;
  combat.blockReady = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.remove('visible');

  showHitFlash('blocked');
  if (navigator.vibrate) navigator.vibrate([30, 20, 30]);
}

function showBlockPrompt() {
  if (!combat || combat.roundOver) return;
  combat.blockReady = true;
  combat.blockSuccess = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.add('visible');

  setTimeout(() => {
    if (combat) {
      combat.blockReady = false;
      blockBtn.classList.remove('visible');
    }
  }, BLOCK_WINDOW + 100);
}

function dealDamageToEnemy(dmg, isSuper) {
  if (!combat || combat.roundOver) return;
  combat.enemyHP = Math.max(0, combat.enemyHP - dmg);
  updateCombatUI();

  // Spawn fireball in viewport (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnTripleFireball(viewport);
  } else {
    spawnNormalFireball(viewport);
  }

  if (isSuper) {
    showHitFlash('super-hit');
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.enemyHP <= 0) {
    endRound(true);
  }
}

function dealDamageToPlayer(dmg, isSuper) {
  if (!combat || combat.roundOver) return;

  const blockMult = combat.blockSuccess ? 0.5 : 1.0;
  const actualDmg = Math.floor(dmg * blockMult);
  combat.playerHP = Math.max(0, combat.playerHP - actualDmg);
  const wasBlocked = combat.blockSuccess;
  combat.blockSuccess = false;
  updateCombatUI();

  // Spawn incoming fireball (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnIncomingTripleFireball(viewport);
  } else {
    spawnIncomingBattleFireball(viewport);
  }

  // Play hit animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv && !wasBlocked) {
    const anims = mv.availableAnimations || [];
    const hitAnim = anims.find(a => /hit|hurt|damage|flinch/i.test(a));
    if (hitAnim) {
      mv.animationName = hitAnim;
      mv.play({ repetitions: 1 });
    }
  }

  showHitFlash(wasBlocked ? 'blocked' : isSuper ? 'super-hit' : '');

  if (isSuper && !wasBlocked) {
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.playerHP <= 0) {
    endRound(false);
  }
}

function showHitFlash(type) {
  const flash = document.createElement('div');
  flash.className = 'battle-hit-flash ' + type;
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 400);
}

function updateCombatUI() {
  if (!combat) return;
  const { playerHP, playerMaxHP, enemyHP, enemyMaxHP } = combat;

  const playerPct = Math.max(0, (playerHP / playerMaxHP) * 100);
  const enemyPct = Math.max(0, (enemyHP / enemyMaxHP) * 100);

  document.getElementById('bc-hp-player').style.width = playerPct + '%';
  document.getElementById('bc-hp-enemy').style.width = enemyPct + '%';
  document.getElementById('bc-hp-player-text').textContent = `${Math.max(0,playerHP)} / ${playerMaxHP}`;
  document.getElementById('bc-hp-enemy-text').textContent = `${Math.max(0,enemyHP)} / ${enemyMaxHP}`;
}

function updateCombatTimer() {
  if (!combat) return;
  const remaining = Math.max(0, Math.ceil((combat.timerEnd - Date.now()) / 1000));
  document.getElementById('bc-timer').textContent = remaining;
  if (remaining <= 0 && !combat.roundOver) {
    // Time's up - higher HP% wins
    const playerPct = combat.playerHP / combat.playerMaxHP;
    const enemyPct = combat.enemyHP / combat.enemyMaxHP;
    endRound(playerPct >= enemyPct);
  }
}

function updateRoundDots() {
  if (!combat) return;
  for (let i = 1; i <= 3; i++) {
    const dot = document.getElementById('rd' + i);
    dot.className = 'round-dot';
    if (i <= combat.playerRoundWins) dot.classList.add('player-win');
  }
  // Show enemy wins on the other end conceptually via color
  document.getElementById('bc-round').textContent = combat.round;
}

function endRound(playerWon) {
  if (!combat || combat.roundOver) return;
  combat.roundOver = true;

  clearInterval(combat.autoAttackTimer);
  clearInterval(combat.botAttackTimer);
  clearInterval(combat.timerInterval);
  clearTimeout(combat.superTimeout);

  if (playerWon) {
    combat.playerRoundWins++;
  } else {
    combat.enemyRoundWins++;
  }

  updateRoundDots();

  // Check match result (best of 3)
  if (combat.playerRoundWins >= 2 || combat.enemyRoundWins >= 2) {
    const matchWon = combat.playerRoundWins >= 2;
    setTimeout(() => showBattleResult(matchWon,
      `${combat.playerRoundWins} - ${combat.enemyRoundWins}`), 800);
  } else {
    // Next round after brief pause
    showNotification(playerWon ? 'Round won!' : 'Round lost!');
    setTimeout(() => startNextRound(), 1500);
  }
}

function startNextRound() {
  if (!combat) return;
  combat.round++;
  combat.playerHP = combat.playerMaxHP;
  combat.enemyHP = combat.enemyMaxHP;
  combat.bashCount = 0;
  combat.superReady = false;
  combat.blockReady = false;
  combat.roundOver = false;
  combat.timerEnd = Date.now() + ROUND_DURATION;

  // Clear any remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Show round transition
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.innerHTML = `<div style="animation:roundTextPop 0.5s ease-out;">ROUND ${combat.round}</div>` +
    `<div style="font-size:0.6em;margin-top:8px;opacity:0.9;">${combat.playerRoundWins} - ${combat.enemyRoundWins}</div>`;
  overlayText.style.color = '#FFD700';
  overlayText.classList.add('active');
  setTimeout(() => { overlayText.classList.remove('active'); overlayText.style.color = ''; }, 1500);

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const ringFill = document.getElementById('bash-ring-fill');
  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  document.getElementById('bc-mana-pct').textContent = '0%';
  document.getElementById('bc-fire-btn').classList.remove('visible');
  document.getElementById('bc-block-btn').classList.remove('visible');
  document.getElementById('bc-bash-btn').classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;
  updateCombatUI();
  updateRoundDots();

  // Restart timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  const botLevel = combat.opponent.fitnessLevel || 40;
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);
    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

// â”€â”€ FIREBALL SYSTEM (matches dashboard exactly) â”€â”€

function spawnNormalFireball(container) {
  const fb = document.createElement('div');
  fb.className = 'fireball';
  fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px;filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
  fb.style.cssText = 'position:absolute; left:150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
  container.appendChild(fb);
  let posX = 150;
  function move() {
    posX += 5;
    fb.style.left = posX + 'px';
    if (posX > container.clientWidth) fb.remove();
    else requestAnimationFrame(move);
  }
  move();
}

function spawnTripleFireball(container) {
  const offsets = [-80, 0, 80];
  offsets.forEach((yOff, i) => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;filter:drop-shadow(0 0 30px gold) brightness(1.3);">`;
    fb.style.cssText = `position:absolute; left:150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
    container.appendChild(fb);
    let posX = 150;
    const speed = 5 + i;
    function move() {
      posX += speed;
      fb.style.left = posX + 'px';
      if (posX > container.clientWidth) fb.remove();
      else requestAnimationFrame(move);
    }
    setTimeout(() => move(), i * 60);
  });
}

function spawnIncomingBattleFireball(container) {
  return new Promise(resolve => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px; transform:scaleX(-1); filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
    fb.style.cssText = 'position:absolute; right:-150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
    container.appendChild(fb);
    let posX = container.clientWidth;
    const targetX = container.clientWidth / 2;
    const speed = 4;
    function move() {
      posX -= speed;
      fb.style.left = posX + 'px';
      if (posX <= targetX) { fb.remove(); resolve(); }
      else requestAnimationFrame(move);
    }
    move();
  });
}

function spawnIncomingTripleFireball(container) {
  return new Promise(resolve => {
    const offsets = [-60, 0, 60];
    let resolved = false;
    offsets.forEach((yOff, i) => {
      const fb = document.createElement('div');
      fb.className = 'fireball';
      fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;transform:scaleX(-1);filter:drop-shadow(0 0 30px cyan) brightness(1.3);">`;
      fb.style.cssText = `position:absolute; right:-150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
      container.appendChild(fb);
      let posX = container.clientWidth;
      const targetX = container.clientWidth / 2;
      const speed = 4 + i;
      function move() {
        posX -= speed;
        fb.style.left = posX + 'px';
        if (posX <= targetX) {
          fb.remove();
          if (!resolved) { resolved = true; resolve(); }
        }
        else requestAnimationFrame(move);
      }
      setTimeout(() => move(), i * 60);
    });
  });
}

// Setup battle model from localStorage (same source as tamagotchi)
function setupBattleModel() {
  const mv = document.getElementById('arena-battle-model');
  if (!mv) return;
  const src = localStorage.getItem('fitgotchi_model_src') ||
    'https://f005.backblazeb2.com/file/shannonsvideos/baby_full_animations.glb';
  mv.setAttribute('src', src);
  mv.removeAttribute('auto-rotate');
  mv.removeAttribute('camera-controls');
  const savedOrbit = localStorage.getItem('fitgotchi_camera_orbit');
  if (savedOrbit) {
    // Extract distance from saved orbit, use 0deg 85deg for battle
    const match = savedOrbit.match(/([\d.]+m)$/);
    const dist = match ? match[1] : '22m';
    mv.setAttribute('camera-orbit', `0deg 85deg ${dist}`);
  }
}

function showBattleResult(won, detail = '') {
  // Hide combat zone
  document.getElementById('battle-combat-zone').style.display = 'none';

  // Hide battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');

  // Clear remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clean up combat timers
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
  }

  const resultDiv = document.getElementById('battle-result');
  resultDiv.classList.add('active');

  if (won) {
    resultDiv.innerHTML = `
      <div class="battle-result-text win">Victory!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-warning);margin:4px 0;">${detail}</div>
      <div class="battle-reward">+15 Coins  +10 XP</div>
      <button class="battle-continue-btn" onclick="endBattle(true)">Continue</button>
    `;
    battleState.opponent.hp -= 1;
    if (battleState.opponent.hp <= 0) {
      battleState.opponent.alive = false;
      player.kills++;
      eliminationOrder.push(battleState.opponent.name);
      document.getElementById('hud-kills').textContent = player.kills;
    }
  } else {
    resultDiv.innerHTML = `
      <div class="battle-result-text lose">Defeated!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-muted);margin:4px 0;">${detail}</div>
      <button class="battle-continue-btn" style="background:linear-gradient(135deg,var(--arena-secondary),#7c3aed);" onclick="endBattle(false)">Continue</button>
    `;
    player.hp -= 1;
    document.getElementById('hud-hp').textContent = player.hp;
    if (player.hp <= 0) {
      player.alive = false;
    }
  }

  updateAliveCount();
}

function endBattle(won) {
  const overlay = document.getElementById('battle-overlay');
  overlay.classList.remove('active');

  // Reset VS display for next battle
  document.getElementById('battle-vs').style.display = '';
  document.getElementById('battle-combat-zone').style.display = 'none';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Reset battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clear model src to free memory
  const mv = document.getElementById('arena-battle-model');
  if (mv) mv.removeAttribute('src');

  // Brief invincibility after battle
  const now = Date.now();
  player.invincibleUntil = now + 2000;
  if (battleState && battleState.opponent) {
    battleState.opponent.invincibleUntil = now + 2000;
  }

  // Cleanup all combat state
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
    combat = null;
  }
  battleState = null;

  if (!player.alive) {
    gameState = 'gameover';
    showGameOver();
  } else {
    gameState = 'playing';
    document.getElementById('dpad-hint').style.display = '';
    document.getElementById('action-zone').style.display = '';
  }
}

function resolveBotBattle(bot1, bot2) {
  // Simple resolution based on fitness levels
  const score1 = (bot1.fitnessLevel || 50) + Math.random() * 40;
  const score2 = (bot2.fitnessLevel || 50) + Math.random() * 40;

  const winner = score1 > score2 ? bot1 : bot2;
  const loser = score1 > score2 ? bot2 : bot1;

  loser.hp -= 1;
  if (loser.hp <= 0) {
    loser.alive = false;
    eliminationOrder.push(loser.name);
  }

  // Invincibility
  const now = Date.now();
  bot1.invincibleUntil = now + 2000;
  bot2.invincibleUntil = now + 2000;

  // Particles at battle site
  for (let i = 0; i < 6; i++) {
    particles.push({
      x: (bot1.x + bot2.x) / 2,
      y: (bot1.y + bot2.y) / 2,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      life: 1,
      color: '#fbbf24',
      size: 3 + Math.random() * 2,
    });
  }

  updateAliveCount();
}

function updateAliveCount() {
  const alive = 1 + bots.filter(b => b.alive).length;
  document.getElementById('alive-count').textContent = alive;
}

// â”€â”€ CAMERA â”€â”€
function updateCamera() {
  if (!player) return;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  camera.x = player.x - vw / 2;
  camera.y = player.y - vh / 2;
  camera.x = Math.max(0, Math.min(ARENA_W - vw, camera.x));
  camera.y = Math.max(0, Math.min(ARENA_H - vh, camera.y));
}

// â”€â”€ GAME OVER â”€â”€
function checkGameOver() {
  if (!player || !player.alive) return;
  const aliveCount = bots.filter(b => b.alive).length;
  if (aliveCount === 0) {
    gameState = 'gameover';
    showGameOver();
  }
}

function showGameOver() {
  const overlay = document.getElementById('gameover-overlay');
  overlay.classList.add('active');

  const aliveCount = bots.filter(b => b.alive).length;
  const place = player.alive ? 1 : aliveCount + 2;
  const totalPlayers = playerCount;

  document.getElementById('gameover-place').textContent = `#${place}`;
  document.getElementById('gameover-place').className = `gameover-place ${place === 1 ? 'first' : ''}`;

  const labels = {
    1: 'Victory!',
    2: 'So Close!',
    3: 'Good Fight!',
  };
  document.getElementById('gameover-label').textContent = labels[place] || 'Eliminated';
  document.getElementById('gameover-sub').textContent = place === 1
    ? `You dominated the arena with ${player.kills} knockouts!`
    : `Eliminated in ${place}${place===2?'nd':place===3?'rd':'th'} place`;

  const coinReward = place === 1 ? 50 : place === 2 ? 25 : 10;
  const xpReward = place === 1 ? 25 : place === 2 ? 15 : 5;
  document.getElementById('gameover-coins').textContent = `+${coinReward}`;
  document.getElementById('gameover-xp').textContent = `+${xpReward}`;
}

function returnToLobby() {
  document.getElementById('gameover-overlay').classList.remove('active');
  document.getElementById('lobby').classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('players-alive').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('powerup-active').innerHTML = '';
  gameState = 'lobby';
  player = null;
  bots = [];
  powerups = [];
  particles = [];
}

function exitArena() {
  if (window.history.length > 1) {
    window.history.back();
  } else {
    window.location.href = 'dashboard.html';
  }
}

// â”€â”€ ACTION BUTTON â”€â”€
function handleAction() {
  if (gameState !== 'playing' || !player || !player.alive) return;

  // Find nearest alive bot
  let nearest = null;
  let nearestDist = Infinity;
  bots.forEach(bot => {
    if (!bot.alive) return;
    const d = dist(player, bot);
    if (d < nearestDist) {
      nearestDist = d;
      nearest = bot;
    }
  });

  if (nearest && nearestDist < 120) {
    showNotification(`${nearest.name} is nearby! Get closer to battle!`);
  } else {
    // Scan - reveal nearest player direction briefly
    if (nearest) {
      const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      const dirs = ['East', 'South', 'West', 'North'];
      const dirIdx = Math.round(((angle + Math.PI) / (Math.PI * 2)) * 4) % 4;
      showNotification(`Nearest fighter: ${Math.round(nearestDist)}m to the ${dirs[dirIdx]}`);
    }
  }
}

// â”€â”€ NOTIFICATIONS â”€â”€
function showNotification(text) {
  // Remove existing
  document.querySelectorAll('.arena-notification').forEach(n => n.remove());

  const notif = document.createElement('div');
  notif.className = 'arena-notification';
  notif.textContent = text;
  document.body.appendChild(notif);
  setTimeout(() => notif.remove(), 3000);
}

// â”€â”€ RENDER â”€â”€
function render() {
  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

  if (gameState === 'lobby') return;

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  drawArenaBackground();
  drawObstacles();
  drawPowerups();
  drawEntities();
  drawParticles();

  // Mini-map
  ctx.restore();
  drawMinimap();

  // Update action button state
  updateActionButton();
}

function drawArenaBackground() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  // Dark void outside rooms - space/stars feel
  ctx.fillStyle = '#050810';
  ctx.fillRect(vx, vy, vw, vh);

  // Subtle star-like dots in the void (seeded by position for consistency)
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  const starSpacing = 80;
  const sx0 = Math.floor(vx / starSpacing) * starSpacing;
  const sy0 = Math.floor(vy / starSpacing) * starSpacing;
  for (let sy = sy0; sy < vy + vh; sy += starSpacing) {
    for (let sx = sx0; sx < vx + vw; sx += starSpacing) {
      // Only draw outside rooms
      const inRoom = ROOMS.some(rm => sx >= rm.x && sx <= rm.x + rm.w && sy >= rm.y && sy <= rm.y + rm.h);
      if (!inRoom) {
        const hash = ((sx * 7919 + sy * 6271) & 0xFFFF) / 65535;
        if (hash < 0.35) {
          ctx.beginPath();
          ctx.arc(sx + hash * 30, sy + hash * 20, 0.5 + hash, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Draw room floors with per-room patterns
  ROOMS.forEach(rm => {
    // Skip if off-screen
    if (rm.x + rm.w < vx || rm.x > vx + vw || rm.y + rm.h < vy || rm.y > vy + vh) return;

    // Base room floor
    ctx.fillStyle = rm.floor;
    ctx.fillRect(rm.x, rm.y, rm.w, rm.h);

    // Per-room floor pattern
    const TILE = 40;
    const startCol = Math.max(0, Math.floor((vx - rm.x) / TILE));
    const endCol = Math.min(Math.ceil(rm.w / TILE), Math.ceil((vx + vw - rm.x) / TILE) + 1);
    const startRow = Math.max(0, Math.floor((vy - rm.y) / TILE));
    const endRow = Math.min(Math.ceil(rm.h / TILE), Math.ceil((vy + vh - rm.y) / TILE) + 1);

    switch (rm.floorType) {
      case 'checker-tile': {
        // Kitchen: Large metallic plates with safety tape border (Among Us Kitchen)
        ctx.fillStyle = '#22262a';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        // Panel lines
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.lineWidth = 3;
        const panSize = 100;
        for (let r = Math.max(0, Math.floor((vy - rm.y) / panSize)); r < Math.min(Math.ceil(rm.h / panSize), Math.ceil((vy + vh - rm.y) / panSize) + 1); r++) {
          for (let c = Math.max(0, Math.floor((vx - rm.x) / panSize)); c < Math.min(Math.ceil(rm.w / panSize), Math.ceil((vx + vw - rm.x) / panSize) + 1); c++) {
            ctx.strokeRect(rm.x + c * panSize, rm.y + r * panSize, panSize, panSize);
            // Rivets at corners
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.beginPath(); ctx.arc(rm.x + c * panSize + 8, rm.y + r * panSize + 8, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(rm.x + c * panSize + panSize - 8, rm.y + r * panSize + 8, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(rm.x + c * panSize + 8, rm.y + r * panSize + panSize - 8, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(rm.x + c * panSize + panSize - 8, rm.y + r * panSize + panSize - 8, 2, 0, Math.PI*2); ctx.fill();
          }
        }
        
        // Heavy safety warning edge tape
        ctx.lineWidth = 16;
        ctx.strokeStyle = '#facc15';
        ctx.strokeRect(rm.x + 15, rm.y + 15, rm.w - 30, rm.h - 30);
        ctx.setLineDash([25, 25]);
        ctx.strokeStyle = '#111';
        ctx.strokeRect(rm.x + 15, rm.y + 15, rm.w - 30, rm.h - 30);
        ctx.setLineDash([]);
        break;
      }
      case 'linoleum': {
        // Cafeteria: Smooth blue floor with giant center grate
        ctx.fillStyle = '#3a4a5a';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        // Large polished tiles
        ctx.strokeStyle = '#2a3a4a';
        ctx.lineWidth = 2;
        const TILE = 80;
        for (let r = Math.max(0, Math.floor((vy - rm.y) / TILE)); r < Math.min(Math.ceil(rm.h / TILE), Math.ceil((vy + vh - rm.y) / TILE) + 1); r++) {
          for (let c = Math.max(0, Math.floor((vx - rm.x) / TILE)); c < Math.min(Math.ceil(rm.w / TILE), Math.ceil((vx + vw - rm.x) / TILE) + 1); c++) {
            ctx.strokeRect(rm.x + c * TILE, rm.y + r * TILE, TILE, TILE);
          }
        }
        
        // Cafeteria Central Vent Grate (Iconic)
        if (vx < rm.x + rm.w / 2 + 120 && vx + vw > rm.x + rm.w / 2 - 120 &&
            vy < rm.y + rm.h / 2 + 120 && vy + vh > rm.y + rm.h / 2 - 120) {
          
          ctx.fillStyle = '#111';
          ctx.beginPath(); ctx.arc(rm.x + rm.w / 2, rm.y + rm.h / 2, 110, 0, Math.PI * 2); ctx.fill();
          
          // Outer vent ring
          ctx.strokeStyle = '#667'; ctx.lineWidth = 14;
          ctx.beginPath(); ctx.arc(rm.x + rm.w / 2, rm.y + rm.h / 2, 110, 0, Math.PI * 2); ctx.stroke();
          
          // Grating mesh inside vent
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 4;
          ctx.save();
          ctx.beginPath(); ctx.arc(rm.x + rm.w/2, rm.y + rm.h/2, 103, 0, Math.PI*2); ctx.clip();
          for (let i = -110; i <= 110; i += 16) {
            ctx.beginPath(); ctx.moveTo(rm.x + rm.w / 2 + i, rm.y + rm.h / 2 - 110); ctx.lineTo(rm.x + rm.w / 2 + i, rm.y + rm.h / 2 + 110); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(rm.x + rm.w / 2 - 110, rm.y + rm.h / 2 + i); ctx.lineTo(rm.x + rm.w / 2 + 110, rm.y + rm.h / 2 + i); ctx.stroke();
          }
          ctx.restore();
        }
        
        // Caution stripes crossing the room
        ctx.beginPath(); ctx.moveTo(rm.x, rm.y + rm.h / 2); ctx.lineTo(rm.x + rm.w, rm.y + rm.h / 2);
        ctx.lineWidth = 30; ctx.strokeStyle = '#facc15'; ctx.stroke();
        ctx.setLineDash([25, 25]); ctx.strokeStyle = '#111'; ctx.stroke(); ctx.setLineDash([]);
        break;
      }
      case 'wood': {
        // Living Room -> Admin (Hexagon Grate Floor)
        ctx.fillStyle = '#1e2025';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        ctx.strokeStyle = 'rgba(0,180,255,0.08)';
        ctx.lineWidth = 2;
        
        const hexS = 22;
        const dx = hexS * 1.5;
        const dy = hexS * Math.sqrt(3);
        
        let hc0 = Math.floor((vx - rm.x) / dx) - 1;
        let hr0 = Math.floor((vy - rm.y) / dy) - 1;
        let hc1 = Math.ceil((vx + vw - rm.x) / dx) + 1;
        let hr1 = Math.ceil((vy + vh - rm.y) / dy) + 1;
        
        ctx.beginPath();
        for (let r = hr0; r < hr1; r++) {
          for (let c = hc0; c < hc1; c++) {
            const cx = rm.x + c * dx;
            const cy = rm.y + r * dy + (c % 2 === 0 ? 0 : dy/2);
            
            ctx.moveTo(cx + hexS, cy);
            ctx.lineTo(cx + hexS/2, cy + dy/2);
            ctx.lineTo(cx - hexS/2, cy + dy/2);
            ctx.lineTo(cx - hexS, cy);
            ctx.lineTo(cx - hexS/2, cy - dy/2);
            ctx.lineTo(cx + hexS/2, cy - dy/2);
            ctx.lineTo(cx + hexS, cy);
          }
        }
        ctx.stroke();
        break;
      }
      case 'small-tile': {
        // Bathroom -> MedBay (White Tech Panels with blue medical crosses)
        ctx.fillStyle = '#bac7d6';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        const ts = 80;
        ctx.strokeStyle = '#9caabb';
        ctx.lineWidth = 4;
        for (let r = Math.max(0, Math.floor((vy - rm.y) / ts)); r < Math.min(Math.ceil(rm.h / ts), Math.ceil((vy + vh - rm.y) / ts) + 1); r++) {
          for (let c = Math.max(0, Math.floor((vx - rm.x) / ts)); c < Math.min(Math.ceil(rm.w / ts), Math.ceil((vx + vw - rm.x) / ts) + 1); c++) {
            ctx.strokeRect(rm.x + c * ts, rm.y + r * ts, ts, ts);
            
            // Medical / Tech markings
            if ((r + c) % 3 === 0) {
              ctx.fillStyle = '#3498db';
              const cx = rm.x + c * ts + ts/2;
              const cy = rm.y + r * ts + ts/2;
              ctx.fillRect(cx - 4, cy - 14, 8, 28);
              ctx.fillRect(cx - 14, cy - 4, 28, 8);
              
              // Internal glow to MedBay crosses
              ctx.shadowColor = '#3498db'; ctx.shadowBlur = 10;
              ctx.fillStyle = '#85c1e9';
              ctx.fillRect(cx - 2, cy - 10, 4, 20);
              ctx.fillRect(cx - 10, cy - 2, 20, 4);
              ctx.shadowBlur = 0;
            }
          }
        }
        break;
      }
      case 'metal': {
        // Hallway: Dark steel industrial plates with massive wire conduits
        ctx.fillStyle = '#26292b';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        ctx.strokeStyle = '#181a1c';
        ctx.lineWidth = 5;
        for (let tx = rm.x + 30; tx < rm.x + rm.w; tx += 80) {
            ctx.beginPath(); ctx.moveTo(tx, rm.y); ctx.lineTo(tx, rm.y + rm.h); ctx.stroke();
        }
        for (let ty = rm.y + 30; ty < rm.y + rm.h; ty += 80) {
            ctx.beginPath(); ctx.moveTo(rm.x, ty); ctx.lineTo(rm.x + rm.w, ty); ctx.stroke();
        }
        
        // Huge central wire conduit crossing hallway
        ctx.fillStyle = '#111';
        ctx.fillRect(rm.x, rm.y + rm.h / 2 - 25, rm.w, 50);
        
        // Electric Wires
        const colors = ['#e74c3c', '#e67e22', '#2ecc71', '#00f2fe'];
        colors.forEach((col, i) => {
          ctx.strokeStyle = col;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(rm.x, rm.y + rm.h / 2 - 15 + i*10);
          for(let wx = rm.x; wx < rm.x + rm.w; wx += 30) {
              ctx.lineTo(wx, rm.y + rm.h / 2 - 15 + i*10 + Math.sin(wx/50 + i)*6);
          }
          ctx.stroke();
        });
        
        // Venting covers on conduit
        ctx.fillStyle = '#444';
        for(let tx = rm.x + 60; tx < rm.x + rm.w; tx += 200) {
           ctx.fillRect(tx, rm.y + rm.h/2 - 28, 40, 56);
        }
        break;
      }
      case 'carpet': {
        // Bedroom -> Nav/Comms Center (Dark technical floor)
        ctx.fillStyle = '#1c222e';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        ctx.strokeStyle = '#28364a';
        ctx.lineWidth = 3;
        const gS = 60;
        for (let r = Math.max(0, Math.floor((vy - rm.y) / gS)); r < Math.min(Math.ceil(rm.h / gS), Math.ceil((vy + vh - rm.y) / gS) + 1); r++) {
          for (let c = Math.max(0, Math.floor((vx - rm.x) / gS)); c < Math.min(Math.ceil(rm.w / gS), Math.ceil((vx + vw - rm.x) / gS) + 1); c++) {
            ctx.strokeRect(rm.x + c * gS, rm.y + r * gS, gS, gS);
            
            const hash = (r*37 + c*19) % 100;
            if (hash < 12) {
              // Comms flashing LED lights built into floor
              const active = (frameCount % 120 < 60);
              ctx.shadowColor = active ? '#00ff88' : '#ff0f3f';
              ctx.shadowBlur = 10;
              ctx.fillStyle = active ? '#00ff88' : '#ff0f3f';
              ctx.beginPath(); ctx.arc(rm.x + c * gS + 14, rm.y + r * gS + 14, 4, 0, Math.PI*2); ctx.fill();
              ctx.shadowBlur = 0;
            }
          }
        }
        break;
      }
      case 'rubber': {
        // Gym -> Weapons (Heavy diamond grip steel)
        ctx.fillStyle = '#313335';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 2;
        const dS = 30;
        for (let r = Math.max(0, Math.floor((vy - rm.y) / dS)); r < Math.min(Math.ceil(rm.h / dS), Math.ceil((vy + vh - rm.y) / dS) + 1); r++) {
          for (let c = Math.max(0, Math.floor((vx - rm.x) / dS)); c < Math.min(Math.ceil(rm.w / dS), Math.ceil((vx + vw - rm.x) / dS) + 1); c++) {
              const dx = rm.x + c * dS; const dy = rm.y + r * dS;
              ctx.beginPath();
              if ((r+c)%2 === 0) {
                  ctx.moveTo(dx + 6, dy + 6); ctx.lineTo(dx + dS - 6, dy + dS - 6);
              } else {
                  ctx.moveTo(dx + dS - 6, dy + 6); ctx.lineTo(dx + 6, dy + dS - 6);
              }
              ctx.stroke();
          }
        }
        
        // Giant weapons target circle on floor
        ctx.strokeStyle = 'rgba(239,68,68,0.2)';
        ctx.lineWidth = 14;
        ctx.beginPath(); ctx.arc(rm.x + rm.w/2, rm.y + rm.h/2, 140, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(rm.x + rm.w/2, rm.y + rm.h/2, 80, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 8;
        ctx.beginPath(); ctx.moveTo(rm.x + rm.w/2, rm.y + rm.h/2 - 180); ctx.lineTo(rm.x + rm.w/2, rm.y + rm.h/2 + 180); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rm.x + rm.w/2 - 180, rm.y + rm.h/2); ctx.lineTo(rm.x + rm.w/2 + 180, rm.y + rm.h/2); ctx.stroke();
        break;
      }
      case 'grass': {
        // Garden -> O2 Greenhouse (Grate with glowing oxygen bio-tubes beneath)
        ctx.fillStyle = '#0a0d0a';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        // Liquid oxygen tubes
        ctx.strokeStyle = '#00ff44';
        ctx.lineWidth = 14;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ff44';
        for (let t = 0; t < 6; t++) {
          ctx.beginPath();
          ctx.moveTo(rm.x + 80 + t*220, rm.y);
          ctx.lineTo(rm.x + 80 + t*220, rm.y + rm.h);
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
        
        // Huge heavy iron hex grate overlay
        ctx.strokeStyle = '#181f18';
        ctx.lineWidth = 8;
        const hexS = 30;
        const dx = hexS * 1.5;
        const dy = hexS * Math.sqrt(3);
        
        let hc0 = Math.floor((vx - rm.x) / dx) - 1;
        let hr0 = Math.floor((vy - rm.y) / dy) - 1;
        let hc1 = Math.ceil((vx + vw - rm.x) / dx) + 1;
        let hr1 = Math.ceil((vy + vh - rm.y) / dy) + 1;
        
        ctx.beginPath();
        for (let r = hr0; r < hr1; r++) {
          for (let c = hc0; c < hc1; c++) {
            const cx = rm.x + c * dx;
            const cy = rm.y + r * dy + (c % 2 === 0 ? 0 : dy/2);
            ctx.moveTo(cx + hexS, cy); ctx.lineTo(cx + hexS/2, cy + dy/2); ctx.lineTo(cx - hexS/2, cy + dy/2); ctx.lineTo(cx - hexS, cy); ctx.lineTo(cx - hexS/2, cy - dy/2); ctx.lineTo(cx + hexS/2, cy - dy/2); ctx.lineTo(cx + hexS, cy);
          }
        }
        ctx.stroke();
        break;
      }
      case 'concrete': {
        // Garage -> Engine / Reactor (Dark metal with glowing plasma cores and vents)
        ctx.fillStyle = '#141418';
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        
        // Massive heavy panel splits
        ctx.strokeStyle = '#08080a';
        ctx.lineWidth = 8;
        for (let c = 1; c < 5; c++) {
          ctx.beginPath(); ctx.moveTo(rm.x + (rm.w/5)*c, rm.y); ctx.lineTo(rm.x + (rm.w/5)*c, rm.y + rm.h); ctx.stroke();
        }
        
        // Engine Plasma Core in Floor
        const cx = rm.x + rm.w / 2;
        const cy = rm.y + rm.h / 2;
        
        // Containment rings
        ctx.strokeStyle = '#222'; ctx.lineWidth = 14;
        ctx.beginPath(); ctx.arc(cx, cy, 180, 0, Math.PI*2); ctx.stroke();
        
        ctx.shadowBlur = 40;
        ctx.shadowColor = '#00f2fe';
        ctx.fillStyle = '#081a30';
        ctx.beginPath(); ctx.arc(cx, cy, 140, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#00f2fe';
        ctx.beginPath(); ctx.arc(cx, cy, 90, 0, Math.PI*2); ctx.fill();
        
        // Engine pipes radiating
        ctx.strokeStyle = '#00f2fe';
        ctx.lineWidth = 12;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f2fe';
        const angles = [0, Math.PI/2, Math.PI, Math.PI*1.5];
        for (let a of angles) {
          ctx.beginPath();
          ctx.moveTo(cx + Math.cos(a)*100, cy + Math.sin(a)*100);
          ctx.lineTo(cx + Math.cos(a)*Math.max(rm.w, rm.h), cy + Math.sin(a)*Math.max(rm.w, rm.h));
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
        break;
      }
    }

    // Room label (larger, more atmospheric)
    ctx.save();
    ctx.font = '800 18px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.letterSpacing = '4px';
    ctx.fillText(rm.name.toUpperCase(), rm.x + rm.w / 2, rm.y + rm.h / 2);
    ctx.restore();

    // Room edge ambient glow (inner shadow)
    const glowGrad = ctx.createRadialGradient(
      rm.x + rm.w / 2, rm.y + rm.h / 2, Math.min(rm.w, rm.h) * 0.3,
      rm.x + rm.w / 2, rm.y + rm.h / 2, Math.max(rm.w, rm.h) * 0.6
    );
    glowGrad.addColorStop(0, 'rgba(0,0,0,0)');
    glowGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
  });

  // Draw floor decorations (non-collision)
  drawFloorDecorations();

  // Draw ambient room details (pipes, wiring, wall decorations)
  drawAmbientDetails();

  // Outer arena border with glow
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 4;
  ctx.strokeRect(20, 20, ARENA_W - 40, ARENA_H - 40);
  ctx.strokeStyle = 'rgba(16,185,129,0.06)';
  ctx.lineWidth = 8;
  ctx.strokeRect(16, 16, ARENA_W - 32, ARENA_H - 32);
}

function drawFloorDecorations() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  FLOOR_DECORATIONS.forEach(d => {
    if (d.x + (d.w || 60) < vx - 20 || d.x > vx + vw + 20 ||
        d.y + (d.h || 60) < vy - 20 || d.y > vy + vh + 20) return;

    switch (d.type) {
      case 'rug': {
        ctx.fillStyle = d.color || 'rgba(100,50,50,0.15)';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 4); ctx.fill();
        // Rug border
        ctx.strokeStyle = d.border || 'rgba(150,80,80,0.12)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(d.x + 4, d.y + 4, d.w - 8, d.h - 8, 3); ctx.stroke();
        // Rug pattern - center diamond
        ctx.strokeStyle = d.border || 'rgba(150,80,80,0.08)';
        ctx.lineWidth = 1;
        const cx = d.x + d.w / 2, cy = d.y + d.h / 2;
        ctx.beginPath();
        ctx.moveTo(cx, d.y + 12); ctx.lineTo(d.x + d.w - 12, cy);
        ctx.lineTo(cx, d.y + d.h - 12); ctx.lineTo(d.x + 12, cy);
        ctx.closePath(); ctx.stroke();
        break;
      }
      case 'vent': {
        ctx.fillStyle = '#141418';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 3); ctx.fill();
        // Grate lines
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        const slats = Math.floor(d.w / 8);
        for (let i = 1; i < slats; i++) {
          ctx.beginPath();
          ctx.moveTo(d.x + i * (d.w / slats), d.y + 2);
          ctx.lineTo(d.x + i * (d.w / slats), d.y + d.h - 2);
          ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 3); ctx.stroke();
        // Screws
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath(); ctx.arc(d.x + 4, d.y + 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + d.w - 4, d.y + 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + 4, d.y + d.h - 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + d.w - 4, d.y + d.h - 4, 2, 0, Math.PI * 2); ctx.fill();
        break;
      }
      case 'floor-mark': {
        ctx.fillStyle = d.color || 'rgba(255,200,0,0.05)';
        ctx.fillRect(d.x, d.y, d.w, d.h);
        break;
      }
      case 'puddle': {
        ctx.fillStyle = 'rgba(80,160,220,0.06)';
        ctx.beginPath();
        ctx.ellipse(d.x + d.w / 2, d.y + d.h / 2, d.w / 2, d.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        // Reflection highlight
        ctx.fillStyle = 'rgba(150,220,255,0.04)';
        ctx.beginPath();
        ctx.ellipse(d.x + d.w * 0.4, d.y + d.h * 0.35, d.w * 0.2, d.h * 0.15, 0.3, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'mat': {
        ctx.fillStyle = d.color || 'rgba(60,60,60,0.15)';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 2); ctx.fill();
        break;
      }
      case 'drain': {
        ctx.fillStyle = '#101014';
        ctx.beginPath();
        ctx.arc(d.x + d.w / 2, d.y + d.h / 2, d.w / 2, 0, Math.PI * 2);
        ctx.fill();
        // Drain cross
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        const dcx = d.x + d.w / 2, dcy = d.y + d.h / 2, dr = d.w / 2 - 3;
        ctx.beginPath(); ctx.moveTo(dcx - dr, dcy); ctx.lineTo(dcx + dr, dcy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(dcx, dcy - dr); ctx.lineTo(dcx, dcy + dr); ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.beginPath(); ctx.arc(dcx, dcy, d.w / 2, 0, Math.PI * 2); ctx.stroke();
        break;
      }
      case 'cable': {
        ctx.strokeStyle = d.color || 'rgba(200,50,50,0.12)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.5, d.y + d.h, d.x + d.w, d.y + d.h * 0.3);
        ctx.stroke();
        break;
      }
      case 'tire-marks': {
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.3, d.y + d.h * 0.5, d.x + d.w, d.y + d.h);
        ctx.stroke();
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(d.x + 14, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.3 + 14, d.y + d.h * 0.5, d.x + d.w + 14, d.y + d.h);
        ctx.stroke();
        break;
      }
      case 'warning-stripes': {
        ctx.save();
        ctx.beginPath();
        ctx.rect(d.x, d.y, d.w, d.h);
        ctx.clip();
        const stripeW = 12;
        ctx.fillStyle = 'rgba(255,200,0,0.06)';
        for (let sx = d.x - d.h; sx < d.x + d.w + d.h; sx += stripeW * 2) {
          ctx.beginPath();
          ctx.moveTo(sx, d.y + d.h);
          ctx.lineTo(sx + d.h, d.y);
          ctx.lineTo(sx + d.h + stripeW, d.y);
          ctx.lineTo(sx + stripeW, d.y + d.h);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
        break;
      }
    }
  });
}

function drawAmbientDetails() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  ROOMS.forEach(rm => {
    if (rm.x + rm.w < vx - 50 || rm.x > vx + vw + 50 ||
        rm.y + rm.h < vy - 50 || rm.y > vy + vh + 50) return;

    ctx.save();
    // Clip to room bounds so we don't bleed out
    ctx.beginPath();
    ctx.rect(rm.x, rm.y, rm.w, rm.h);
    ctx.clip();
    
    // Draw 3D floor/wall junction line to add depth to the floors themselves
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(rm.x, rm.y, rm.w, 15);
    ctx.fillRect(rm.x, rm.y, 15, rm.h);

    switch (rm.name) {
      case 'Kitchen': {
        // Kitchen Back Wall (Industrial Ovens built-in)
        ctx.fillStyle = '#1c2024'; ctx.fillRect(rm.x, rm.y, rm.w, 80);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
        for (let ox = rm.x + 80; ox < rm.x + rm.w - 100; ox += 160) {
            ctx.fillStyle = '#4a5560'; ctx.fillRect(ox, rm.y, 120, 60); ctx.strokeRect(ox, rm.y, 120, 60);
            ctx.fillStyle = '#0a0c0f'; ctx.fillRect(ox+10, rm.y+10, 100, 40); ctx.strokeRect(ox+10, rm.y+10, 100, 40);
            // Flames inside oven
            ctx.fillStyle = 'rgba(255, 100, 0, 0.4)';
            ctx.beginPath(); ctx.ellipse(ox+60, rm.y+35, 40, 10, 0, 0, Math.PI*2); ctx.fill();
        }
        break;
      }
      case 'Cafeteria': {
        // Cafeteria Buffet line built into the north wall
        ctx.fillStyle = '#3a4a5a'; ctx.fillRect(rm.x, rm.y, rm.w, 120);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(rm.x + 40, rm.y + 40, rm.w - 80, 60); ctx.strokeRect(rm.x + 40, rm.y + 40, rm.w - 80, 60);
        // Food trays
        for (let fx = rm.x + 80; fx < rm.x + rm.w - 120; fx += 140) {
            ctx.fillStyle = '#c0392b'; ctx.fillRect(fx, rm.y + 50, 100, 40); ctx.strokeRect(fx, rm.y + 50, 100, 40);
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(fx+10, rm.y + 60, 80, 20); // The "Food"
        }
        break;
      }
      case 'Living Room': {
        // ADMIN Room: The giant map table in the center
        // Background wall super-computers
        ctx.fillStyle = '#1c222e'; ctx.fillRect(rm.x, rm.y, rm.w, 100);
        ctx.fillStyle = '#2c3e50'; ctx.fillRect(rm.x+50, rm.y, rm.w-100, 80);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(rm.x+50, rm.y, rm.w-100, 80);
        // Giant glowing map screen on wall
        ctx.fillStyle = '#0984e3'; ctx.fillRect(rm.x+100, rm.y+10, rm.w-200, 60);
        ctx.fillStyle = '#00cec9'; ctx.fillRect(rm.x+150, rm.y+20, rm.w-350, 40);
        break;
      }
      case 'Bathroom': {
        // MEDBAY: Glowing bio-scanners and beds
        ctx.fillStyle = '#bac7d6'; ctx.fillRect(rm.x, rm.y, rm.w, 100);
        // Medical Pods against the wall
        for (let mx = rm.x + 80; mx < rm.x + rm.w - 150; mx += 200) {
            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(mx, rm.y, 140, 120);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(mx, rm.y, 140, 120);
            // Glowing scanner glass
            ctx.fillStyle = 'rgba(52, 152, 219, 0.4)';
            ctx.fillRect(mx + 20, rm.y + 20, 100, 80);
            ctx.beginPath(); ctx.moveTo(mx+20, rm.y+50); ctx.lineTo(mx+120, rm.y+50); ctx.strokeStyle='#00f2fe'; ctx.stroke();
        }
        // Occasional blood splatter (Among Us vibe)
        ctx.fillStyle = 'rgba(192, 57, 43, 0.8)';
        ctx.beginPath(); ctx.arc(rm.x + rm.w - 80, rm.y + 150, 20, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rm.x + rm.w - 60, rm.y + 170, 10, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rm.x + rm.w - 100, rm.y + 160, 15, 0, Math.PI*2); ctx.fill();
        break;
      }
      case 'Bedroom': {
        // COMMS: Radio desks and flashing servers
        ctx.fillStyle = '#1c222e'; ctx.fillRect(rm.x, rm.y, rm.w, 120);
        for (let sx = rm.x + 40; sx < rm.x + rm.w - 100; sx += 120) {
            ctx.fillStyle = '#2f3640'; ctx.fillRect(sx, rm.y, 100, 100);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(sx, rm.y, 100, 100);
            // Server lights
            ctx.fillStyle = (frameCount % 60 < 30) ? '#e84118' : '#4cd137';
            ctx.fillRect(sx + 20, rm.y + 20, 10, 10);
            ctx.fillStyle = (frameCount % 45 < 20) ? '#4cd137' : '#e84118';
            ctx.fillRect(sx + 40, rm.y + 20, 10, 10);
            ctx.fillStyle = '#192a56'; ctx.fillRect(sx+20, rm.y+40, 60, 15);
            ctx.fillRect(sx+20, rm.y+65, 60, 15);
        }
        break;
      }
      case 'Gym': {
        // WEAPONS: Giant Asteroid Cannon embedded in wall
        ctx.fillStyle = '#313335'; ctx.fillRect(rm.x, rm.y, rm.w, 140);
        ctx.fillStyle = '#222'; ctx.fillRect(rm.x + rm.w/2 - 150, rm.y, 300, 140);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(rm.x + rm.w/2 - 150, rm.y, 300, 140);
        // The cannon barrels
        ctx.fillStyle = '#111';
        ctx.fillRect(rm.x+rm.w/2 - 100, rm.y + 40, 200, 40);
        ctx.fillRect(rm.x+rm.w/2 - 40, rm.y + 80, 80, 60);
        break;
      }
      case 'Garden': {
        // O2 ROOM: Massive Oxygen Tanks
        ctx.fillStyle = '#2d3436'; ctx.fillRect(rm.x, rm.y, rm.w, 150);
        for (let tx = rm.x + 80; tx < rm.x + rm.w - 180; tx += 200) {
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.roundRect(tx, rm.y + 10, 140, 130, 20); ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(tx, rm.y + 10, 140, 130);
            // Green liquid inside
            ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
            ctx.fillRect(tx + 20, rm.y + 40, 100, 90);
            // Bubbles
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            const bob = (frameCount % 60) * 1.5;
            ctx.beginPath(); ctx.arc(tx + 40, rm.y + 120 - bob, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(tx + 80, rm.y + 90 - bob*0.8, 8, 0, Math.PI*2); ctx.fill();
        }
        break;
      }
      case 'Garage': {
        // REACTOR / TRASH ROOM: Giant garbage chute and engines
        // The garbage chute
        ctx.fillStyle = '#555'; ctx.fillRect(rm.x, rm.y, 250, 150);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(rm.x, rm.y, 250, 150);
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(rm.x + 125, rm.y + 75, 60, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
        ctx.font = '24px sans-serif'; ctx.fillText('TRASH', rm.x + 125, rm.y + 160);

        // Scattered trash bags (organic blobby shapes)
        function drawTrashBag(bx, by) {
            ctx.fillStyle = '#2c3e50'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.ellipse(bx, by, 30, 20, Math.random(), 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(bx-10, by-20); ctx.lineTo(bx, by-35); ctx.lineTo(bx+10, by-20); ctx.fill(); ctx.stroke();
        }
        drawTrashBag(rm.x + 200, rm.y + 180);
        drawTrashBag(rm.x + 250, rm.y + 150);
        drawTrashBag(rm.x + 160, rm.y + 200);

        break;
      }
      case 'Hallway': {
        // Hallway - massive wire bundles and structural pillars
        ctx.fillStyle = '#1e2025';
        for (let p = rm.x + 100; p < rm.x + rm.w; p += 400) {
            ctx.fillRect(p, rm.y, 60, 80);
            ctx.strokeStyle = '#000'; ctx.lineWidth=4; ctx.strokeRect(p, rm.y, 60, 80);
            ctx.fillStyle = '#facc15'; ctx.fillRect(p + 10, rm.y + 60, 40, 10);
        }
        break;
      }
    }

    ctx.restore();
  });
}
function getWallRoomColor(ox, oy) {
  // Find which room this wall belongs to based on proximity
  let best = null, bestDist = Infinity;
  ROOMS.forEach(rm => {
    const cx = rm.x + rm.w / 2, cy = rm.y + rm.h / 2;
    const d = Math.abs(ox + 8 - cx) + Math.abs(oy + 8 - cy);
    if (d < bestDist) { bestDist = d; best = rm; }
  });
  return best;
}

function drawObstacles() {
  MAP_OBSTACLES.forEach(o => {
    // Frustum culling
    if (o.x + o.w < camera.x - 20 || o.x > camera.x + window.innerWidth + 20 ||
        o.y + o.h < camera.y - 40 || o.y > camera.y + window.innerHeight + 40) return;

    if (o.type === 'wall') {
      const rm = getWallRoomColor(o.x, o.y);
      const wallBase = rm ? rm.wallColor : '#1e2538';
      const wallLight = rm ? rm.wallHighlight : '#2a3548';
      const trim = rm ? rm.trimColor : '#4a6a88';
      
      // Cyberpunk edge glow for bounds
      if (rm == null) {
          ctx.shadowColor = '#f20089';
          ctx.shadowBlur = 20;
      } else {
          ctx.shadowColor = rm.trimColor;
          ctx.shadowBlur = 10;
      }

      ctx.save();
      
      const wallDepth = 25; // How tall the walls are in 2.5D
      
      // Shadow (inner base)
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(o.x + 4, o.y + wallDepth + 4, o.w, o.h);
      ctx.shadowBlur = 0; // Turn off glow for geometry
      
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.lineJoin = 'round';

      // Wall front face (extrusion)
      ctx.fillStyle = wallBase;
      ctx.beginPath();
      ctx.rect(o.x, o.y + o.h, o.w, wallDepth);
      ctx.fill();
      ctx.stroke();
      
      // Trim/baseboard on the front face
      ctx.fillStyle = trim;
      ctx.fillRect(o.x, o.y + o.h + wallDepth - 6, o.w, 6);
      ctx.beginPath(); ctx.moveTo(o.x, o.y + o.h + wallDepth - 6); ctx.lineTo(o.x + o.w, o.y + o.h + wallDepth - 6); ctx.stroke();

      // Top face of the wall
      ctx.fillStyle = wallLight;
      ctx.beginPath();
      ctx.rect(o.x, o.y, o.w, o.h);
      ctx.fill();
      ctx.stroke();
      
      // Top face inner highlight
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(o.x + 4, o.y + 4, o.w - 8, Math.min(6, o.h - 8));
      
      // Subtle repeating panel lines on top face
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (o.w > o.h) {
          for (let px = o.x + 40; px < o.x + o.w; px += 40) {
              ctx.moveTo(px, o.y); ctx.lineTo(px, o.y + o.h);
          }
      } else {
          for (let py = o.y + 40; py < o.y + o.h; py += 40) {
              ctx.moveTo(o.x, py); ctx.lineTo(o.x + o.w, py);
          }
      }
      ctx.stroke();

      ctx.restore();
    } else {
      drawFurnitureItem(o);
    }
  });
}
// â”€â”€ FURNITURE RENDERER (TOP-DOWN SVG) â”€â”€
function drawFurnitureItem(o) {
  const x = o.x, y = o.y, w = o.w, h = o.h;
  ctx.save();
  
  // Outer Ambient Drop Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.shadowColor = '#00f2fe';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.roundRect(x + 5, y + 5, w, h + 15, 6);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Among Us Style 2.5D Renderer Helper
  function drawIsoProp(px, py, pw, ph, depth, tColor, fColor, isRound=false, customDetail=null) {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#000000';
    
    if (isRound) {
        // Back half / body extrusion
        ctx.fillStyle = fColor;
        ctx.beginPath(); ctx.ellipse(px + pw/2, py + ph/2 + depth, pw/2, ph/2, 0, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        // Body connection
        ctx.fillRect(px, py + ph/2, pw, depth);
        ctx.beginPath(); ctx.moveTo(px, py + ph/2); ctx.lineTo(px, py + ph/2 + depth); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(px+pw, py + ph/2); ctx.lineTo(px+pw, py + ph/2 + depth); ctx.stroke();
        // Top cap
        ctx.fillStyle = tColor;
        ctx.beginPath(); ctx.ellipse(px + pw/2, py + ph/2, pw/2, ph/2, 0, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        
        // Highlight
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath(); ctx.ellipse(px + pw/2, py + ph/2 - ph*0.1, pw*0.3, ph*0.2, 0, 0, Math.PI*2); ctx.fill();
        
        if (customDetail) customDetail(px, py, pw, ph, depth, tColor, fColor);
        return;
    }

    // Front/Side Face (Extrusion)
    ctx.fillStyle = fColor;
    ctx.beginPath();
    ctx.roundRect(px, py + ph - 4, pw, depth + 4, 4);
    ctx.fill(); 
    ctx.stroke();

    // Top Face
    ctx.fillStyle = tColor;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, 4);
    ctx.fill(); 
    ctx.stroke();
    
    // Top highlight rim
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(px + 4, py + 4, pw - 8, ph * 0.4, 2); ctx.fill();

    if (customDetail) customDetail(px, py, pw, ph, depth, tColor, fColor);
  }

  // Draw specific items
  switch (o.label) {
    case 'Stove':
      drawIsoProp(x, y, w, h, 20, '#596068', '#383d42', false, (px, py, pw, ph) => {
          ctx.fillStyle = '#111'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(px + pw*.3, py + ph*.3, ph*.15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.arc(px + pw*.7, py + ph*.3, ph*.15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.arc(px + pw*.3, py + ph*.7, ph*.15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.arc(px + pw*.7, py + ph*.7, ph*.15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.fillStyle = '#0a0c0f'; ctx.fillRect(px + pw*.1, py + ph + 2, pw*.8, 14);
      });
      break;
    case 'Fridge':
      drawIsoProp(x, y-10, w, h+10, 40, '#ccdae7', '#9ca8b5', false, (px, py, pw, ph, depth) => {
          ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(px, py + ph + 20); ctx.lineTo(px+pw, py + ph + 20); ctx.stroke();
          ctx.fillStyle = '#555'; ctx.fillRect(px+pw*.8, py+ph+5, 4, 12);
          ctx.fillRect(px+pw*.8, py+ph+23, 4, 15);
      });
      break;
    case 'Table':
    case 'Coffee Table':
    case 'Side Table':
    case 'Desk':
    case 'Workbench':
    case 'Food Counter':
      drawIsoProp(x, y, w, h, 14, '#bf8245', '#7a4f21', false, (px, py, pw, ph, depth) => {
          ctx.fillStyle = '#3e260e'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.roundRect(px + 4, py + ph + depth - 4, 6, 12, 1); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.roundRect(px + pw - 10, py + ph + depth - 4, 6, 12, 1); ctx.fill(); ctx.stroke();
      });
      break;
    case 'Couch':
    case 'Armchair':
      // The backrest
      drawIsoProp(x, y, w, h*.4, 30, '#e74c3c', '#c0392b', false);
      // The seat cushion
      drawIsoProp(x + 4, y + h*.4, w - 8, h*.6, 12, '#ff6b6b', '#e74c3c', false);
      // Armrests
      drawIsoProp(x, y + h*.1, Math.max(10, w*.15), h*.9, 15, '#e74c3c', '#c0392b', false);
      drawIsoProp(x + w - Math.max(10, w*.15), y + h*.1, Math.max(10, w*.15), h*.9, 15, '#e74c3c', '#c0392b', false);
      break;
    case 'TV':
      drawIsoProp(x, y, w, h, 8, '#2d3436', '#171a1c', false, (px, py, pw, ph) => {
          ctx.fillStyle = '#0984e3'; ctx.strokeStyle = '#000'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.roundRect(px+4, py+4, pw-8, ph-8, 2); ctx.fill(); ctx.stroke();
          ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.moveTo(px+pw*.1, py+ph*.1); ctx.lineTo(px+pw*.8, py+ph*.1); ctx.lineTo(px+pw*.1, py+ph*.8); ctx.fill();
      });
      break;
    case 'Bed':
      drawIsoProp(x, y, w, h, 14, '#7f8fa6', '#353b48', false);
      drawIsoProp(x+4, y+10, w-8, h-14, 8, '#273c75', '#192a56', false, (px, py, pw, ph) => {
          ctx.fillStyle = '#f5f6fa'; ctx.strokeStyle='#000'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.roundRect(px+pw*.1, py+4, pw*.3, 15, 3); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.roundRect(px+pw*.6, py+4, pw*.3, 15, 3); ctx.fill(); ctx.stroke();
      });
      break;
    case 'Wardrobe':
    case 'Cabinet':
    case 'Pantry':
    case 'Medicine Cabinet':
    case 'Bookshelf':
    case 'Shelving':
      drawIsoProp(x, y-10, w, h+10, 35, '#e1b12c', '#c23616', false, (px, py, pw, ph, depth) => {
          ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(px+pw/2, py+ph); ctx.lineTo(px+pw/2, py+ph+depth); ctx.stroke();
          ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(px+pw/2 - 6, py+ph+depth/2, 3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.arc(px+pw/2 + 6, py+ph+depth/2, 3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      });
      break;
    case 'Toilet': 
      drawIsoProp(x+w*.2, y, w*.6, h*.4, 25, '#f5f6fa', '#dcdde1', false); // Tank
      drawIsoProp(x+w*.25, y+h*.3, w*.5, h*.6, 15, '#fff', '#e5e7e9', true, (px,py,pw,ph)=>{
          ctx.fillStyle='#00a8ff'; ctx.beginPath(); ctx.ellipse(px+pw/2, py+ph/2, pw*.3, ph*.3, 0, 0, Math.PI*2); ctx.fill();
      });
      break;
    case 'Bathtub':
      drawIsoProp(x, y, w, h, 18, '#ffffff', '#dcdde1', false, (px, py, pw, ph) => {
          ctx.fillStyle = '#74b9ff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.roundRect(px+8, py+8, pw-16, ph-16, 8); ctx.fill(); ctx.stroke();
      });
      break;
    case 'Shower':
      drawIsoProp(x, y, w, h, 4, '#ebf5fb', '#cad8e3', false, (px, py, pw, ph) => {
          ctx.strokeStyle = '#000'; ctx.lineWidth=3; ctx.fillStyle = 'rgba(116, 185, 255, 0.4)';
          ctx.beginPath(); ctx.rect(px, py+ph, pw, 35); ctx.fill(); ctx.stroke();
          ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(px+pw/2, py+ph/2, 8, 0, Math.PI*2); ctx.fill();
      });
      break;
    case 'Vending':
      drawIsoProp(x, y, w, h, 40, '#e84118', '#c23616', false, (px, py, pw, ph, depth) => {
          ctx.fillStyle = '#2f3640'; ctx.strokeStyle='#000'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.roundRect(px+4, py+ph+4, pw-16, depth-14, 2); ctx.fill(); ctx.stroke();
          ctx.fillStyle = '#00a8ff'; ctx.fillRect(px+6, py+ph+6, pw-20, depth-30);
      });
      break;
    case 'Plant':
    case 'Tree':
    case 'Bush':
    case 'Potted Plant':
    case 'Flower Pot':
      drawIsoProp(x+w*.2, y+h*.4, w*.6, h*.4, 15, '#e17055', '#d63031', true);
      drawIsoProp(x-4, y, w+8, h*.6, 20, '#2ecc71', '#27ae60', true);
      break;
    case 'Car':
      drawIsoProp(x, y+h*.1, w, h*.8, 20, '#0984e3', '#0652dd', false);
      drawIsoProp(x+w*.2, y+h*.2, w*.5, h*.6, 15, '#74b9ff', '#0984e3', false);
      drawIsoProp(x+10, y-5, 16, h+10, 6, '#2d3436', '#1e272e', false);
      drawIsoProp(x+w-26, y-5, 16, h+10, 6, '#2d3436', '#1e272e', false);
      break;
    case 'Bin':
    case 'Trash Can':
    case 'Barrel':
    case 'Oil Can':
      drawIsoProp(x, y, w, h, 20, '#7f8fa6', '#353b48', true);
      break;
    case 'Boxes':
    case 'Cardboard Box':
      drawIsoProp(x, y, w, h, 25, '#cd6133', '#aa4b2b', false, (px, py, pw, ph) => {
          ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(px+pw/2, py); ctx.lineTo(px+pw/2, py+ph); ctx.stroke();
      });
      break;
    case 'Treadmill':
    case 'Rowing Machine':
    case 'Elliptical':
    case 'Exercise Bike':
      drawIsoProp(x, y, w, h, 10, '#353b48', '#2f3640', false, (px, py, pw, ph, depth) => {
          drawIsoProp(px, py, pw*.3, ph, 25, '#718093', '#2f3640', false);
      });
      break;
    case 'Dumbbells':
    case 'Weights':
    case 'Kettlebells':
      drawIsoProp(x, y, w, h, 4, '#1e272e', '#111', false, (px, py, pw, ph) => {
          drawIsoProp(px+pw*.1, py+ph*.2, pw*.2, ph*.6, 8, '#7f8fa6', '#353b48', true);
          drawIsoProp(px+pw*.7, py+ph*.2, pw*.2, ph*.6, 8, '#7f8fa6', '#353b48', true);
      });
      break;
    case 'Gym Mirror':
      drawIsoProp(x, y, w, h, 4, '#bdc3c7', '#7f8fa6', false, (px, py, pw, ph, depth) => {
          ctx.fillStyle = '#00a8ff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.rect(px, py+ph, pw, 35); ctx.fill(); ctx.stroke();
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath(); ctx.moveTo(px+pw*.2, py+ph+5); ctx.lineTo(px+pw*.8, py+ph+5); ctx.lineTo(px+pw*.2, py+ph+30); ctx.fill();
      });
      break;
    default:
      drawIsoProp(x, y, w, h, 20, '#00cec9', '#01a3a4', false);
      break;
  }
  
  ctx.restore();
}

function drawPowerups() {
  const time = frameCount / 60;
  powerups.forEach(pu => {
    if (!pu.alive) return;
    if (pu.x < camera.x - 40 || pu.x > camera.x + window.innerWidth + 40 ||
        pu.y < camera.y - 40 || pu.y > camera.y + window.innerHeight + 40) return;

    const bob = Math.sin(time * 3 + pu.bobPhase) * 5;
    const pulse = Math.sin(time * 4 + pu.bobPhase) * 0.15 + 0.85;
    const rotation = time * 0.5 + pu.bobPhase;

    // Ground shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(pu.x, pu.y + 10, POWERUP_RADIUS * 0.8, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Outer glow (pulsing)
    const glowGrd = ctx.createRadialGradient(pu.x, pu.y + bob, 2, pu.x, pu.y + bob, POWERUP_RADIUS + 14);
    glowGrd.addColorStop(0, pu.color + '30');
    glowGrd.addColorStop(0.5, pu.color + '10');
    glowGrd.addColorStop(1, pu.color + '00');
    ctx.fillStyle = glowGrd;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, (POWERUP_RADIUS + 14) * pulse, 0, Math.PI * 2);
    ctx.fill();

    // Spinning ring
    ctx.save();
    ctx.translate(pu.x, pu.y + bob);
    ctx.rotate(rotation);
    ctx.strokeStyle = pu.color + '25';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, POWERUP_RADIUS + 4, 0, Math.PI * 1.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, POWERUP_RADIUS + 4, Math.PI * 1.4, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // Main circle (gradient fill)
    const puGrd = ctx.createRadialGradient(pu.x - 3, pu.y + bob - 3, 2, pu.x, pu.y + bob, POWERUP_RADIUS);
    puGrd.addColorStop(0, pu.color + '70');
    puGrd.addColorStop(1, pu.color + '35');
    ctx.fillStyle = puGrd;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    // Circle border
    ctx.strokeStyle = pu.color + '90';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS, 0, Math.PI * 2);
    ctx.stroke();

    // Inner highlight
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.arc(pu.x - 2, pu.y + bob - 3, POWERUP_RADIUS * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Icon
    ctx.font = '16px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pu.icon, pu.x, pu.y + bob);
  });
}

function drawEntities() {
  // Collect all alive entities and sort by Y for depth
  const entities = [];
  if (player && player.alive) entities.push({ ...player, isPlayer: true });
  bots.forEach(b => { if (b.alive) entities.push(b); });
  entities.sort((a, b) => a.y - b.y);

  entities.forEach(e => {
    if (e.x < camera.x - 40 || e.x > camera.x + window.innerWidth + 40 ||
        e.y < camera.y - 50 || e.y > camera.y + window.innerHeight + 50) return;

    const isShielded = hasActivePowerup(e, 'shield');
    const isPowered = hasActivePowerup(e, 'power');
    const isSpeed = hasActivePowerup(e, 'speed');

    // Invincibility flash
    if (Date.now() < e.invincibleUntil && Math.floor(Date.now() / 100) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }

    // Speed trail effect
    if (isSpeed) {
      ctx.globalAlpha = 0.08;
      drawBean(ctx, e.x - (e.facingLeft ? -8 : 8), e.y + 2, e.color, 0.95, e.facingLeft, '', false, false);
      ctx.globalAlpha = 0.04;
      drawBean(ctx, e.x - (e.facingLeft ? -16 : 16), e.y + 4, e.color, 0.9, e.facingLeft, '', false, false);
      ctx.globalAlpha = Date.now() < e.invincibleUntil && Math.floor(Date.now() / 100) % 2 === 0 ? 0.5 : 1;
    }

    drawBean(ctx, e.x, e.y, e.color, 1, e.facingLeft, e.isPlayer ? '' : e.name, isShielded, isPowered);

    // HP bar above player (replaces dots for better visibility)
    if (e.isPlayer) {
      const barW = 34;
      const barH = 4;
      const barX = e.x - barW / 2;
      const barY = e.y - 40;
      const maxHp = 5;

      // Bar background
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.roundRect(barX - 1, barY - 1, barW + 2, barH + 2, 2);
      ctx.fill();

      // HP segments
      const segW = barW / maxHp;
      for (let i = 0; i < maxHp; i++) {
        if (i < e.hp) {
          // Gradient from green to red based on HP
          const hpRatio = e.hp / maxHp;
          const r = Math.round(255 * (1 - hpRatio));
          const g = Math.round(200 * hpRatio);
          ctx.fillStyle = `rgb(${r},${g},60)`;
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
        }
        ctx.fillRect(barX + i * segW + 0.5, barY, segW - 1, barH);
      }

      // Bar shine
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(barX, barY, barW, 1);
    } else {
      // Bot HP dots (smaller, above name)
      const dotSpacing = 8;
      const totalWidth = (e.hp - 1) * dotSpacing;
      for (let i = 0; i < e.hp; i++) {
        ctx.fillStyle = i < e.hp ? '#ef4444' : 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.arc(e.x - totalWidth / 2 + i * dotSpacing, e.y - 42, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  const mapW = 140;
  const mapH = mapW * (ARENA_H / ARENA_W);
  const padding = 12;
  const mx = window.innerWidth - mapW - padding;
  const my = window.innerHeight - mapH - padding - 60;
  const scale = mapW / ARENA_W;

  // Background with subtle gradient
  const mmBg = ctx.createLinearGradient(mx, my, mx, my + mapH);
  mmBg.addColorStop(0, 'rgba(8,12,24,0.92)');
  mmBg.addColorStop(1, 'rgba(12,16,30,0.92)');
  ctx.fillStyle = mmBg;
  ctx.beginPath();
  ctx.roundRect(mx - 6, my - 18, mapW + 12, mapH + 24, 8);
  ctx.fill();

  // Title
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '600 7px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('MAP', mx + mapW / 2, my - 8);

  // Border glow
  ctx.strokeStyle = 'rgba(16,185,129,0.2)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.roundRect(mx - 6, my - 18, mapW + 12, mapH + 24, 8);
  ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.roundRect(mx - 5, my - 17, mapW + 10, mapH + 22, 7);
  ctx.stroke();

  // Room floors with room-specific colors
  ROOMS.forEach(rm => {
    // Room floor with accent tint
    ctx.fillStyle = rm.floor;
    ctx.fillRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
    // Subtle room accent overlay
    ctx.fillStyle = rm.accent + '10';
    ctx.fillRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
    // Room border
    ctx.strokeStyle = rm.trimColor + '20';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
  });

  // Walls (brighter, more visible)
  MAP_OBSTACLES.forEach(o => {
    if (o.type === 'wall') {
      ctx.fillStyle = 'rgba(200,210,230,0.35)';
      ctx.fillRect(mx + o.x * scale, my + o.y * scale, Math.max(1, o.w * scale), Math.max(1, o.h * scale));
    }
  });

  // Furniture (subtle dots)
  MAP_OBSTACLES.forEach(o => {
    if (o.type === 'furniture') {
      ctx.fillStyle = 'rgba(100,140,200,0.15)';
      ctx.fillRect(mx + o.x * scale, my + o.y * scale, Math.max(1, o.w * scale), Math.max(1, o.h * scale));
    }
  });

  // Powerup dots
  powerups.forEach(pu => {
    if (!pu.alive) return;
    ctx.fillStyle = pu.color + '60';
    ctx.beginPath();
    ctx.arc(mx + pu.x * scale, my + pu.y * scale, 1.5, 0, Math.PI * 2);
    ctx.fill();
  });

  // Bots with colored rings
  bots.forEach(b => {
    if (!b.alive) return;
    // Outer ring
    ctx.strokeStyle = b.color.body + '80';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(mx + b.x * scale, my + b.y * scale, 3.5, 0, Math.PI * 2);
    ctx.stroke();
    // Inner dot
    ctx.fillStyle = b.color.body;
    ctx.beginPath();
    ctx.arc(mx + b.x * scale, my + b.y * scale, 2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Player (pulsing white dot)
  if (player && player.alive) {
    const pulse = Math.sin(frameCount / 30 * Math.PI * 2) * 0.3 + 0.7;
    // Player glow
    ctx.fillStyle = `rgba(255,255,255,${0.15 * pulse})`;
    ctx.beginPath();
    ctx.arc(mx + player.x * scale, my + player.y * scale, 6, 0, Math.PI * 2);
    ctx.fill();
    // Player dot
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(mx + player.x * scale, my + player.y * scale, 3, 0, Math.PI * 2);
    ctx.fill();
    // Player direction indicator
    const dir = player.facingLeft ? -1 : 1;
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(mx + player.x * scale + dir * 5, my + player.y * scale);
    ctx.lineTo(mx + player.x * scale + dir * 2, my + player.y * scale - 2);
    ctx.lineTo(mx + player.x * scale + dir * 2, my + player.y * scale + 2);
    ctx.closePath();
    ctx.fill();

    // Camera viewport rectangle
    ctx.strokeStyle = 'rgba(16,185,129,0.25)';
    ctx.lineWidth = 0.8;
    ctx.strokeRect(
      mx + camera.x * scale,
      my + camera.y * scale,
      window.innerWidth * scale,
      window.innerHeight * scale
    );
  }
}

function updateActionButton() {
  if (!player || !player.alive) return;
  const btn = document.getElementById('action-btn');
  let nearestDist = Infinity;
  bots.forEach(b => {
    if (!b.alive) return;
    const d = dist(player, b);
    if (d < nearestDist) nearestDist = d;
  });

  if (nearestDist < BATTLE_RANGE + 30) {
    btn.classList.add('battle-ready');
    btn.textContent = 'BATTLE!';
  } else {
    btn.classList.remove('battle-ready');
    btn.textContent = 'SCAN';
  }
}

// â”€â”€ START â”€â”€
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
