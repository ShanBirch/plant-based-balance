<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>FitGotchi Arena - Battle Mode</title>
<meta name="description" content="Battle your friends in the FitGotchi Arena! Your fitness powers your fighter.">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet"/>
<link href="manifest.json" rel="manifest"/>
<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.1.0/model-viewer.min.js"></script>
<style>
  :root {
    --arena-bg: #0a0e1a;
    --arena-accent: #10b981;
    --arena-accent-glow: rgba(16, 185, 129, 0.4);
    --arena-secondary: #8b5cf6;
    --arena-danger: #ef4444;
    --arena-warning: #fbbf24;
    --arena-text: #f1f5f9;
    --arena-muted: rgba(255,255,255,0.5);
    --arena-surface: rgba(255,255,255,0.06);
    --arena-border: rgba(255,255,255,0.1);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', sans-serif;
    background: var(--arena-bg);
    color: var(--arena-text);
    overflow: hidden;
    height: 100vh;
    height: 100dvh;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }

  /* ‚îÄ‚îÄ HUD ‚îÄ‚îÄ */
  .arena-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(180deg, rgba(10,14,26,0.95) 0%, transparent 100%);
    pointer-events: none;
  }
  .arena-hud > * { pointer-events: auto; }

  .hud-left { display: flex; align-items: center; gap: 10px; }
  .hud-back {
    width: 36px; height: 36px; border-radius: 50%;
    background: var(--arena-surface); border: 1px solid var(--arena-border);
    color: var(--arena-text); font-size: 1.1rem;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .hud-title {
    font-size: 0.85rem; font-weight: 800;
    color: var(--arena-accent);
    text-shadow: 0 0 20px var(--arena-accent-glow);
    text-transform: uppercase; letter-spacing: 1px;
  }

  .hud-stats {
    display: flex; gap: 8px;
  }
  .hud-stat {
    background: var(--arena-surface);
    border: 1px solid var(--arena-border);
    border-radius: 20px; padding: 5px 12px;
    font-size: 0.75rem; font-weight: 700;
    display: flex; align-items: center; gap: 4px;
  }

  /* ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ */
  #arena-canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
  }

  /* ‚îÄ‚îÄ Virtual Joystick ‚îÄ‚îÄ */
  .joystick-zone {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 50%;
    height: 40%;
    z-index: 50;
    touch-action: none;
  }
  .joystick-base {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.06);
    border: 2px solid rgba(255,255,255,0.15);
    display: none;
    pointer-events: none;
  }
  .joystick-thumb {
    position: absolute;
    width: 50px; height: 50px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(16,185,129,0.6), rgba(16,185,129,0.2));
    border: 2px solid rgba(16,185,129,0.5);
    display: none;
    pointer-events: none;
  }

  /* ‚îÄ‚îÄ Visible D-Pad hint ‚îÄ‚îÄ */
  .dpad-hint {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 110px;
    height: 110px;
    z-index: 45;
    pointer-events: none;
    opacity: 0.35;
    transition: opacity 0.3s;
  }
  .dpad-hint.active {
    opacity: 0.6;
  }
  .dpad-center {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 32px; height: 32px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 1.5px solid rgba(255,255,255,0.25);
  }
  .dpad-arrow {
    position: absolute;
    width: 0; height: 0;
    border: 10px solid transparent;
  }
  .dpad-arrow.up {
    top: 4px; left: 50%;
    transform: translateX(-50%);
    border-bottom: 12px solid rgba(255,255,255,0.35);
    border-top: none;
  }
  .dpad-arrow.down {
    bottom: 4px; left: 50%;
    transform: translateX(-50%);
    border-top: 12px solid rgba(255,255,255,0.35);
    border-bottom: none;
  }
  .dpad-arrow.left {
    left: 4px; top: 50%;
    transform: translateY(-50%);
    border-right: 12px solid rgba(255,255,255,0.35);
    border-left: none;
  }
  .dpad-arrow.right {
    right: 4px; top: 50%;
    transform: translateY(-50%);
    border-left: 12px solid rgba(255,255,255,0.35);
    border-right: none;
  }


  /* ‚îÄ‚îÄ Action Button ‚îÄ‚îÄ */
  .action-zone {
    position: fixed;
    bottom: 30px;
    right: 20px;
    z-index: 50;
  }
  .action-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: 3px solid rgba(255,255,255,0.2);
    color: white;
    font-size: 0.7rem; font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    box-shadow: 0 0 30px var(--arena-accent-glow);
    transition: transform 0.1s, box-shadow 0.2s;
    display: flex; align-items: center; justify-content: center;
  }
  .action-btn:active { transform: scale(0.92); }
  .action-btn.battle-ready {
    background: linear-gradient(135deg, var(--arena-danger), #dc2626);
    box-shadow: 0 0 30px rgba(239,68,68,0.5);
    animation: pulse-battle 1s infinite;
  }
  @keyframes pulse-battle {
    0%,100% { box-shadow: 0 0 20px rgba(239,68,68,0.4); }
    50% { box-shadow: 0 0 40px rgba(239,68,68,0.7); }
  }

  /* ‚îÄ‚îÄ Players Alive Counter ‚îÄ‚îÄ */
  .players-alive {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 0.75rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(10px);
  }

  /* ‚îÄ‚îÄ Battle Overlay ‚îÄ‚îÄ */
  .battle-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .battle-overlay.active {
    display: flex;
    animation: battleIn 0.4s ease;
  }
  @keyframes battleIn {
    0% { opacity: 0; transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
  }

  .battle-vs {
    display: flex;
    align-items: center;
    gap: 30px;
    margin-bottom: 30px;
  }
  .battle-fighter {
    text-align: center;
  }
  .battle-fighter canvas {
    border-radius: 16px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.05);
  }
  .battle-fighter-name {
    margin-top: 8px;
    font-weight: 800;
    font-size: 0.9rem;
  }
  .battle-fighter-stats {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 4px;
  }
  .battle-vs-text {
    font-size: 2.5rem;
    font-weight: 900;
    color: var(--arena-danger);
    text-shadow: 0 0 30px rgba(239,68,68,0.5);
  }

  /* ‚îÄ‚îÄ Battle Combat Zone (stacks viewport + info panel) ‚îÄ‚îÄ */
  .battle-combat-zone {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  /* ‚îÄ‚îÄ Battle Viewport (matches tamagotchi widget: 420px) ‚îÄ‚îÄ */
  .battle-viewport {
    position: relative;
    width: 100%;
    height: 420px;
    min-height: 320px;
    background: #1a1a2e;
    overflow: hidden;
    flex-shrink: 0;
  }

  .battle-viewport .dojo-bg {
    position: absolute;
    inset: 0;
    background: url('./assets/battle_dojo_bg.jpeg') center center / cover no-repeat;
    z-index: 0;
  }
  .battle-viewport .dojo-bg::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.15);
    pointer-events: none;
  }

  .battle-viewport model-viewer {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: -30%;
    z-index: 3;
    --poster-color: transparent;
    background: transparent;
    transform: scale(0.75);
    transform-origin: center center;
  }

  .battle-viewport .battle-overlay-text {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
    background: rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .battle-viewport .battle-overlay-text.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
  }
  .battle-viewport .battle-overlay-text .battle-text {
    color: white;
    font-size: 2.5rem;
    font-weight: 900;
    text-shadow: 0 0 20px rgba(255,0,0,0.8), 0 4px 20px rgba(0,0,0,0.7);
    font-family: 'Inter', sans-serif;
    text-transform: uppercase;
    text-align: center;
    line-height: 1.3;
  }

  /* ‚îÄ‚îÄ HP bars (overlaid on viewport) ‚îÄ‚îÄ */
  .battle-hp-container {
    position: absolute;
    top: 12px;
    left: 12px;
    right: 12px;
    display: none;
    justify-content: space-between;
    z-index: 150;
    pointer-events: none;
  }
  .battle-hp-container.active {
    display: flex;
  }
  .battle-hp-box {
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(6px);
    border-radius: 10px;
    padding: 6px 10px;
    min-width: 120px;
    border: 1px solid rgba(255,255,255,0.15);
  }
  .battle-hp-box.enemy {
    text-align: right;
  }
  .battle-hp-name {
    font-size: 0.6rem;
    font-weight: 700;
    color: rgba(255,255,255,0.8);
    margin-bottom: 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .battle-hp-bar-bg {
    height: 6px;
    background: rgba(255,255,255,0.15);
    border-radius: 6px;
    overflow: hidden;
  }
  .battle-hp-bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.4s ease-out;
  }
  .battle-hp-bar-fill.player {
    background: linear-gradient(90deg, #2ecc71, #4ecdc4);
  }
  .battle-hp-bar-fill.enemy {
    background: linear-gradient(90deg, #e74c3c, #ff6b6b);
  }
  .battle-hp-text {
    font-size: 0.5rem;
    font-weight: 800;
    color: rgba(255,255,255,0.7);
    margin-top: 2px;
    font-family: 'Inter', sans-serif;
  }

  /* ‚îÄ‚îÄ Mana bar (above action buttons, bottom of viewport) ‚îÄ‚îÄ */
  .battle-mana-container {
    position: absolute;
    bottom: 95px;
    left: 12px;
    right: 12px;
    z-index: 150;
    pointer-events: none;
    display: none;
  }
  .battle-mana-container.active {
    display: block;
  }
  .battle-mana-label {
    font-size: 0.5rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
  }
  .battle-mana-bar-bg {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    overflow: hidden;
  }
  .battle-mana-bar-fill {
    height: 100%;
    border-radius: 8px;
    background: linear-gradient(90deg, #3498db, #45b7d1, #9b59b6);
    transition: width 0.2s linear;
    box-shadow: 0 0 8px rgba(52,152,219,0.4);
  }
  .battle-mana-bar-fill.full {
    animation: manaReady 0.5s ease-in-out infinite alternate;
  }
  @keyframes manaReady {
    0% { box-shadow: 0 0 8px rgba(52,152,219,0.4); }
    100% { box-shadow: 0 0 20px rgba(155,89,182,0.8); }
  }

  /* ‚îÄ‚îÄ Info Panel (below viewport) ‚îÄ‚îÄ */
  .battle-info-panel {
    flex: 1;
    width: 100%;
    padding: 16px 20px;
    overflow-y: auto;
    background: linear-gradient(180deg, #0d1117 0%, #0a0e1a 100%);
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .battle-info-title {
    text-align: center;
    font-size: 0.65rem;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--arena-accent);
    margin-bottom: 12px;
    opacity: 0.8;
  }
  .battle-info-opponent {
    display: flex;
    align-items: center;
    gap: 14px;
    background: rgba(255,255,255,0.04);
    border-radius: 14px;
    padding: 12px 16px;
    border: 1px solid rgba(255,255,255,0.06);
    margin-bottom: 12px;
  }
  .battle-info-opponent canvas {
    border-radius: 10px;
    background: rgba(255,255,255,0.03);
    flex-shrink: 0;
  }
  .battle-info-opponent-details {
    flex: 1;
    min-width: 0;
  }
  .battle-info-opponent-name {
    font-size: 1rem;
    font-weight: 800;
    color: white;
    margin-bottom: 2px;
  }
  .battle-info-opponent-level {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--arena-muted);
    margin-bottom: 6px;
  }
  .battle-info-stat-row {
    display: flex;
    gap: 12px;
  }
  .battle-info-stat {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.65rem;
    font-weight: 700;
    color: rgba(255,255,255,0.5);
  }
  .battle-info-stat span:first-child {
    color: rgba(255,255,255,0.3);
  }
  .battle-info-stat-val {
    color: rgba(255,255,255,0.8) !important;
  }

  .battle-info-round-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 0;
  }
  .battle-round-info {
    font-size: 0.75rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
  }
  .battle-round-score {
    display: inline-flex;
    gap: 6px;
    font-size: 0.85rem;
    font-weight: 900;
    margin-left: 8px;
  }
  .round-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: inline-block;
  }
  .round-dot.player-win { background: #2ecc71; }
  .round-dot.enemy-win { background: #ff4444; }

  .battle-timer {
    font-size: 1.6rem;
    font-weight: 900;
    color: var(--arena-warning);
    font-family: 'Inter', monospace;
  }

  /* ‚îÄ‚îÄ Action buttons (overlaid at bottom-right, dashboard style) ‚îÄ‚îÄ */
  .battle-action-container {
    position: absolute;
    bottom: 12px;
    right: 12px;
    z-index: 200;
    display: none;
    pointer-events: none;
  }
  .battle-action-container.active {
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: auto;
  }

  .battle-bash-btn {
    width: 80px;
    height: 80px;
    border: none;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff6b4a, #e63946);
    color: white;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    box-shadow: 0 4px 20px rgba(230,57,70,0.5), inset 0 2px 4px rgba(255,255,255,0.2);
    transition: transform 0.05s;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-bash-btn:active {
    transform: scale(0.88);
    box-shadow: 0 2px 10px rgba(230,57,70,0.7), inset 0 2px 4px rgba(0,0,0,0.2);
  }
  .battle-bash-btn .bash-icon { font-size: 1.5rem; line-height: 1; }
  .battle-bash-btn .bash-label { font-size: 0.55rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }

  .battle-bash-btn .bash-progress-ring {
    position: absolute;
    inset: -4px;
    pointer-events: none;
  }
  .battle-bash-btn .bash-progress-ring svg {
    width: 100%;
    height: 100%;
  }
  .bash-ring-bg {
    fill: none;
    stroke: rgba(255,255,255,0.15);
    stroke-width: 3;
  }
  .bash-ring-fill {
    fill: none;
    stroke: #FFD700;
    stroke-width: 3;
    stroke-dasharray: 163.36;
    stroke-dashoffset: 163.36;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.1s;
    transform: rotate(-90deg);
    transform-origin: center;
  }

  .battle-bash-btn.attack-ready {
    animation: bashReady 0.3s ease-in-out infinite alternate;
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff8c00);
  }
  @keyframes bashReady {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.5); transform: scale(1); }
    100% { box-shadow: 0 0 30px rgba(255,215,0,0.9); transform: scale(1.05); }
  }

  .battle-action-btn {
    width: 64px;
    height: 64px;
    border: none;
    border-radius: 50%;
    color: white;
    cursor: pointer;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-action-btn.visible {
    display: flex;
    animation: actionBtnAppear 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  .battle-action-btn .action-btn-icon { font-size: 1.3rem; line-height: 1; }
  .battle-action-btn .action-btn-label { font-size: 0.5rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }
  .battle-action-btn:active { transform: scale(0.85); }

  .battle-fire-btn {
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff6b00);
    box-shadow: 0 0 20px rgba(255,215,0,0.7), 0 0 40px rgba(255,107,0,0.4);
    animation: firePulse 0.5s ease-in-out infinite alternate;
  }
  @keyframes firePulse {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(255,215,0,0.9); transform: scale(1.08); }
  }

  .battle-block-btn {
    background: radial-gradient(circle at 30% 30%, #60a5fa, #2563eb);
    box-shadow: 0 0 20px rgba(96,165,250,0.7), 0 0 40px rgba(37,99,235,0.4);
    animation: blockPulse 0.4s ease-in-out infinite alternate;
  }
  @keyframes blockPulse {
    0% { box-shadow: 0 0 15px rgba(96,165,250,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(96,165,250,0.9); transform: scale(1.08); }
  }

  @keyframes actionBtnAppear {
    0% { transform: scale(0) rotate(-20deg); opacity: 0; }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
  }

  /* ‚îÄ‚îÄ Fireball projectile ‚îÄ‚îÄ */
  .fireball {
    position: absolute;
    pointer-events: none;
    z-index: 100;
    will-change: transform;
  }
  .fireball img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: auto;
  }

  /* ‚îÄ‚îÄ Hit flash ‚îÄ‚îÄ */
  .battle-hit-flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 210;
    animation: hitFlash 0.3s ease-out forwards;
  }
  @keyframes hitFlash {
    0% { background: rgba(255,68,68,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.blocked { animation-name: blockFlash; }
  @keyframes blockFlash {
    0% { background: rgba(59,130,246,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.super-hit { animation-name: superFlash; }
  @keyframes superFlash {
    0% { background: rgba(251,191,36,0.4); }
    100% { background: transparent; }
  }

  /* ‚îÄ‚îÄ Screen shake ‚îÄ‚îÄ */
  @keyframes battleShake {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-4px, 2px); }
    40% { transform: translate(4px, -2px); }
    60% { transform: translate(-2px, 4px); }
    80% { transform: translate(2px, -4px); }
  }
  .battle-shake { animation: battleShake 0.3s ease; }

  @keyframes roundTextPop {
    0% { transform: scale(0.3); opacity: 0; }
    60% { transform: scale(1.15); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  /* ‚îÄ‚îÄ Battle Result ‚îÄ‚îÄ */
  .battle-result {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }
  .battle-result.active { display: flex; }
  .battle-result-text {
    font-size: 2rem;
    font-weight: 900;
    text-transform: uppercase;
  }
  .battle-result-text.win { color: var(--arena-accent); text-shadow: 0 0 30px var(--arena-accent-glow); }
  .battle-result-text.lose { color: var(--arena-danger); }
  .battle-reward {
    font-size: 0.85rem;
    color: var(--arena-warning);
    font-weight: 700;
  }
  .battle-continue-btn {
    margin-top: 10px;
    padding: 12px 40px;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
  }

  /* ‚îÄ‚îÄ Lobby / Start Screen ‚îÄ‚îÄ */
  .lobby-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: linear-gradient(135deg, #0a0e1a 0%, #1a0e2e 50%, #0e1a2e 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
  }
  .lobby-overlay.hidden { display: none; }

  .lobby-title {
    font-size: 2.2rem;
    font-weight: 900;
    background: linear-gradient(135deg, var(--arena-accent), var(--arena-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }
  .lobby-subtitle {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 40px;
    max-width: 300px;
  }

  .lobby-avatar-preview {
    margin-bottom: 30px;
  }
  .lobby-avatar-preview canvas {
    border-radius: 20px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.03);
  }

  .lobby-customize {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 30px;
    max-width: 340px;
  }
  .lobby-color-btn {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: transform 0.15s, border-color 0.15s;
  }
  .lobby-color-btn:hover { transform: scale(1.15); }
  .lobby-color-btn.selected { border-color: white; transform: scale(1.15); }

  .lobby-start-btn {
    padding: 16px 50px;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 1.1rem;
    font-weight: 800;
    cursor: pointer;
    box-shadow: 0 4px 30px var(--arena-accent-glow);
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: transform 0.15s;
  }
  .lobby-start-btn:active { transform: scale(0.95); }

  .lobby-mode-select {
    display: flex;
    gap: 10px;
    margin-bottom: 24px;
  }
  .lobby-mode-btn {
    padding: 10px 20px;
    border-radius: 12px;
    border: 2px solid var(--arena-border);
    background: var(--arena-surface);
    color: var(--arena-text);
    font-size: 0.8rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
  }
  .lobby-mode-btn.selected {
    border-color: var(--arena-accent);
    background: rgba(16,185,129,0.15);
    color: var(--arena-accent);
  }

  /* ‚îÄ‚îÄ Game Over ‚îÄ‚îÄ */
  .gameover-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: rgba(0,0,0,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
  }
  .gameover-overlay.active { display: flex; animation: battleIn 0.5s ease; }
  .gameover-place {
    font-size: 4rem;
    font-weight: 900;
    margin-bottom: 8px;
  }
  .gameover-place.first {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .gameover-label {
    font-size: 1.3rem;
    font-weight: 800;
    color: var(--arena-text);
    margin-bottom: 4px;
  }
  .gameover-sub {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 30px;
  }
  .gameover-rewards {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  .gameover-reward {
    text-align: center;
  }
  .gameover-reward-val {
    font-size: 1.5rem;
    font-weight: 900;
    color: var(--arena-warning);
  }
  .gameover-reward-label {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 2px;
  }

  /* ‚îÄ‚îÄ Notifications ‚îÄ‚îÄ */
  .arena-notification {
    position: fixed;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 150;
    background: rgba(10,14,26,0.9);
    border: 1px solid var(--arena-accent);
    border-radius: 12px;
    padding: 10px 20px;
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--arena-accent);
    backdrop-filter: blur(10px);
    animation: notifIn 0.3s ease, notifOut 0.3s ease 2.5s forwards;
    white-space: nowrap;
  }
  @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
  @keyframes notifOut { to { opacity: 0; transform: translateX(-50%) translateY(-10px); } }

  /* ‚îÄ‚îÄ Powerup indicator ‚îÄ‚îÄ */
  .powerup-active {
    position: fixed;
    bottom: 120px;
    right: 20px;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .powerup-badge {
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 0.7rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 5px;
    animation: notifIn 0.3s ease;
  }
</style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LOBBY SCREEN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="lobby-overlay" id="lobby">
  <div class="lobby-title">FitGotchi Arena</div>
  <div class="lobby-subtitle">Your fitness powers your fighter. Battle your way to the top!</div>

  <div class="lobby-avatar-preview">
    <canvas id="lobby-avatar" width="140" height="160"></canvas>
  </div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Choose Your Color</div>
  <div class="lobby-customize" id="color-picker"></div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Arena Size</div>
  <div class="lobby-mode-select">
    <button class="lobby-mode-btn selected" onclick="selectMode(this,4)">4 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,6)">6 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,8)">8 Players</button>
  </div>

  <button class="lobby-start-btn" onclick="startGame()">Enter Arena</button>
  <div style="margin-top:12px;font-size:0.65rem;color:var(--arena-muted);">WASD / Arrow keys or touch joystick to move</div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME CANVAS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<canvas id="arena-canvas"></canvas>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HUD ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="arena-hud" id="hud" style="display:none;">
  <div class="hud-left">
    <button class="hud-back" onclick="exitArena()">&#8249;</button>
    <div class="hud-title">FitGotchi Arena</div>
  </div>
  <div class="hud-stats">
    <div class="hud-stat"><span>&#9876;</span> <span id="hud-kills">0</span></div>
    <div class="hud-stat"><span>&#9829;</span> <span id="hud-hp">3</span></div>
  </div>
</div>

<div class="players-alive" id="players-alive" style="display:none;">
  <span style="color:var(--arena-accent);">&#9679;</span>
  <span id="alive-count">8</span> alive
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê VIRTUAL JOYSTICK ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="joystick-zone" id="joystick-zone">
  <div class="joystick-base" id="joystick-base"></div>
  <div class="joystick-thumb" id="joystick-thumb"></div>
</div>
<div class="dpad-hint" id="dpad-hint" style="display:none;">
  <div class="dpad-center"></div>
  <div class="dpad-arrow up"></div>
  <div class="dpad-arrow down"></div>
  <div class="dpad-arrow left"></div>
  <div class="dpad-arrow right"></div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ACTION BUTTON ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="action-zone" id="action-zone" style="display:none;">
  <button class="action-btn" id="action-btn" onclick="handleAction()">SCAN</button>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ACTIVE POWERUPS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="powerup-active" id="powerup-active"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê BATTLE OVERLAY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="battle-overlay" id="battle-overlay">
  <div class="battle-vs" id="battle-vs"></div>
  <div class="battle-combat-zone" id="battle-combat-zone" style="display:none;">
    <!-- Battle Viewport (same as tamagotchi) -->
    <div class="battle-viewport" id="battle-viewport">
      <div class="dojo-bg"></div>
      <model-viewer
        id="arena-battle-model"
        camera-orbit="0deg 85deg 22m"
        field-of-view="55deg"
        min-field-of-view="20deg"
        max-field-of-view="120deg"
        shadow-intensity="1.5"
        shadow-softness="0.8"
        exposure="0.9"
        environment-image="neutral"
        interaction-prompt="none"
        disable-zoom
        disable-pan
        loading="eager"
        style="background: transparent;">
      </model-viewer>
      <!-- HP bars overlaid -->
      <div id="bc-hp-container" class="battle-hp-container">
        <div class="battle-hp-box player">
          <div class="battle-hp-name">YOU</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-player" class="battle-hp-bar-fill player" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-player-text" class="battle-hp-text">100 / 100</div>
        </div>
        <div class="battle-hp-box enemy">
          <div class="battle-hp-name" id="bc-enemy-name">OPPONENT</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-enemy" class="battle-hp-bar-fill enemy" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-enemy-text" class="battle-hp-text">100 / 100</div>
        </div>
      </div>
      <!-- Battle text overlay -->
      <div class="battle-overlay-text" id="bc-overlay-text">
        <div class="battle-text" id="bc-text-inner">BATTLE!</div>
      </div>
      <!-- Mana bar (above action buttons) -->
      <div id="bc-mana-container" class="battle-mana-container">
        <div class="battle-mana-label">SPECIAL <span id="bc-mana-pct">0%</span></div>
        <div class="battle-mana-bar-bg">
          <div id="bc-mana-fill" class="battle-mana-bar-fill" style="width: 0%;"></div>
        </div>
      </div>
      <!-- Action buttons (overlaid at bottom-right) -->
      <div id="bc-action-container" class="battle-action-container">
        <button id="bc-block-btn" class="battle-action-btn battle-block-btn" ontouchstart="combatBlock(event)" onmousedown="combatBlock(event)">
          <span class="action-btn-icon">üõ°Ô∏è</span>
          <span class="action-btn-label">BLOCK</span>
        </button>
        <button id="bc-bash-btn" class="battle-bash-btn" ontouchstart="combatBash(event)" onmousedown="combatBash(event)">
          <span class="bash-icon">üëä</span>
          <span class="bash-label">BASH!</span>
          <div class="bash-progress-ring">
            <svg viewBox="0 0 60 60">
              <circle cx="30" cy="30" r="26" class="bash-ring-bg"/>
              <circle cx="30" cy="30" r="26" class="bash-ring-fill" id="bash-ring-fill"/>
            </svg>
          </div>
        </button>
        <button id="bc-fire-btn" class="battle-action-btn battle-fire-btn" ontouchstart="combatFire(event)" onmousedown="combatFire(event)">
          <span class="action-btn-icon">üî•</span>
          <span class="action-btn-label">FIRE!</span>
        </button>
      </div>
    </div>
    <!-- Info Panel (below viewport) -->
    <div class="battle-info-panel" id="battle-info-panel">
      <div class="battle-info-title">Arena Battle Mode</div>
      <div class="battle-info-opponent" id="battle-info-opponent">
        <canvas id="battle-info-avatar" width="56" height="64"></canvas>
        <div class="battle-info-opponent-details">
          <div class="battle-info-opponent-name" id="bc-info-name">Opponent</div>
          <div class="battle-info-opponent-level" id="bc-info-level">Level ??</div>
          <div class="battle-info-stat-row" id="bc-info-stats">
            <div class="battle-info-stat"><span>STR</span> <span class="battle-info-stat-val" id="bc-info-str">?</span></div>
            <div class="battle-info-stat"><span>HP</span> <span class="battle-info-stat-val" id="bc-info-hp">?</span></div>
            <div class="battle-info-stat"><span>DEF</span> <span class="battle-info-stat-val" id="bc-info-def">?</span></div>
          </div>
        </div>
      </div>
      <div class="battle-info-round-row">
        <div class="battle-round-info">
          ROUND <span id="bc-round">1</span> / 3
          <span class="battle-round-score" id="bc-round-dots">
            <span class="round-dot" id="rd1"></span>
            <span class="round-dot" id="rd2"></span>
            <span class="round-dot" id="rd3"></span>
          </span>
        </div>
        <div class="battle-timer" id="bc-timer">30</div>
      </div>
    </div>
  </div>
  <div class="battle-result" id="battle-result"></div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME OVER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="gameover-overlay" id="gameover-overlay">
  <div class="gameover-place first" id="gameover-place">#1</div>
  <div class="gameover-label" id="gameover-label">Victory!</div>
  <div class="gameover-sub" id="gameover-sub">You outlasted everyone in the arena</div>
  <div class="gameover-rewards">
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-coins">+50</div>
      <div class="gameover-reward-label">Coins</div>
    </div>
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-xp">+25</div>
      <div class="gameover-reward-label">XP</div>
    </div>
  </div>
  <button class="lobby-start-btn" onclick="returnToLobby()">Play Again</button>
  <button style="margin-top:10px;padding:10px 30px;border-radius:10px;background:var(--arena-surface);border:1px solid var(--arena-border);color:var(--arena-text);font-size:0.85rem;font-weight:600;cursor:pointer;" onclick="exitArena()">Exit</button>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FITGOTCHI ARENA - Battle Mode Proof of Concept
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ
const ARENA_W = 4000;
const ARENA_H = 3000;
const TILE_SIZE = 60;
const PLAYER_RADIUS = 18;
const PLAYER_SPEED = 3;
const BOT_SPEED = 1.6;
const BATTLE_RANGE = 44;
const POWERUP_RADIUS = 14;

const BEAN_COLORS = [
  { name: 'Emerald',  body: '#10b981', dark: '#059669', visor: '#a7f3d0' },
  { name: 'Violet',   body: '#8b5cf6', dark: '#7c3aed', visor: '#c4b5fd' },
  { name: 'Coral',    body: '#ef4444', dark: '#dc2626', visor: '#fca5a5' },
  { name: 'Ocean',    body: '#3b82f6', dark: '#2563eb', visor: '#93c5fd' },
  { name: 'Amber',    body: '#f59e0b', dark: '#d97706', visor: '#fde68a' },
  { name: 'Rose',     body: '#ec4899', dark: '#db2777', visor: '#f9a8d4' },
  { name: 'Cyan',     body: '#06b6d4', dark: '#0891b2', visor: '#a5f3fc' },
  { name: 'Lime',     body: '#84cc16', dark: '#65a30d', visor: '#d9f99d' },
  { name: 'Slate',    body: '#64748b', dark: '#475569', visor: '#cbd5e1' },
  { name: 'White',    body: '#e2e8f0', dark: '#cbd5e1', visor: '#f8fafc' },
];

const POWERUP_TYPES = [
  { type: 'protein', icon: 'ü•§', label: 'Protein Shake', effect: 'speed', duration: 6000, color: '#a78bfa' },
  { type: 'broccoli', icon: 'ü•¶', label: 'Shield Up', effect: 'shield', duration: 8000, color: '#10b981' },
  { type: 'dumbbell', icon: 'üèãÔ∏è', label: 'Power Up', effect: 'power', duration: 5000, color: '#ef4444' },
  { type: 'apple', icon: 'üçé', label: 'Heal', effect: 'heal', duration: 0, color: '#f59e0b' },
];

// Map obstacle tiles (1 = wall, 2 = table/equipment)
const MAP_OBSTACLES = [];

// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
let canvas, ctx;
let gameState = 'lobby'; // lobby | playing | battle | gameover
let playerCount = 4;
let selectedColorIdx = 0;
let camera = { x: 0, y: 0 };
let player = null;
let bots = [];
let powerups = [];
let particles = [];
let battleState = null;
let inputDir = { x: 0, y: 0 };
let keys = {};
let joystickActive = false;
let joystickOrigin = { x: 0, y: 0 };
let frameCount = 0;
let lastTime = 0;
let eliminationOrder = [];

// Simulated fitness stats (would come from Supabase in prod)
// In production these are loaded from localStorage.battleStats + users table
let fitnessStats = {
  fitnessLevel: 65,
  energyLevel: 72,
  weeklyWorkoutCount: 4,
  level: 23,
  title: 'Growing',
  // Battle stats (STR/HP/MANA) - from the dashboard stat allocation system
  str: 15,   // Increases attack damage
  hp: 12,    // Increases max health pool (100 + hp*5)
  mana: 8,   // Reduces taps needed for special (max(10, 30 - mana/5))
};

// ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
function init() {
  canvas = document.getElementById('arena-canvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Read query params from dashboard launch
  const params = new URLSearchParams(window.location.search);
  if (params.get('players')) {
    playerCount = parseInt(params.get('players')) || 4;
    // Update lobby mode buttons
    document.querySelectorAll('.lobby-mode-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.textContent.trim() === playerCount + ' Players') btn.classList.add('selected');
    });
  }

  // Input
  window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.key] = false; });
  setupJoystick();

  // Color picker
  buildColorPicker();
  drawLobbyAvatar();

  // Generate map obstacles
  generateMap();

  // Start loop
  requestAnimationFrame(gameLoop);
}

function resizeCanvas() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

// ‚îÄ‚îÄ ROOM DEFINITIONS ‚îÄ‚îÄ
const WALL = 16;
const DOOR = 100; // doorway gap size
const ROOMS = [
  { name: 'Kitchen',     x: 40,   y: 40,   w: 1200, h: 940,  floor: '#1a1f14', accent: '#2d4a1e' },
  { name: 'Cafeteria',   x: 1300, y: 40,   w: 1400, h: 940,  floor: '#1a1420', accent: '#3d1e4a' },
  { name: 'Living Room', x: 2760, y: 40,   w: 1200, h: 940,  floor: '#1a1a28', accent: '#1e2d4a' },
  { name: 'Bathroom',    x: 40,   y: 1040, w: 900,  h: 920,  floor: '#141a1a', accent: '#1e3a4a' },
  { name: 'Hallway',     x: 1000, y: 1040, w: 2000, h: 920,  floor: '#18181f', accent: '#333340' },
  { name: 'Bedroom',     x: 3060, y: 1040, w: 900,  h: 920,  floor: '#201a1a', accent: '#4a1e2d' },
  { name: 'Gym',         x: 40,   y: 2020, w: 1200, h: 940,  floor: '#1f1a14', accent: '#4a3a1e' },
  { name: 'Garden',      x: 1300, y: 2020, w: 1400, h: 940,  floor: '#142014', accent: '#1e4a28' },
  { name: 'Garage',      x: 2760, y: 2020, w: 1200, h: 940,  floor: '#1a1a1a', accent: '#3a3a3a' },
];

// ‚îÄ‚îÄ MAP GENERATION ‚îÄ‚îÄ
function generateMap() {
  MAP_OBSTACLES.length = 0;

  // Helper: add a wall segment
  function wall(x, y, w, h) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'wall' });
  }
  // Helper: add furniture
  function furniture(x, y, w, h, icon, label) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'furniture', icon, label });
  }

  // ‚îÄ‚îÄ‚îÄ ROOM WALLS (with doorways) ‚îÄ‚îÄ‚îÄ

  // Kitchen walls
  wall(40, 40, 1200, WALL);              // top
  wall(40, 40, WALL, 940);               // left
  wall(40, 980 - WALL, 500, WALL);       // bottom-left
  wall(500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(1240 - WALL, 40, WALL, 400);      // right-top
  wall(1240 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Cafeteria walls
  wall(1300, 40, 1400, WALL);            // top
  wall(1300, 980 - WALL, 600, WALL);     // bottom-left
  wall(1300 + 600 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(2700 - WALL, 40, WALL, 400);      // right-top
  wall(2700 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Living Room walls
  wall(2760, 40, 1200, WALL);            // top
  wall(3960 - WALL, 40, WALL, 940);      // right
  wall(2760, 980 - WALL, 500, WALL);     // bottom-left
  wall(2760 + 500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right

  // Bathroom walls
  wall(40, 1040, WALL, 920);             // left
  wall(40, 1040, 900, WALL);             // top (shared)
  wall(40, 1960 - WALL, 400, WALL);      // bottom-left
  wall(400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right
  wall(940 - WALL, 1040, WALL, 400);     // right-top
  wall(940 - WALL, 1040 + 400 + DOOR, WALL, 520 - DOOR - WALL); // right-bottom

  // Hallway (open area, just top/bottom walls with doorways)
  wall(1000, 1040, 800, WALL);           // top-left section
  wall(1000 + 800 + DOOR, 1040, 1100 - DOOR, WALL); // top-right section
  wall(1000, 1960 - WALL, 700, WALL);    // bottom-left
  wall(1000 + 700 + DOOR, 1960 - WALL, 1200 - DOOR, WALL); // bottom-right

  // Bedroom walls
  wall(3060, 1040, 900, WALL);           // top
  wall(3960 - WALL, 1040, WALL, 920);    // right
  wall(3060, 1960 - WALL, 400, WALL);    // bottom-left
  wall(3060 + 400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right

  // Gym walls
  wall(40, 2020, WALL, 940);             // left
  wall(40, 2020, 1200, WALL);            // top
  wall(40, 2960 - WALL, 1200, WALL);     // bottom
  wall(1240 - WALL, 2020, WALL, 400);    // right-top
  wall(1240 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garden walls
  wall(1300, 2020, 600, WALL);           // top-left
  wall(1300 + 600 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(1300, 2960 - WALL, 1400, WALL);   // bottom
  wall(2700 - WALL, 2020, WALL, 400);    // right-top
  wall(2700 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garage walls
  wall(2760, 2020, 500, WALL);           // top-left
  wall(2760 + 500 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(3960 - WALL, 2020, WALL, 940);    // right
  wall(2760, 2960 - WALL, 1200, WALL);   // bottom

  // ‚îÄ‚îÄ‚îÄ FURNITURE ‚îÄ‚îÄ‚îÄ

  // Kitchen
  furniture(100, 100, 200, 60, 'üç≥', 'Stove');
  furniture(100, 200, 60, 120, 'üßä', 'Fridge');
  furniture(400, 100, 300, 50, 'üî™', 'Counter');
  furniture(800, 100, 120, 50, 'üçΩÔ∏è', 'Sink');
  furniture(500, 500, 180, 100, 'ü™ë', 'Table');
  furniture(900, 400, 80, 80, 'üóëÔ∏è', 'Bin');

  // Cafeteria
  furniture(1450, 200, 200, 80, 'ü™ë', 'Table');
  furniture(1750, 200, 200, 80, 'ü™ë', 'Table');
  furniture(1450, 500, 200, 80, 'ü™ë', 'Table');
  furniture(1750, 500, 200, 80, 'ü™ë', 'Table');
  furniture(2050, 350, 200, 80, 'ü™ë', 'Table');
  furniture(2350, 150, 80, 200, 'ü•§', 'Vending');

  // Living Room
  furniture(2900, 200, 280, 70, 'üõãÔ∏è', 'Couch');
  furniture(3300, 100, 120, 80, 'üì∫', 'TV');
  furniture(2900, 500, 120, 70, 'ü™ë', 'Armchair');
  furniture(3100, 450, 100, 60, '‚òï', 'Coffee Table');
  furniture(3500, 500, 80, 120, 'üìö', 'Bookshelf');
  furniture(3650, 200, 60, 60, 'ü™¥', 'Plant');

  // Bathroom
  furniture(120, 1120, 100, 80, 'üöø', 'Shower');
  furniture(120, 1400, 80, 50, 'ü™•', 'Sink');
  furniture(350, 1120, 60, 60, 'üöΩ', 'Toilet');
  furniture(600, 1120, 120, 60, 'üõÅ', 'Bathtub');
  furniture(600, 1600, 60, 60, 'üß∫', 'Laundry');

  // Hallway
  furniture(1200, 1200, 60, 60, 'ü™¥', 'Plant');
  furniture(1800, 1350, 100, 50, 'üñºÔ∏è', 'Bench');
  furniture(2400, 1200, 60, 60, 'ü™¥', 'Plant');
  furniture(1500, 1600, 80, 80, 'üóÑÔ∏è', 'Cabinet');
  furniture(2100, 1150, 60, 60, 'üí°', 'Lamp');

  // Bedroom
  furniture(3200, 1150, 200, 120, 'üõèÔ∏è', 'Bed');
  furniture(3600, 1150, 100, 70, 'üíª', 'Desk');
  furniture(3600, 1500, 80, 120, 'üëî', 'Wardrobe');
  furniture(3150, 1500, 60, 60, 'ü™¥', 'Plant');
  furniture(3750, 1350, 60, 60, 'ü™û', 'Mirror');

  // Gym
  furniture(200, 2150, 140, 60, 'üèãÔ∏è', 'Bench Press');
  furniture(500, 2150, 100, 60, 'üèãÔ∏è', 'Weights');
  furniture(200, 2450, 60, 140, 'üèÉ', 'Treadmill');
  furniture(400, 2450, 60, 140, 'üèÉ', 'Treadmill');
  furniture(700, 2300, 120, 60, 'üí™', 'Dumbbells');
  furniture(900, 2500, 80, 80, 'ü•ä', 'Punching Bag');
  furniture(700, 2650, 100, 50, 'üßò', 'Yoga Mat');

  // Garden
  furniture(1450, 2200, 100, 100, 'üå≥', 'Tree');
  furniture(1800, 2150, 100, 100, 'üå≥', 'Tree');
  furniture(2200, 2400, 100, 100, 'üå≥', 'Tree');
  furniture(1500, 2550, 80, 60, 'üåø', 'Bush');
  furniture(2000, 2600, 80, 60, 'üåø', 'Bush');
  furniture(1700, 2400, 120, 70, '‚õ≤', 'Fountain');
  furniture(2400, 2200, 60, 60, 'üåª', 'Flowers');

  // Garage
  furniture(2900, 2200, 220, 120, 'üöó', 'Car');
  furniture(3300, 2150, 80, 200, 'üîß', 'Workbench');
  furniture(3550, 2150, 120, 60, 'üß∞', 'Toolbox');
  furniture(2900, 2550, 100, 80, 'üõ¢Ô∏è', 'Barrel');
  furniture(3200, 2600, 100, 80, 'üì¶', 'Boxes');
  furniture(3600, 2500, 60, 100, 'ü™ú', 'Ladder');
}

// ‚îÄ‚îÄ COLOR PICKER ‚îÄ‚îÄ
function buildColorPicker() {
  const container = document.getElementById('color-picker');
  container.innerHTML = BEAN_COLORS.map((c, i) => `
    <button class="lobby-color-btn ${i === 0 ? 'selected' : ''}"
      style="background:${c.body};"
      onclick="selectColor(${i})"
      title="${c.name}"></button>
  `).join('');
}

function selectColor(idx) {
  selectedColorIdx = idx;
  document.querySelectorAll('.lobby-color-btn').forEach((btn, i) => {
    btn.classList.toggle('selected', i === idx);
  });
  drawLobbyAvatar();
}

function selectMode(btn, count) {
  playerCount = count;
  document.querySelectorAll('.lobby-mode-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
}

// ‚îÄ‚îÄ DRAW BEAN CHARACTER ‚îÄ‚îÄ
function drawBean(ctx, x, y, color, scale = 1, facingLeft = false, name = '', isShielded = false, isPowered = false) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);
  if (facingLeft) ctx.scale(-1, 1);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, 22, 16, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Shield glow
  if (isShielded) {
    ctx.strokeStyle = 'rgba(16,185,129,0.5)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, -2, 26, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = 'rgba(16,185,129,0.2)';
    ctx.lineWidth = 6;
    ctx.stroke();
  }

  // Power glow
  if (isPowered) {
    ctx.shadowColor = 'rgba(239,68,68,0.6)';
    ctx.shadowBlur = 15;
  }

  // Backpack (small bump on back)
  ctx.fillStyle = color.dark;
  ctx.beginPath();
  ctx.roundRect(-20, -8, 10, 20, 4);
  ctx.fill();

  // Body (bean shape)
  ctx.fillStyle = color.body;
  ctx.beginPath();
  ctx.moveTo(-14, 20);
  ctx.lineTo(-14, -8);
  ctx.quadraticCurveTo(-14, -24, 0, -24);
  ctx.quadraticCurveTo(14, -24, 14, -8);
  ctx.lineTo(14, 20);
  ctx.quadraticCurveTo(14, 24, 8, 24);
  ctx.lineTo(3, 24);
  ctx.lineTo(3, 20);
  ctx.lineTo(-3, 20);
  ctx.lineTo(-3, 24);
  ctx.lineTo(-8, 24);
  ctx.quadraticCurveTo(-14, 24, -14, 20);
  ctx.fill();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // Visor (Among Us style)
  ctx.fillStyle = color.visor;
  ctx.beginPath();
  ctx.ellipse(6, -6, 10, 8, 0.15, 0, Math.PI * 2);
  ctx.fill();

  // Visor shine
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.ellipse(9, -9, 4, 3, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Legs
  ctx.fillStyle = color.dark;
  ctx.fillRect(-10, 20, 6, 6);
  ctx.fillRect(4, 20, 6, 6);

  // Feet
  ctx.fillStyle = color.body;
  ctx.beginPath();
  ctx.roundRect(-12, 24, 10, 5, [0, 0, 3, 3]);
  ctx.fill();
  ctx.beginPath();
  ctx.roundRect(2, 24, 10, 5, [0, 0, 3, 3]);
  ctx.fill();

  if (facingLeft) ctx.scale(-1, 1);

  // Name tag
  if (name) {
    ctx.font = '600 9px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillText(name, 0, -30);
    ctx.fillStyle = '#fff';
    ctx.fillText(name, 0, -31);
  }

  ctx.restore();
}

function drawLobbyAvatar() {
  const c = document.getElementById('lobby-avatar');
  const lctx = c.getContext('2d');
  lctx.clearRect(0, 0, c.width, c.height);
  drawBean(lctx, 70, 90, BEAN_COLORS[selectedColorIdx], 2.5, false, '');
}

// ‚îÄ‚îÄ GAME START ‚îÄ‚îÄ
function startGame() {
  document.getElementById('lobby').classList.add('hidden');
  document.getElementById('hud').style.display = '';
  document.getElementById('players-alive').style.display = '';
  document.getElementById('action-zone').style.display = '';
  document.getElementById('dpad-hint').style.display = '';
  gameState = 'playing';

  // Create player
  player = {
    x: ARENA_W / 2,
    y: ARENA_H / 2,
    color: BEAN_COLORS[selectedColorIdx],
    name: 'You',
    hp: 3,
    kills: 0,
    speed: PLAYER_SPEED,
    facingLeft: false,
    alive: true,
    powerups: [],
    invincibleUntil: 0,
  };

  // Create bots
  bots = [];
  const botNames = ['FitFrog', 'GymRat', 'IronChef', 'CardioKing', 'FlexBot', 'GainzGuru', 'RunBuddy', 'LiftLord'];
  const usedColors = [selectedColorIdx];

  for (let i = 0; i < playerCount - 1; i++) {
    let colorIdx;
    do { colorIdx = Math.floor(Math.random() * BEAN_COLORS.length); }
    while (usedColors.includes(colorIdx));
    usedColors.push(colorIdx);

    const angle = (Math.PI * 2 * i) / (playerCount - 1);
    const dist = 400 + Math.random() * 300;
    bots.push({
      x: ARENA_W / 2 + Math.cos(angle) * dist,
      y: ARENA_H / 2 + Math.sin(angle) * dist,
      color: BEAN_COLORS[colorIdx],
      name: botNames[i % botNames.length],
      hp: 3,
      alive: true,
      facingLeft: false,
      speed: BOT_SPEED,
      powerups: [],
      invincibleUntil: 0,
      // AI state
      ai: {
        targetX: 0, targetY: 0,
        nextDecision: 0,
        state: 'wander', // wander | chase | flee | powerup
        targetEntity: null,
      },
      fitnessLevel: 30 + Math.floor(Math.random() * 50),
    });
  }

  // Spawn powerups
  spawnPowerups(8);

  eliminationOrder = [];
  showNotification('Arena started! Find and battle opponents!');
}

function spawnPowerups(count) {
  for (let i = 0; i < count; i++) {
    const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    let x, y, valid;
    // Ensure powerup doesn't overlap obstacles
    do {
      x = 80 + Math.random() * (ARENA_W - 160);
      y = 80 + Math.random() * (ARENA_H - 160);
      valid = !MAP_OBSTACLES.some(o =>
        x > o.x - 20 && x < o.x + o.w + 20 &&
        y > o.y - 20 && y < o.y + o.h + 20
      );
    } while (!valid);

    powerups.push({
      x, y, ...type,
      bobPhase: Math.random() * Math.PI * 2,
      alive: true,
    });
  }
}

// ‚îÄ‚îÄ JOYSTICK ‚îÄ‚îÄ
function setupJoystick() {
  const zone = document.getElementById('joystick-zone');
  const base = document.getElementById('joystick-base');
  const thumb = document.getElementById('joystick-thumb');
  const dpadHint = document.getElementById('dpad-hint');

  zone.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    const t = e.touches[0];
    joystickActive = true;
    joystickOrigin = { x: t.clientX, y: t.clientY };
    base.style.display = 'block';
    base.style.left = (t.clientX - 60) + 'px';
    base.style.top = (t.clientY - 60) + 'px';
    thumb.style.display = 'block';
    thumb.style.left = (t.clientX - 25) + 'px';
    thumb.style.top = (t.clientY - 25) + 'px';
    if (dpadHint) dpadHint.classList.add('active');
  }, { passive: false });

  zone.addEventListener('touchmove', e => {
    e.preventDefault();
    e.stopPropagation();
    if (!joystickActive) return;
    const t = e.touches[0];
    const dx = t.clientX - joystickOrigin.x;
    const dy = t.clientY - joystickOrigin.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    const maxDist = 50;
    const clampDist = Math.min(d, maxDist);
    const angle = Math.atan2(dy, dx);

    const thumbX = joystickOrigin.x + Math.cos(angle) * clampDist;
    const thumbY = joystickOrigin.y + Math.sin(angle) * clampDist;
    thumb.style.left = (thumbX - 25) + 'px';
    thumb.style.top = (thumbY - 25) + 'px';

    inputDir.x = (clampDist / maxDist) * Math.cos(angle);
    inputDir.y = (clampDist / maxDist) * Math.sin(angle);
  }, { passive: false });

  const endJoystick = () => {
    joystickActive = false;
    inputDir = { x: 0, y: 0 };
    base.style.display = 'none';
    thumb.style.display = 'none';
    if (dpadHint) dpadHint.classList.remove('active');
  };
  zone.addEventListener('touchend', endJoystick);
  zone.addEventListener('touchcancel', endJoystick);

  // Also listen on canvas itself for taps on right side ‚Üí tap-to-move
  canvas.addEventListener('touchstart', e => {
    if (gameState !== 'playing' || !player) return;
    const t = e.touches[0];
    // Only if tapping right half (joystick zone is left half)
    if (t.clientX > window.innerWidth * 0.5) {
      e.preventDefault();
      const worldX = t.clientX + camera.x;
      const worldY = t.clientY + camera.y;
      // Set a move target the player walks toward
      player._moveTarget = { x: worldX, y: worldY };
    }
  }, { passive: false });
}

// ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ
function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 16.67, 3); // normalize to ~60fps
  lastTime = timestamp;
  frameCount++;

  if (gameState === 'playing') {
    updateInput();
    updatePlayer(dt);
    updateBots(dt);
    checkCollisions();
    updatePowerups(dt);
    updateParticles(dt);
    updateCamera();
    checkGameOver();
  }

  render();
  requestAnimationFrame(gameLoop);
}

// ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ
function updateInput() {
  if (joystickActive) return; // joystick takes priority

  inputDir = { x: 0, y: 0 };
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) inputDir.x = -1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) inputDir.x = 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) inputDir.y = -1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) inputDir.y = 1;

  // Normalize
  const len = Math.sqrt(inputDir.x ** 2 + inputDir.y ** 2);
  if (len > 1) {
    inputDir.x /= len;
    inputDir.y /= len;
  }
}

// ‚îÄ‚îÄ PLAYER UPDATE ‚îÄ‚îÄ
function updatePlayer(dt) {
  if (!player || !player.alive) return;

  let moveX = inputDir.x;
  let moveY = inputDir.y;

  // Tap-to-move: walk toward target if no joystick/keyboard input
  if (moveX === 0 && moveY === 0 && player._moveTarget) {
    const dx = player._moveTarget.x - player.x;
    const dy = player._moveTarget.y - player.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > 5) {
      moveX = dx / d;
      moveY = dy / d;
    } else {
      player._moveTarget = null;
    }
  }

  const speed = player.speed * (hasActivePowerup(player, 'speed') ? 1.6 : 1) * dt;
  let nx = player.x + moveX * speed;
  let ny = player.y + moveY * speed;

  // Facing direction
  if (moveX < -0.1) player.facingLeft = true;
  if (moveX > 0.1) player.facingLeft = false;

  // Bounds
  nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
  ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

  // Obstacle collision
  if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
    player.x = nx;
    player.y = ny;
  } else if (!collidesWithObstacle(nx, player.y, PLAYER_RADIUS)) {
    player.x = nx;
  } else if (!collidesWithObstacle(player.x, ny, PLAYER_RADIUS)) {
    player.y = ny;
  }

  // Cancel tap-to-move on manual input
  if (inputDir.x !== 0 || inputDir.y !== 0) player._moveTarget = null;

  // Powerup expiry
  player.powerups = player.powerups.filter(p => Date.now() < p.expires);
  updatePowerupUI(player);
}

// ‚îÄ‚îÄ BOT AI ‚îÄ‚îÄ
function updateBots(dt) {
  const now = Date.now();
  bots.forEach(bot => {
    if (!bot.alive) return;

    const ai = bot.ai;

    // Decision timer
    if (now > ai.nextDecision) {
      ai.nextDecision = now + 1500 + Math.random() * 2000;

      // Find nearest alive entity
      let nearestBot = null;
      let nearestDist = Infinity;
      const allTargets = [player, ...bots].filter(e => e !== bot && e.alive);

      allTargets.forEach(target => {
        const d = dist(bot, target);
        if (d < nearestDist) {
          nearestDist = d;
          nearestBot = target;
        }
      });

      // Find nearest powerup
      let nearestPU = null;
      let nearestPUDist = Infinity;
      powerups.forEach(pu => {
        if (!pu.alive) return;
        const d = dist(bot, pu);
        if (d < nearestPUDist) {
          nearestPUDist = d;
          nearestPU = pu;
        }
      });

      // Decide behavior
      if (bot.hp <= 1 && nearestDist < 200) {
        // Low HP - flee from nearest
        ai.state = 'flee';
        ai.targetEntity = nearestBot;
      } else if (nearestPU && nearestPUDist < 300 && bot.powerups.length === 0) {
        // Go for nearby powerup
        ai.state = 'powerup';
        ai.targetX = nearestPU.x;
        ai.targetY = nearestPU.y;
      } else if (nearestBot && nearestDist < 350) {
        // Chase nearby opponent
        ai.state = 'chase';
        ai.targetEntity = nearestBot;
      } else {
        // Wander
        ai.state = 'wander';
        ai.targetX = 100 + Math.random() * (ARENA_W - 200);
        ai.targetY = 100 + Math.random() * (ARENA_H - 200);
      }
    }

    // Move based on AI state
    let tx, ty;
    if (ai.state === 'flee' && ai.targetEntity && ai.targetEntity.alive) {
      const dx = bot.x - ai.targetEntity.x;
      const dy = bot.y - ai.targetEntity.y;
      const d = Math.sqrt(dx * dx + dy * dy) || 1;
      tx = bot.x + (dx / d) * 200;
      ty = bot.y + (dy / d) * 200;
    } else if (ai.state === 'chase' && ai.targetEntity && ai.targetEntity.alive) {
      tx = ai.targetEntity.x;
      ty = ai.targetEntity.y;
    } else {
      tx = ai.targetX;
      ty = ai.targetY;
    }

    const dx = tx - bot.x;
    const dy = ty - bot.y;
    const d = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = bot.speed * (hasActivePowerup(bot, 'speed') ? 1.5 : 1) * dt;

    if (d > 5) {
      let nx = bot.x + (dx / d) * speed;
      let ny = bot.y + (dy / d) * speed;

      nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
      ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

      if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
        bot.x = nx;
        bot.y = ny;
      } else if (!collidesWithObstacle(nx, bot.y, PLAYER_RADIUS)) {
        bot.x = nx;
      } else if (!collidesWithObstacle(bot.x, ny, PLAYER_RADIUS)) {
        bot.y = ny;
      }

      bot.facingLeft = dx < 0;
    }

    // Bot powerup expiry
    bot.powerups = bot.powerups.filter(p => Date.now() < p.expires);
  });
}

// ‚îÄ‚îÄ COLLISIONS ‚îÄ‚îÄ
function checkCollisions() {
  if (!player || !player.alive) return;
  const now = Date.now();

  // Player vs bots
  bots.forEach(bot => {
    if (!bot.alive) return;
    if (now < player.invincibleUntil || now < bot.invincibleUntil) return;

    const d = dist(player, bot);
    if (d < BATTLE_RANGE) {
      startBattle(bot);
    }
  });

  // Bot vs bot
  for (let i = 0; i < bots.length; i++) {
    for (let j = i + 1; j < bots.length; j++) {
      if (!bots[i].alive || !bots[j].alive) continue;
      if (now < bots[i].invincibleUntil || now < bots[j].invincibleUntil) continue;
      const d = dist(bots[i], bots[j]);
      if (d < BATTLE_RANGE) {
        resolveBotBattle(bots[i], bots[j]);
      }
    }
  }

  // Player vs powerups
  powerups.forEach(pu => {
    if (!pu.alive) return;
    const d = dist(player, pu);
    if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
      collectPowerup(player, pu);
    }
  });

  // Bots vs powerups
  bots.forEach(bot => {
    if (!bot.alive) return;
    powerups.forEach(pu => {
      if (!pu.alive) return;
      const d = dist(bot, pu);
      if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
        collectPowerup(bot, pu);
      }
    });
  });
}

function collidesWithObstacle(x, y, r) {
  return MAP_OBSTACLES.some(o =>
    x + r > o.x && x - r < o.x + o.w &&
    y + r > o.y && y - r < o.y + o.h
  );
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

// ‚îÄ‚îÄ POWERUPS ‚îÄ‚îÄ
function collectPowerup(entity, pu) {
  pu.alive = false;

  if (pu.effect === 'heal') {
    entity.hp = Math.min(entity.hp + 1, 5);
    if (entity === player) {
      showNotification(`${pu.icon} Health restored!`);
      document.getElementById('hud-hp').textContent = player.hp;
    }
  } else {
    entity.powerups.push({
      type: pu.effect,
      icon: pu.icon,
      label: pu.label,
      expires: Date.now() + pu.duration,
    });
    if (entity === player) {
      showNotification(`${pu.icon} ${pu.label} activated!`);
    }
  }

  // Spawn particles
  for (let i = 0; i < 8; i++) {
    particles.push({
      x: pu.x, y: pu.y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 1,
      color: pu.color,
      size: 3 + Math.random() * 3,
    });
  }

  // Respawn a new powerup after delay
  setTimeout(() => {
    if (gameState === 'playing') spawnPowerups(1);
  }, 5000 + Math.random() * 5000);
}

function hasActivePowerup(entity, type) {
  return entity.powerups.some(p => p.type === type && Date.now() < p.expires);
}

function updatePowerups(dt) {
  // Bob animation handled in render
}

function updatePowerupUI(entity) {
  if (entity !== player) return;
  const container = document.getElementById('powerup-active');
  const active = entity.powerups.filter(p => Date.now() < p.expires);
  container.innerHTML = active.map(p => {
    const remaining = Math.ceil((p.expires - Date.now()) / 1000);
    return `<div class="powerup-badge">${p.icon} ${p.label} ${remaining}s</div>`;
  }).join('');
}

function updateParticles(dt) {
  particles = particles.filter(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= 0.03 * dt;
    p.vy += 0.1 * dt;
    return p.life > 0;
  });
}

// ‚îÄ‚îÄ BATTLE SYSTEM (Exact match to dashboard.html) ‚îÄ‚îÄ
// Uses model-viewer, fireball.png sprites, dojo background

const ROUND_DURATION = 30000;
const BASH_THRESHOLD_BASE = 30;
const AUTO_ATTACK_INTERVAL = 2500;
const BLOCK_WINDOW = 400;

let combat = null;

function startBattle(opponent) {
  if (gameState !== 'playing') return;
  gameState = 'battle';

  // Hide movement controls during battle
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';

  const overlay = document.getElementById('battle-overlay');
  overlay.classList.add('active');

  // Load model for battle viewport
  setupBattleModel();

  // VS screen
  const vsDiv = document.getElementById('battle-vs');
  vsDiv.innerHTML = `
    <div class="battle-fighter">
      <canvas id="battle-player-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${player.color.body}">You</div>
      <div class="battle-fighter-stats">STR ${fitnessStats.str || 10} / HP ${fitnessStats.hp || 10} / MANA ${fitnessStats.mana || 5}</div>
    </div>
    <div class="battle-vs-text">VS</div>
    <div class="battle-fighter">
      <canvas id="battle-opponent-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${opponent.color.body}">${opponent.name}</div>
      <div class="battle-fighter-stats">Lv.${opponent.fitnessLevel || '??'}</div>
    </div>
  `;

  setTimeout(() => {
    const pc = document.getElementById('battle-player-canvas');
    const oc = document.getElementById('battle-opponent-canvas');
    if (pc) drawBean(pc.getContext('2d'), 40, 50, player.color, 1.5);
    if (oc) drawBean(oc.getContext('2d'), 40, 50, opponent.color, 1.5, true);
  }, 50);

  battleState = { opponent, phase: 'intro' };

  // After VS intro, start combat
  setTimeout(() => {
    if (battleState) {
      vsDiv.style.display = 'none';
      initCombat(opponent);
    }
  }, 1500);
}

function initCombat(opponent) {
  const stats = fitnessStats;
  const playerSTR = stats.str || 10;
  const playerHP_stat = stats.hp || 10;
  const playerMANA = stats.mana || 5;

  const botLevel = opponent.fitnessLevel || 40;
  const botSTR = Math.floor(botLevel * 0.3);
  const botHP_stat = Math.floor(botLevel * 0.25);

  const playerMaxHP = 100 + (playerHP_stat * 5);
  const enemyMaxHP = 100 + (botHP_stat * 5);

  combat = {
    opponent,
    round: 1,
    playerRoundWins: 0,
    enemyRoundWins: 0,
    playerHP: playerMaxHP,
    playerMaxHP,
    enemyHP: enemyMaxHP,
    enemyMaxHP,
    playerSTR,
    enemySTR: botSTR,
    playerMANA,
    bashCount: 0,
    bashThreshold: Math.max(10, BASH_THRESHOLD_BASE - Math.floor(playerMANA / 5)),
    superReady: false,
    blockReady: false,
    blockSuccess: false,
    roundOver: false,
    timerEnd: Date.now() + ROUND_DURATION,
    autoAttackTimer: null,
    botAttackTimer: null,
    timerInterval: null,
  };

  // Show combat UI
  document.getElementById('battle-combat-zone').style.display = '';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Show HP bars + action container (mana bar hidden like dashboard)
  document.getElementById('bc-hp-container').classList.add('active');
  document.getElementById('bc-action-container').classList.add('active');

  // Play battle model animation
  const mv = document.getElementById('arena-battle-model');
  if (mv && mv.availableAnimations && mv.availableAnimations.length > 0) {
    const anims = mv.availableAnimations;
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a)) || anims[0];
    mv.animationName = attackAnim;
    mv.play({ repetitions: Infinity });
  }

  // Show BASH! overlay briefly
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.textContent = 'BASH!';
  overlayText.classList.add('active');
  setTimeout(() => overlayText.classList.remove('active'), 1000);

  // Update UI
  document.getElementById('bc-enemy-name').textContent = opponent.name.toUpperCase();
  updateCombatUI();
  updateRoundDots();

  // Populate info panel
  document.getElementById('bc-info-name').textContent = opponent.name;
  document.getElementById('bc-info-level').textContent = `Level ${botLevel}`;
  document.getElementById('bc-info-str').textContent = botSTR;
  document.getElementById('bc-info-hp').textContent = botHP_stat;
  document.getElementById('bc-info-def').textContent = Math.floor(botLevel * 0.2);
  // Draw opponent avatar in info panel
  const infoCanvas = document.getElementById('battle-info-avatar');
  if (infoCanvas && opponent.color) {
    drawBean(infoCanvas.getContext('2d'), 28, 36, opponent.color, 1.2, true);
  }

  // Start timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);

  // Player auto-attacks (fires normal fireballs)
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  // Bot attacks
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);

    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

function combatBash(e) {
  e.preventDefault();
  if (!combat || combat.roundOver) return;

  combat.bashCount++;
  if (navigator.vibrate) navigator.vibrate(30);

  // Bash button feedback
  const btn = document.getElementById('bc-bash-btn');
  btn.style.transform = 'scale(0.88)';
  setTimeout(() => { if (btn) btn.style.transform = ''; }, 50);

  // Update mana/charge bar + SVG ring
  const progress = Math.min(1, combat.bashCount / combat.bashThreshold);
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = (progress * 100) + '%';
  manaPct.textContent = Math.floor(progress * 100) + '%';

  // Update SVG ring (circumference = 2 * PI * 26 = 163.36)
  if (ringFill) {
    ringFill.style.strokeDashoffset = 163.36 * (1 - progress);
  }

  if (progress >= 1) {
    manaFill.classList.add('full');
    btn.classList.add('attack-ready');
  }

  // Check if super is charged
  if (combat.bashCount >= combat.bashThreshold && !combat.superReady) {
    combat.superReady = true;
    const fireBtn = document.getElementById('bc-fire-btn');
    fireBtn.classList.add('visible');
    if (navigator.vibrate) navigator.vibrate([50, 30, 50]);

    // Auto-reset if not fired in 2s
    combat.superTimeout = setTimeout(() => {
      if (combat && combat.superReady) {
        combat.superReady = false;
        combat.bashCount = 0;
        fireBtn.classList.remove('visible');
        manaFill.classList.remove('full');
        btn.classList.remove('attack-ready');
        manaFill.style.width = '0%';
        manaPct.textContent = '0%';
        if (ringFill) ringFill.style.strokeDashoffset = 163.36;
      }
    }, 2000);
  }
}

function combatFire(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.superReady) return;

  combat.superReady = false;
  combat.bashCount = 0;
  clearTimeout(combat.superTimeout);

  // Fire damage (full power) + triple fireball
  const dmg = Math.floor((10 + combat.playerSTR) * 1.0);
  dealDamageToEnemy(dmg, true);

  // Play attack animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv) {
    const anims = mv.availableAnimations || [];
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a));
    if (attackAnim) {
      mv.animationName = attackAnim;
      mv.play({ repetitions: 1 });
    }
  }

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const fireBtn = document.getElementById('bc-fire-btn');
  const bashBtn = document.getElementById('bc-bash-btn');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  manaPct.textContent = '0%';
  fireBtn.classList.remove('visible');
  bashBtn.classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;

  if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
}

function combatBlock(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.blockReady) return;

  combat.blockSuccess = true;
  combat.blockReady = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.remove('visible');

  showHitFlash('blocked');
  if (navigator.vibrate) navigator.vibrate([30, 20, 30]);
}

function showBlockPrompt() {
  if (!combat || combat.roundOver) return;
  combat.blockReady = true;
  combat.blockSuccess = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.add('visible');

  setTimeout(() => {
    if (combat) {
      combat.blockReady = false;
      blockBtn.classList.remove('visible');
    }
  }, BLOCK_WINDOW + 100);
}

function dealDamageToEnemy(dmg, isSuper) {
  if (!combat || combat.roundOver) return;
  combat.enemyHP = Math.max(0, combat.enemyHP - dmg);
  updateCombatUI();

  // Spawn fireball in viewport (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnTripleFireball(viewport);
  } else {
    spawnNormalFireball(viewport);
  }

  if (isSuper) {
    showHitFlash('super-hit');
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.enemyHP <= 0) {
    endRound(true);
  }
}

function dealDamageToPlayer(dmg, isSuper) {
  if (!combat || combat.roundOver) return;

  const blockMult = combat.blockSuccess ? 0.5 : 1.0;
  const actualDmg = Math.floor(dmg * blockMult);
  combat.playerHP = Math.max(0, combat.playerHP - actualDmg);
  const wasBlocked = combat.blockSuccess;
  combat.blockSuccess = false;
  updateCombatUI();

  // Spawn incoming fireball (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnIncomingTripleFireball(viewport);
  } else {
    spawnIncomingBattleFireball(viewport);
  }

  // Play hit animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv && !wasBlocked) {
    const anims = mv.availableAnimations || [];
    const hitAnim = anims.find(a => /hit|hurt|damage|flinch/i.test(a));
    if (hitAnim) {
      mv.animationName = hitAnim;
      mv.play({ repetitions: 1 });
    }
  }

  showHitFlash(wasBlocked ? 'blocked' : isSuper ? 'super-hit' : '');

  if (isSuper && !wasBlocked) {
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.playerHP <= 0) {
    endRound(false);
  }
}

function showHitFlash(type) {
  const flash = document.createElement('div');
  flash.className = 'battle-hit-flash ' + type;
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 400);
}

function updateCombatUI() {
  if (!combat) return;
  const { playerHP, playerMaxHP, enemyHP, enemyMaxHP } = combat;

  const playerPct = Math.max(0, (playerHP / playerMaxHP) * 100);
  const enemyPct = Math.max(0, (enemyHP / enemyMaxHP) * 100);

  document.getElementById('bc-hp-player').style.width = playerPct + '%';
  document.getElementById('bc-hp-enemy').style.width = enemyPct + '%';
  document.getElementById('bc-hp-player-text').textContent = `${Math.max(0,playerHP)} / ${playerMaxHP}`;
  document.getElementById('bc-hp-enemy-text').textContent = `${Math.max(0,enemyHP)} / ${enemyMaxHP}`;
}

function updateCombatTimer() {
  if (!combat) return;
  const remaining = Math.max(0, Math.ceil((combat.timerEnd - Date.now()) / 1000));
  document.getElementById('bc-timer').textContent = remaining;
  if (remaining <= 0 && !combat.roundOver) {
    // Time's up - higher HP% wins
    const playerPct = combat.playerHP / combat.playerMaxHP;
    const enemyPct = combat.enemyHP / combat.enemyMaxHP;
    endRound(playerPct >= enemyPct);
  }
}

function updateRoundDots() {
  if (!combat) return;
  for (let i = 1; i <= 3; i++) {
    const dot = document.getElementById('rd' + i);
    dot.className = 'round-dot';
    if (i <= combat.playerRoundWins) dot.classList.add('player-win');
  }
  // Show enemy wins on the other end conceptually via color
  document.getElementById('bc-round').textContent = combat.round;
}

function endRound(playerWon) {
  if (!combat || combat.roundOver) return;
  combat.roundOver = true;

  clearInterval(combat.autoAttackTimer);
  clearInterval(combat.botAttackTimer);
  clearInterval(combat.timerInterval);
  clearTimeout(combat.superTimeout);

  if (playerWon) {
    combat.playerRoundWins++;
  } else {
    combat.enemyRoundWins++;
  }

  updateRoundDots();

  // Check match result (best of 3)
  if (combat.playerRoundWins >= 2 || combat.enemyRoundWins >= 2) {
    const matchWon = combat.playerRoundWins >= 2;
    setTimeout(() => showBattleResult(matchWon,
      `${combat.playerRoundWins} - ${combat.enemyRoundWins}`), 800);
  } else {
    // Next round after brief pause
    showNotification(playerWon ? 'Round won!' : 'Round lost!');
    setTimeout(() => startNextRound(), 1500);
  }
}

function startNextRound() {
  if (!combat) return;
  combat.round++;
  combat.playerHP = combat.playerMaxHP;
  combat.enemyHP = combat.enemyMaxHP;
  combat.bashCount = 0;
  combat.superReady = false;
  combat.blockReady = false;
  combat.roundOver = false;
  combat.timerEnd = Date.now() + ROUND_DURATION;

  // Clear any remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Show round transition
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.innerHTML = `<div style="animation:roundTextPop 0.5s ease-out;">ROUND ${combat.round}</div>` +
    `<div style="font-size:0.6em;margin-top:8px;opacity:0.9;">${combat.playerRoundWins} - ${combat.enemyRoundWins}</div>`;
  overlayText.style.color = '#FFD700';
  overlayText.classList.add('active');
  setTimeout(() => { overlayText.classList.remove('active'); overlayText.style.color = ''; }, 1500);

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const ringFill = document.getElementById('bash-ring-fill');
  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  document.getElementById('bc-mana-pct').textContent = '0%';
  document.getElementById('bc-fire-btn').classList.remove('visible');
  document.getElementById('bc-block-btn').classList.remove('visible');
  document.getElementById('bc-bash-btn').classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;
  updateCombatUI();
  updateRoundDots();

  // Restart timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  const botLevel = combat.opponent.fitnessLevel || 40;
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);
    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

// ‚îÄ‚îÄ FIREBALL SYSTEM (matches dashboard exactly) ‚îÄ‚îÄ

function spawnNormalFireball(container) {
  const fb = document.createElement('div');
  fb.className = 'fireball';
  fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px;filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
  fb.style.cssText = 'position:absolute; left:150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
  container.appendChild(fb);
  let posX = 150;
  function move() {
    posX += 5;
    fb.style.left = posX + 'px';
    if (posX > container.clientWidth) fb.remove();
    else requestAnimationFrame(move);
  }
  move();
}

function spawnTripleFireball(container) {
  const offsets = [-80, 0, 80];
  offsets.forEach((yOff, i) => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;filter:drop-shadow(0 0 30px gold) brightness(1.3);">`;
    fb.style.cssText = `position:absolute; left:150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
    container.appendChild(fb);
    let posX = 150;
    const speed = 5 + i;
    function move() {
      posX += speed;
      fb.style.left = posX + 'px';
      if (posX > container.clientWidth) fb.remove();
      else requestAnimationFrame(move);
    }
    setTimeout(() => move(), i * 60);
  });
}

function spawnIncomingBattleFireball(container) {
  return new Promise(resolve => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px; transform:scaleX(-1); filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
    fb.style.cssText = 'position:absolute; right:-150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
    container.appendChild(fb);
    let posX = container.clientWidth;
    const targetX = container.clientWidth / 2;
    const speed = 4;
    function move() {
      posX -= speed;
      fb.style.left = posX + 'px';
      if (posX <= targetX) { fb.remove(); resolve(); }
      else requestAnimationFrame(move);
    }
    move();
  });
}

function spawnIncomingTripleFireball(container) {
  return new Promise(resolve => {
    const offsets = [-60, 0, 60];
    let resolved = false;
    offsets.forEach((yOff, i) => {
      const fb = document.createElement('div');
      fb.className = 'fireball';
      fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;transform:scaleX(-1);filter:drop-shadow(0 0 30px cyan) brightness(1.3);">`;
      fb.style.cssText = `position:absolute; right:-150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
      container.appendChild(fb);
      let posX = container.clientWidth;
      const targetX = container.clientWidth / 2;
      const speed = 4 + i;
      function move() {
        posX -= speed;
        fb.style.left = posX + 'px';
        if (posX <= targetX) {
          fb.remove();
          if (!resolved) { resolved = true; resolve(); }
        }
        else requestAnimationFrame(move);
      }
      setTimeout(() => move(), i * 60);
    });
  });
}

// Setup battle model from localStorage (same source as tamagotchi)
function setupBattleModel() {
  const mv = document.getElementById('arena-battle-model');
  if (!mv) return;
  const src = localStorage.getItem('fitgotchi_model_src') ||
    'https://f005.backblazeb2.com/file/shannonsvideos/baby_full_animations.glb';
  mv.setAttribute('src', src);
  mv.removeAttribute('auto-rotate');
  mv.removeAttribute('camera-controls');
  const savedOrbit = localStorage.getItem('fitgotchi_camera_orbit');
  if (savedOrbit) {
    // Extract distance from saved orbit, use 0deg 85deg for battle
    const match = savedOrbit.match(/([\d.]+m)$/);
    const dist = match ? match[1] : '22m';
    mv.setAttribute('camera-orbit', `0deg 85deg ${dist}`);
  }
}

function showBattleResult(won, detail = '') {
  // Hide combat zone
  document.getElementById('battle-combat-zone').style.display = 'none';

  // Hide battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');

  // Clear remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clean up combat timers
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
  }

  const resultDiv = document.getElementById('battle-result');
  resultDiv.classList.add('active');

  if (won) {
    resultDiv.innerHTML = `
      <div class="battle-result-text win">Victory!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-warning);margin:4px 0;">${detail}</div>
      <div class="battle-reward">+15 Coins  +10 XP</div>
      <button class="battle-continue-btn" onclick="endBattle(true)">Continue</button>
    `;
    battleState.opponent.hp -= 1;
    if (battleState.opponent.hp <= 0) {
      battleState.opponent.alive = false;
      player.kills++;
      eliminationOrder.push(battleState.opponent.name);
      document.getElementById('hud-kills').textContent = player.kills;
    }
  } else {
    resultDiv.innerHTML = `
      <div class="battle-result-text lose">Defeated!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-muted);margin:4px 0;">${detail}</div>
      <button class="battle-continue-btn" style="background:linear-gradient(135deg,var(--arena-secondary),#7c3aed);" onclick="endBattle(false)">Continue</button>
    `;
    player.hp -= 1;
    document.getElementById('hud-hp').textContent = player.hp;
    if (player.hp <= 0) {
      player.alive = false;
    }
  }

  updateAliveCount();
}

function endBattle(won) {
  const overlay = document.getElementById('battle-overlay');
  overlay.classList.remove('active');

  // Reset VS display for next battle
  document.getElementById('battle-vs').style.display = '';
  document.getElementById('battle-combat-zone').style.display = 'none';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Reset battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clear model src to free memory
  const mv = document.getElementById('arena-battle-model');
  if (mv) mv.removeAttribute('src');

  // Brief invincibility after battle
  const now = Date.now();
  player.invincibleUntil = now + 2000;
  if (battleState && battleState.opponent) {
    battleState.opponent.invincibleUntil = now + 2000;
  }

  // Cleanup all combat state
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
    combat = null;
  }
  battleState = null;

  if (!player.alive) {
    gameState = 'gameover';
    showGameOver();
  } else {
    gameState = 'playing';
    document.getElementById('dpad-hint').style.display = '';
    document.getElementById('action-zone').style.display = '';
  }
}

function resolveBotBattle(bot1, bot2) {
  // Simple resolution based on fitness levels
  const score1 = (bot1.fitnessLevel || 50) + Math.random() * 40;
  const score2 = (bot2.fitnessLevel || 50) + Math.random() * 40;

  const winner = score1 > score2 ? bot1 : bot2;
  const loser = score1 > score2 ? bot2 : bot1;

  loser.hp -= 1;
  if (loser.hp <= 0) {
    loser.alive = false;
    eliminationOrder.push(loser.name);
  }

  // Invincibility
  const now = Date.now();
  bot1.invincibleUntil = now + 2000;
  bot2.invincibleUntil = now + 2000;

  // Particles at battle site
  for (let i = 0; i < 6; i++) {
    particles.push({
      x: (bot1.x + bot2.x) / 2,
      y: (bot1.y + bot2.y) / 2,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      life: 1,
      color: '#fbbf24',
      size: 3 + Math.random() * 2,
    });
  }

  updateAliveCount();
}

function updateAliveCount() {
  const alive = 1 + bots.filter(b => b.alive).length;
  document.getElementById('alive-count').textContent = alive;
}

// ‚îÄ‚îÄ CAMERA ‚îÄ‚îÄ
function updateCamera() {
  if (!player) return;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  camera.x = player.x - vw / 2;
  camera.y = player.y - vh / 2;
  camera.x = Math.max(0, Math.min(ARENA_W - vw, camera.x));
  camera.y = Math.max(0, Math.min(ARENA_H - vh, camera.y));
}

// ‚îÄ‚îÄ GAME OVER ‚îÄ‚îÄ
function checkGameOver() {
  if (!player || !player.alive) return;
  const aliveCount = bots.filter(b => b.alive).length;
  if (aliveCount === 0) {
    gameState = 'gameover';
    showGameOver();
  }
}

function showGameOver() {
  const overlay = document.getElementById('gameover-overlay');
  overlay.classList.add('active');

  const aliveCount = bots.filter(b => b.alive).length;
  const place = player.alive ? 1 : aliveCount + 2;
  const totalPlayers = playerCount;

  document.getElementById('gameover-place').textContent = `#${place}`;
  document.getElementById('gameover-place').className = `gameover-place ${place === 1 ? 'first' : ''}`;

  const labels = {
    1: 'Victory!',
    2: 'So Close!',
    3: 'Good Fight!',
  };
  document.getElementById('gameover-label').textContent = labels[place] || 'Eliminated';
  document.getElementById('gameover-sub').textContent = place === 1
    ? `You dominated the arena with ${player.kills} knockouts!`
    : `Eliminated in ${place}${place===2?'nd':place===3?'rd':'th'} place`;

  const coinReward = place === 1 ? 50 : place === 2 ? 25 : 10;
  const xpReward = place === 1 ? 25 : place === 2 ? 15 : 5;
  document.getElementById('gameover-coins').textContent = `+${coinReward}`;
  document.getElementById('gameover-xp').textContent = `+${xpReward}`;
}

function returnToLobby() {
  document.getElementById('gameover-overlay').classList.remove('active');
  document.getElementById('lobby').classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('players-alive').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('powerup-active').innerHTML = '';
  gameState = 'lobby';
  player = null;
  bots = [];
  powerups = [];
  particles = [];
}

function exitArena() {
  if (window.history.length > 1) {
    window.history.back();
  } else {
    window.location.href = 'dashboard.html';
  }
}

// ‚îÄ‚îÄ ACTION BUTTON ‚îÄ‚îÄ
function handleAction() {
  if (gameState !== 'playing' || !player || !player.alive) return;

  // Find nearest alive bot
  let nearest = null;
  let nearestDist = Infinity;
  bots.forEach(bot => {
    if (!bot.alive) return;
    const d = dist(player, bot);
    if (d < nearestDist) {
      nearestDist = d;
      nearest = bot;
    }
  });

  if (nearest && nearestDist < 120) {
    showNotification(`${nearest.name} is nearby! Get closer to battle!`);
  } else {
    // Scan - reveal nearest player direction briefly
    if (nearest) {
      const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      const dirs = ['East', 'South', 'West', 'North'];
      const dirIdx = Math.round(((angle + Math.PI) / (Math.PI * 2)) * 4) % 4;
      showNotification(`Nearest fighter: ${Math.round(nearestDist)}m to the ${dirs[dirIdx]}`);
    }
  }
}

// ‚îÄ‚îÄ NOTIFICATIONS ‚îÄ‚îÄ
function showNotification(text) {
  // Remove existing
  document.querySelectorAll('.arena-notification').forEach(n => n.remove());

  const notif = document.createElement('div');
  notif.className = 'arena-notification';
  notif.textContent = text;
  document.body.appendChild(notif);
  setTimeout(() => notif.remove(), 3000);
}

// ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
function render() {
  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

  if (gameState === 'lobby') return;

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  drawArenaBackground();
  drawObstacles();
  drawPowerups();
  drawEntities();
  drawParticles();

  // Mini-map
  ctx.restore();
  drawMinimap();

  // Update action button state
  updateActionButton();
}

function drawArenaBackground() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  // Dark void outside rooms
  ctx.fillStyle = '#080a10';
  ctx.fillRect(vx, vy, vw, vh);

  // Draw room floors
  ROOMS.forEach(rm => {
    // Skip if off-screen
    if (rm.x + rm.w < vx || rm.x > vx + vw || rm.y + rm.h < vy || rm.y > vy + vh) return;

    // Room floor
    ctx.fillStyle = rm.floor;
    ctx.fillRect(rm.x, rm.y, rm.w, rm.h);

    // Floor tiles (checkerboard)
    const sc = Math.max(0, Math.floor((rm.x - vx) / TILE_SIZE));
    const ec = Math.ceil((rm.x + rm.w - vx) / TILE_SIZE);
    const sr = Math.max(0, Math.floor((rm.y - vy) / TILE_SIZE));
    const er = Math.ceil((rm.y + rm.h - vy) / TILE_SIZE);
    for (let r = sr; r <= er; r++) {
      for (let c = sc; c <= ec; c++) {
        const tx = vx + c * TILE_SIZE;
        const ty = vy + r * TILE_SIZE;
        if (tx < rm.x || tx + TILE_SIZE > rm.x + rm.w || ty < rm.y || ty + TILE_SIZE > rm.y + rm.h) continue;
        if ((r + c) % 2 === 0) {
          ctx.fillStyle = 'rgba(255,255,255,0.015)';
          ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    // Room label
    ctx.save();
    ctx.font = '600 14px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.letterSpacing = '3px';
    ctx.fillText(rm.name.toUpperCase(), rm.x + rm.w / 2, rm.y + rm.h / 2);
    ctx.restore();
  });

  // Outer arena border
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 3;
  ctx.strokeRect(20, 20, ARENA_W - 40, ARENA_H - 40);
}

function drawObstacles() {
  MAP_OBSTACLES.forEach(o => {
    // Frustum culling
    if (o.x + o.w < camera.x - 20 || o.x > camera.x + window.innerWidth + 20 ||
        o.y + o.h < camera.y - 20 || o.y > camera.y + window.innerHeight + 20) return;

    if (o.type === 'wall') {
      // Wall rendering
      ctx.fillStyle = '#1e2538';
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 2);
      ctx.fill();

      // Wall top highlight
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(o.x, o.y, o.w, 2);

      // Wall border
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 2);
      ctx.stroke();
    } else {
      // Furniture shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.roundRect(o.x + 3, o.y + 3, o.w, o.h, 8);
      ctx.fill();

      // Furniture body
      const grd = ctx.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
      grd.addColorStop(0, '#2a3450');
      grd.addColorStop(1, '#1e2740');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 8);
      ctx.fill();

      // Furniture border
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 8);
      ctx.stroke();

      // Furniture icon
      if (o.icon) {
        ctx.font = `${Math.min(o.w, o.h) * 0.5}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(o.icon, o.x + o.w / 2, o.y + o.h / 2);
      }

      // Furniture label
      if (o.label) {
        ctx.font = '500 8px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillText(o.label, o.x + o.w / 2, o.y + o.h + 12);
      }
    }
  });
}

function drawPowerups() {
  const time = frameCount / 60;
  powerups.forEach(pu => {
    if (!pu.alive) return;
    if (pu.x < camera.x - 30 || pu.x > camera.x + window.innerWidth + 30 ||
        pu.y < camera.y - 30 || pu.y > camera.y + window.innerHeight + 30) return;

    const bob = Math.sin(time * 3 + pu.bobPhase) * 4;

    // Glow
    ctx.fillStyle = pu.color + '20';
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS + 8, 0, Math.PI * 2);
    ctx.fill();

    // Circle
    ctx.fillStyle = pu.color + '40';
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = pu.color + '80';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Icon
    ctx.font = '16px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pu.icon, pu.x, pu.y + bob);
  });
}

function drawEntities() {
  // Collect all alive entities and sort by Y for depth
  const entities = [];
  if (player && player.alive) entities.push({ ...player, isPlayer: true });
  bots.forEach(b => { if (b.alive) entities.push(b); });
  entities.sort((a, b) => a.y - b.y);

  entities.forEach(e => {
    if (e.x < camera.x - 40 || e.x > camera.x + window.innerWidth + 40 ||
        e.y < camera.y - 50 || e.y > camera.y + window.innerHeight + 50) return;

    const isShielded = hasActivePowerup(e, 'shield');
    const isPowered = hasActivePowerup(e, 'power');

    // Invincibility flash
    if (Date.now() < e.invincibleUntil && Math.floor(Date.now() / 100) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }

    drawBean(ctx, e.x, e.y, e.color, 1, e.facingLeft, e.isPlayer ? '' : e.name, isShielded, isPowered);

    // HP dots above player
    if (e.isPlayer) {
      const dotSpacing = 10;
      const totalWidth = (e.hp - 1) * dotSpacing;
      for (let i = 0; i < e.hp; i++) {
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(e.x - totalWidth / 2 + i * dotSpacing, e.y - 38, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  const mapW = 120;
  const mapH = mapW * (ARENA_H / ARENA_W);
  const padding = 12;
  const mx = window.innerWidth - mapW - padding;
  const my = window.innerHeight - mapH - padding - 60;
  const scale = mapW / ARENA_W;

  // Background
  ctx.fillStyle = 'rgba(10,14,26,0.9)';
  ctx.beginPath();
  ctx.roundRect(mx - 4, my - 4, mapW + 8, mapH + 8, 8);
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(mx - 4, my - 4, mapW + 8, mapH + 8, 8);
  ctx.stroke();

  // Room floors
  ROOMS.forEach(rm => {
    ctx.fillStyle = rm.floor;
    ctx.fillRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
  });

  // Walls + furniture
  MAP_OBSTACLES.forEach(o => {
    ctx.fillStyle = o.type === 'wall' ? 'rgba(255,255,255,0.3)' : 'rgba(100,140,255,0.2)';
    ctx.fillRect(mx + o.x * scale, my + o.y * scale, Math.max(1, o.w * scale), Math.max(1, o.h * scale));
  });

  // Bots
  bots.forEach(b => {
    if (!b.alive) return;
    ctx.fillStyle = b.color.body;
    ctx.beginPath();
    ctx.arc(mx + b.x * scale, my + b.y * scale, 2.5, 0, Math.PI * 2);
    ctx.fill();
  });

  // Player
  if (player && player.alive) {
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(mx + player.x * scale, my + player.y * scale, 3, 0, Math.PI * 2);
    ctx.fill();
    // Player view cone
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.strokeRect(
      mx + camera.x * scale,
      my + camera.y * scale,
      window.innerWidth * scale,
      window.innerHeight * scale
    );
  }
}

function updateActionButton() {
  if (!player || !player.alive) return;
  const btn = document.getElementById('action-btn');
  let nearestDist = Infinity;
  bots.forEach(b => {
    if (!b.alive) return;
    const d = dist(player, b);
    if (d < nearestDist) nearestDist = d;
  });

  if (nearestDist < BATTLE_RANGE + 30) {
    btn.classList.add('battle-ready');
    btn.textContent = 'BATTLE!';
  } else {
    btn.classList.remove('battle-ready');
    btn.textContent = 'SCAN';
  }
}

// ‚îÄ‚îÄ START ‚îÄ‚îÄ
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
