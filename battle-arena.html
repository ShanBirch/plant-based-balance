<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>FitGotchi Arena - Battle Mode</title>
<meta name="description" content="Battle your friends in the FitGotchi Arena! Your fitness powers your fighter.">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet"/>
<link href="manifest.json" rel="manifest"/>
<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.1.0/model-viewer.min.js"></script>
<style>
  :root {
    --arena-bg: #0a0e1a;
    --arena-accent: #10b981;
    --arena-accent-glow: rgba(16, 185, 129, 0.4);
    --arena-secondary: #8b5cf6;
    --arena-danger: #ef4444;
    --arena-warning: #fbbf24;
    --arena-text: #f1f5f9;
    --arena-muted: rgba(255,255,255,0.5);
    --arena-surface: rgba(255,255,255,0.06);
    --arena-border: rgba(255,255,255,0.1);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', sans-serif;
    background: var(--arena-bg);
    color: var(--arena-text);
    overflow: hidden;
    height: 100vh;
    height: 100dvh;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }

  /* â”€â”€ HUD â”€â”€ */
  .arena-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    padding: 12px 16px;
    padding-top: calc(12px + env(safe-area-inset-top, 0px));
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(180deg, rgba(10,14,26,0.95) 0%, transparent 100%);
    pointer-events: none;
  }
  .arena-hud > * { pointer-events: auto; }

  .hud-left { display: flex; align-items: center; gap: 10px; }
  .hud-back {
    width: 36px; height: 36px; border-radius: 50%;
    background: var(--arena-surface); border: 1px solid var(--arena-border);
    color: var(--arena-text); font-size: 1.1rem;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .hud-title {
    font-size: 0.85rem; font-weight: 800;
    color: var(--arena-accent);
    text-shadow: 0 0 20px var(--arena-accent-glow);
    text-transform: uppercase; letter-spacing: 1px;
  }

  .hud-stats {
    display: flex; gap: 8px;
  }
  .hud-stat {
    background: var(--arena-surface);
    border: 1px solid var(--arena-border);
    border-radius: 20px; padding: 5px 12px;
    font-size: 0.75rem; font-weight: 700;
    display: flex; align-items: center; gap: 4px;
  }

  /* â”€â”€ Canvas â”€â”€ */
  #arena-canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
  }

  /* â”€â”€ Virtual Joystick â”€â”€ */
  .joystick-zone {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 50%;
    height: 40%;
    z-index: 50;
    touch-action: none;
  }
  .joystick-base {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.06);
    border: 2px solid rgba(255,255,255,0.15);
    display: none;
    pointer-events: none;
  }
  .joystick-thumb {
    position: absolute;
    width: 50px; height: 50px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(16,185,129,0.6), rgba(16,185,129,0.2));
    border: 2px solid rgba(16,185,129,0.5);
    display: none;
    pointer-events: none;
  }

  /* â”€â”€ Visible D-Pad hint â”€â”€ */
  .dpad-hint {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 110px;
    height: 110px;
    z-index: 45;
    pointer-events: none;
    opacity: 0.35;
    transition: opacity 0.3s;
  }
  .dpad-hint.active {
    opacity: 0.6;
  }
  .dpad-center {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 32px; height: 32px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 1.5px solid rgba(255,255,255,0.25);
  }
  .dpad-arrow {
    position: absolute;
    width: 0; height: 0;
    border: 10px solid transparent;
  }
  .dpad-arrow.up {
    top: 4px; left: 50%;
    transform: translateX(-50%);
    border-bottom: 12px solid rgba(255,255,255,0.35);
    border-top: none;
  }
  .dpad-arrow.down {
    bottom: 4px; left: 50%;
    transform: translateX(-50%);
    border-top: 12px solid rgba(255,255,255,0.35);
    border-bottom: none;
  }
  .dpad-arrow.left {
    left: 4px; top: 50%;
    transform: translateY(-50%);
    border-right: 12px solid rgba(255,255,255,0.35);
    border-left: none;
  }
  .dpad-arrow.right {
    right: 4px; top: 50%;
    transform: translateY(-50%);
    border-left: 12px solid rgba(255,255,255,0.35);
    border-right: none;
  }


  /* â”€â”€ Action Button â”€â”€ */
  .action-zone {
    position: fixed;
    bottom: 30px;
    right: 20px;
    z-index: 50;
  }
  .action-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: 3px solid rgba(255,255,255,0.2);
    color: white;
    font-size: 0.7rem; font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    box-shadow: 0 0 30px var(--arena-accent-glow);
    transition: transform 0.1s, box-shadow 0.2s;
    display: flex; align-items: center; justify-content: center;
  }
  .action-btn:active { transform: scale(0.92); }
  .action-btn.battle-ready {
    background: linear-gradient(135deg, var(--arena-danger), #dc2626);
    box-shadow: 0 0 30px rgba(239,68,68,0.5);
    animation: pulse-battle 1s infinite;
  }
  @keyframes pulse-battle {
    0%,100% { box-shadow: 0 0 20px rgba(239,68,68,0.4); }
    50% { box-shadow: 0 0 40px rgba(239,68,68,0.7); }
  }

  /* â”€â”€ Players Alive Counter â”€â”€ */
  .players-alive {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 0.75rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(10px);
  }

  /* â”€â”€ Battle Overlay â”€â”€ */
  .battle-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    background: rgba(0,0,0,0.95);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .battle-overlay.active {
    display: flex;
    animation: battleIn 0.4s ease;
  }
  @keyframes battleIn {
    0% { opacity: 0; transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
  }

  .battle-vs {
    display: flex;
    align-items: center;
    gap: 30px;
    margin-bottom: 30px;
  }
  .battle-fighter {
    text-align: center;
  }
  .battle-fighter canvas {
    border-radius: 16px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.05);
  }
  .battle-fighter-name {
    margin-top: 8px;
    font-weight: 800;
    font-size: 0.9rem;
  }
  .battle-fighter-stats {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 4px;
  }
  .battle-vs-text {
    font-size: 2.5rem;
    font-weight: 900;
    color: var(--arena-danger);
    text-shadow: 0 0 30px rgba(239,68,68,0.5);
  }

  /* â”€â”€ Battle Combat Zone (stacks viewport + info panel) â”€â”€ */
  .battle-combat-zone {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  /* â”€â”€ Battle Viewport (matches tamagotchi widget: 420px) â”€â”€ */
  .battle-viewport {
    position: relative;
    width: 100%;
    height: 420px;
    min-height: 320px;
    background: #1a1a2e;
    overflow: hidden;
    flex-shrink: 0;
  }

  .battle-viewport .dojo-bg {
    position: absolute;
    inset: 0;
    background: url('./assets/battle_dojo_bg.jpeg') center center / cover no-repeat;
    z-index: 0;
  }
  .battle-viewport .dojo-bg::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.15);
    pointer-events: none;
  }

  .battle-viewport model-viewer {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: -30%;
    z-index: 3;
    --poster-color: transparent;
    background: transparent;
    transform: scale(0.75);
    transform-origin: center center;
  }

  .battle-viewport .battle-overlay-text {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
    background: rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .battle-viewport .battle-overlay-text.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
  }
  .battle-viewport .battle-overlay-text .battle-text {
    color: white;
    font-size: 2.5rem;
    font-weight: 900;
    text-shadow: 0 0 20px rgba(255,0,0,0.8), 0 4px 20px rgba(0,0,0,0.7);
    font-family: 'Inter', sans-serif;
    text-transform: uppercase;
    text-align: center;
    line-height: 1.3;
  }

  /* â”€â”€ HP bars (overlaid on viewport) â”€â”€ */
  .battle-hp-container {
    position: absolute;
    top: 12px;
    left: 12px;
    right: 12px;
    display: none;
    justify-content: space-between;
    z-index: 150;
    pointer-events: none;
  }
  .battle-hp-container.active {
    display: flex;
  }
  .battle-hp-box {
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(6px);
    border-radius: 10px;
    padding: 6px 10px;
    min-width: 120px;
    border: 1px solid rgba(255,255,255,0.15);
  }
  .battle-hp-box.enemy {
    text-align: right;
  }
  .battle-hp-name {
    font-size: 0.6rem;
    font-weight: 700;
    color: rgba(255,255,255,0.8);
    margin-bottom: 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .battle-hp-bar-bg {
    height: 6px;
    background: rgba(255,255,255,0.15);
    border-radius: 6px;
    overflow: hidden;
  }
  .battle-hp-bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.4s ease-out;
  }
  .battle-hp-bar-fill.player {
    background: linear-gradient(90deg, #2ecc71, #4ecdc4);
  }
  .battle-hp-bar-fill.enemy {
    background: linear-gradient(90deg, #e74c3c, #ff6b6b);
  }
  .battle-hp-text {
    font-size: 0.5rem;
    font-weight: 800;
    color: rgba(255,255,255,0.7);
    margin-top: 2px;
    font-family: 'Inter', sans-serif;
  }

  /* â”€â”€ Mana bar (above action buttons, bottom of viewport) â”€â”€ */
  .battle-mana-container {
    position: absolute;
    bottom: 95px;
    left: 12px;
    right: 12px;
    z-index: 150;
    pointer-events: none;
    display: none;
  }
  .battle-mana-container.active {
    display: block;
  }
  .battle-mana-label {
    font-size: 0.5rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
  }
  .battle-mana-bar-bg {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    overflow: hidden;
  }
  .battle-mana-bar-fill {
    height: 100%;
    border-radius: 8px;
    background: linear-gradient(90deg, #3498db, #45b7d1, #9b59b6);
    transition: width 0.2s linear;
    box-shadow: 0 0 8px rgba(52,152,219,0.4);
  }
  .battle-mana-bar-fill.full {
    animation: manaReady 0.5s ease-in-out infinite alternate;
  }
  @keyframes manaReady {
    0% { box-shadow: 0 0 8px rgba(52,152,219,0.4); }
    100% { box-shadow: 0 0 20px rgba(155,89,182,0.8); }
  }

  /* â”€â”€ Info Panel (below viewport) â”€â”€ */
  .battle-info-panel {
    flex: 1;
    width: 100%;
    padding: 16px 20px;
    overflow-y: auto;
    background: linear-gradient(180deg, #0d1117 0%, #0a0e1a 100%);
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .battle-info-title {
    text-align: center;
    font-size: 0.65rem;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--arena-accent);
    margin-bottom: 12px;
    opacity: 0.8;
  }
  .battle-info-opponent {
    display: flex;
    align-items: center;
    gap: 14px;
    background: rgba(255,255,255,0.04);
    border-radius: 14px;
    padding: 12px 16px;
    border: 1px solid rgba(255,255,255,0.06);
    margin-bottom: 12px;
  }
  .battle-info-opponent canvas {
    border-radius: 10px;
    background: rgba(255,255,255,0.03);
    flex-shrink: 0;
  }
  .battle-info-opponent-details {
    flex: 1;
    min-width: 0;
  }
  .battle-info-opponent-name {
    font-size: 1rem;
    font-weight: 800;
    color: white;
    margin-bottom: 2px;
  }
  .battle-info-opponent-level {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--arena-muted);
    margin-bottom: 6px;
  }
  .battle-info-stat-row {
    display: flex;
    gap: 12px;
  }
  .battle-info-stat {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.65rem;
    font-weight: 700;
    color: rgba(255,255,255,0.5);
  }
  .battle-info-stat span:first-child {
    color: rgba(255,255,255,0.3);
  }
  .battle-info-stat-val {
    color: rgba(255,255,255,0.8) !important;
  }

  .battle-info-round-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 0;
  }
  .battle-round-info {
    font-size: 0.75rem;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
  }
  .battle-round-score {
    display: inline-flex;
    gap: 6px;
    font-size: 0.85rem;
    font-weight: 900;
    margin-left: 8px;
  }
  .round-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: inline-block;
  }
  .round-dot.player-win { background: #2ecc71; }
  .round-dot.enemy-win { background: #ff4444; }

  .battle-timer {
    font-size: 1.6rem;
    font-weight: 900;
    color: var(--arena-warning);
    font-family: 'Inter', monospace;
  }

  /* â”€â”€ Action buttons (overlaid at bottom-right, dashboard style) â”€â”€ */
  .battle-action-container {
    position: absolute;
    bottom: 12px;
    right: 12px;
    z-index: 200;
    display: none;
    pointer-events: none;
  }
  .battle-action-container.active {
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: auto;
  }

  .battle-bash-btn {
    width: 80px;
    height: 80px;
    border: none;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff6b4a, #e63946);
    color: white;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    box-shadow: 0 4px 20px rgba(230,57,70,0.5), inset 0 2px 4px rgba(255,255,255,0.2);
    transition: transform 0.05s;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-bash-btn:active {
    transform: scale(0.88);
    box-shadow: 0 2px 10px rgba(230,57,70,0.7), inset 0 2px 4px rgba(0,0,0,0.2);
  }
  .battle-bash-btn .bash-icon { font-size: 1.5rem; line-height: 1; }
  .battle-bash-btn .bash-label { font-size: 0.55rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }

  .battle-bash-btn .bash-progress-ring {
    position: absolute;
    inset: -4px;
    pointer-events: none;
  }
  .battle-bash-btn .bash-progress-ring svg {
    width: 100%;
    height: 100%;
  }
  .bash-ring-bg {
    fill: none;
    stroke: rgba(255,255,255,0.15);
    stroke-width: 3;
  }
  .bash-ring-fill {
    fill: none;
    stroke: #FFD700;
    stroke-width: 3;
    stroke-dasharray: 163.36;
    stroke-dashoffset: 163.36;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.1s;
    transform: rotate(-90deg);
    transform-origin: center;
  }

  .battle-bash-btn.attack-ready {
    animation: bashReady 0.3s ease-in-out infinite alternate;
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff8c00);
  }
  @keyframes bashReady {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.5); transform: scale(1); }
    100% { box-shadow: 0 0 30px rgba(255,215,0,0.9); transform: scale(1.05); }
  }

  .battle-action-btn {
    width: 64px;
    height: 64px;
    border: none;
    border-radius: 50%;
    color: white;
    cursor: pointer;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    position: relative;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    touch-action: manipulation;
  }
  .battle-action-btn.visible {
    display: flex;
    animation: actionBtnAppear 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  .battle-action-btn .action-btn-icon { font-size: 1.3rem; line-height: 1; }
  .battle-action-btn .action-btn-label { font-size: 0.5rem; font-weight: 900; letter-spacing: 1px; text-transform: uppercase; }
  .battle-action-btn:active { transform: scale(0.85); }

  .battle-fire-btn {
    background: radial-gradient(circle at 30% 30%, #FFD700, #ff6b00);
    box-shadow: 0 0 20px rgba(255,215,0,0.7), 0 0 40px rgba(255,107,0,0.4);
    animation: firePulse 0.5s ease-in-out infinite alternate;
  }
  @keyframes firePulse {
    0% { box-shadow: 0 0 15px rgba(255,215,0,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(255,215,0,0.9); transform: scale(1.08); }
  }

  .battle-block-btn {
    background: radial-gradient(circle at 30% 30%, #60a5fa, #2563eb);
    box-shadow: 0 0 20px rgba(96,165,250,0.7), 0 0 40px rgba(37,99,235,0.4);
    animation: blockPulse 0.4s ease-in-out infinite alternate;
  }
  @keyframes blockPulse {
    0% { box-shadow: 0 0 15px rgba(96,165,250,0.6); transform: scale(1); }
    100% { box-shadow: 0 0 25px rgba(96,165,250,0.9); transform: scale(1.08); }
  }

  @keyframes actionBtnAppear {
    0% { transform: scale(0) rotate(-20deg); opacity: 0; }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
  }

  /* â”€â”€ Fireball projectile â”€â”€ */
  .fireball {
    position: absolute;
    pointer-events: none;
    z-index: 100;
    will-change: transform;
  }
  .fireball img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: auto;
  }

  /* â”€â”€ Hit flash â”€â”€ */
  .battle-hit-flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 210;
    animation: hitFlash 0.3s ease-out forwards;
  }
  @keyframes hitFlash {
    0% { background: rgba(255,68,68,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.blocked { animation-name: blockFlash; }
  @keyframes blockFlash {
    0% { background: rgba(59,130,246,0.3); }
    100% { background: transparent; }
  }
  .battle-hit-flash.super-hit { animation-name: superFlash; }
  @keyframes superFlash {
    0% { background: rgba(251,191,36,0.4); }
    100% { background: transparent; }
  }

  /* â”€â”€ Screen shake â”€â”€ */
  @keyframes battleShake {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-4px, 2px); }
    40% { transform: translate(4px, -2px); }
    60% { transform: translate(-2px, 4px); }
    80% { transform: translate(2px, -4px); }
  }
  .battle-shake { animation: battleShake 0.3s ease; }

  @keyframes roundTextPop {
    0% { transform: scale(0.3); opacity: 0; }
    60% { transform: scale(1.15); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  /* â”€â”€ Battle Result â”€â”€ */
  .battle-result {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }
  .battle-result.active { display: flex; }
  .battle-result-text {
    font-size: 2rem;
    font-weight: 900;
    text-transform: uppercase;
  }
  .battle-result-text.win { color: var(--arena-accent); text-shadow: 0 0 30px var(--arena-accent-glow); }
  .battle-result-text.lose { color: var(--arena-danger); }
  .battle-reward {
    font-size: 0.85rem;
    color: var(--arena-warning);
    font-weight: 700;
  }
  .battle-continue-btn {
    margin-top: 10px;
    padding: 12px 40px;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
  }

  /* â”€â”€ Lobby / Start Screen â”€â”€ */
  .lobby-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: linear-gradient(135deg, #0a0e1a 0%, #1a0e2e 50%, #0e1a2e 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top, 0px));
  }
  .lobby-overlay.hidden { display: none; }

  .lobby-title {
    font-size: 2.2rem;
    font-weight: 900;
    background: linear-gradient(135deg, var(--arena-accent), var(--arena-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }
  .lobby-subtitle {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 40px;
    max-width: 300px;
  }

  .lobby-avatar-preview {
    margin-bottom: 30px;
  }
  .lobby-avatar-preview canvas {
    border-radius: 20px;
    border: 3px solid var(--arena-border);
    background: rgba(255,255,255,0.03);
  }

  .lobby-customize {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 30px;
    max-width: 340px;
  }
  .lobby-color-btn {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: transform 0.15s, border-color 0.15s;
  }
  .lobby-color-btn:hover { transform: scale(1.15); }
  .lobby-color-btn.selected { border-color: white; transform: scale(1.15); }

  .lobby-start-btn {
    padding: 16px 50px;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--arena-accent), #059669);
    border: none;
    color: white;
    font-size: 1.1rem;
    font-weight: 800;
    cursor: pointer;
    box-shadow: 0 4px 30px var(--arena-accent-glow);
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: transform 0.15s;
  }
  .lobby-start-btn:active { transform: scale(0.95); }

  .lobby-mode-select {
    display: flex;
    gap: 10px;
    margin-bottom: 24px;
  }
  .lobby-mode-btn {
    padding: 10px 20px;
    border-radius: 12px;
    border: 2px solid var(--arena-border);
    background: var(--arena-surface);
    color: var(--arena-text);
    font-size: 0.8rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
  }
  .lobby-mode-btn.selected {
    border-color: var(--arena-accent);
    background: rgba(16,185,129,0.15);
    color: var(--arena-accent);
  }

  /* â”€â”€ Game Over â”€â”€ */
  .gameover-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: rgba(0,0,0,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding-top: env(safe-area-inset-top, 0px);
  }
  .gameover-overlay.active { display: flex; animation: battleIn 0.5s ease; }
  .gameover-place {
    font-size: 4rem;
    font-weight: 900;
    margin-bottom: 8px;
  }
  .gameover-place.first {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .gameover-label {
    font-size: 1.3rem;
    font-weight: 800;
    color: var(--arena-text);
    margin-bottom: 4px;
  }
  .gameover-sub {
    font-size: 0.85rem;
    color: var(--arena-muted);
    margin-bottom: 30px;
  }
  .gameover-rewards {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  .gameover-reward {
    text-align: center;
  }
  .gameover-reward-val {
    font-size: 1.5rem;
    font-weight: 900;
    color: var(--arena-warning);
  }
  .gameover-reward-label {
    font-size: 0.7rem;
    color: var(--arena-muted);
    margin-top: 2px;
  }

  /* â”€â”€ Notifications â”€â”€ */
  .arena-notification {
    position: fixed;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 150;
    background: rgba(10,14,26,0.9);
    border: 1px solid var(--arena-accent);
    border-radius: 12px;
    padding: 10px 20px;
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--arena-accent);
    backdrop-filter: blur(10px);
    animation: notifIn 0.3s ease, notifOut 0.3s ease 2.5s forwards;
    white-space: nowrap;
  }
  @keyframes notifIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
  @keyframes notifOut { to { opacity: 0; transform: translateX(-50%) translateY(-10px); } }

  /* â”€â”€ Powerup indicator â”€â”€ */
  .powerup-active {
    position: fixed;
    bottom: 120px;
    right: 20px;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .powerup-badge {
    background: rgba(10,14,26,0.85);
    border: 1px solid var(--arena-border);
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 0.7rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 5px;
    animation: notifIn 0.3s ease;
  }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOBBY SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="lobby-overlay" id="lobby">
  <div class="lobby-title">FitGotchi Arena</div>
  <div class="lobby-subtitle">Your fitness powers your fighter. Battle your way to the top!</div>

  <div class="lobby-avatar-preview">
    <canvas id="lobby-avatar" width="140" height="160"></canvas>
  </div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Choose Your Color</div>
  <div class="lobby-customize" id="color-picker"></div>

  <div style="font-size:0.7rem;font-weight:700;color:var(--arena-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;">Arena Size</div>
  <div class="lobby-mode-select">
    <button class="lobby-mode-btn selected" onclick="selectMode(this,4)">4 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,6)">6 Players</button>
    <button class="lobby-mode-btn" onclick="selectMode(this,8)">8 Players</button>
  </div>

  <button class="lobby-start-btn" onclick="startGame()">Enter Arena</button>
  <div style="margin-top:12px;font-size:0.65rem;color:var(--arena-muted);">WASD / Arrow keys or touch joystick to move</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME CANVAS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<canvas id="arena-canvas"></canvas>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HUD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="arena-hud" id="hud" style="display:none;">
  <div class="hud-left">
    <button class="hud-back" onclick="exitArena()">&#8249;</button>
    <div class="hud-title">FitGotchi Arena</div>
  </div>
  <div class="hud-stats">
    <div class="hud-stat"><span>&#9876;</span> <span id="hud-kills">0</span></div>
    <div class="hud-stat"><span>&#9829;</span> <span id="hud-hp">3</span></div>
  </div>
</div>

<div class="players-alive" id="players-alive" style="display:none;">
  <span style="color:var(--arena-accent);">&#9679;</span>
  <span id="alive-count">8</span> alive
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VIRTUAL JOYSTICK â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="joystick-zone" id="joystick-zone">
  <div class="joystick-base" id="joystick-base"></div>
  <div class="joystick-thumb" id="joystick-thumb"></div>
</div>
<div class="dpad-hint" id="dpad-hint" style="display:none;">
  <div class="dpad-center"></div>
  <div class="dpad-arrow up"></div>
  <div class="dpad-arrow down"></div>
  <div class="dpad-arrow left"></div>
  <div class="dpad-arrow right"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTION BUTTON â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="action-zone" id="action-zone" style="display:none;">
  <button class="action-btn" id="action-btn" onclick="handleAction()">SCAN</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTIVE POWERUPS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="powerup-active" id="powerup-active"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BATTLE OVERLAY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="battle-overlay" id="battle-overlay">
  <div class="battle-vs" id="battle-vs"></div>
  <div class="battle-combat-zone" id="battle-combat-zone" style="display:none;">
    <!-- Battle Viewport (same as tamagotchi) -->
    <div class="battle-viewport" id="battle-viewport">
      <div class="dojo-bg"></div>
      <model-viewer
        id="arena-battle-model"
        camera-orbit="0deg 85deg 22m"
        field-of-view="55deg"
        min-field-of-view="20deg"
        max-field-of-view="120deg"
        shadow-intensity="1.5"
        shadow-softness="0.8"
        exposure="0.9"
        environment-image="neutral"
        interaction-prompt="none"
        disable-zoom
        disable-pan
        loading="eager"
        style="background: transparent;">
      </model-viewer>
      <!-- HP bars overlaid -->
      <div id="bc-hp-container" class="battle-hp-container">
        <div class="battle-hp-box player">
          <div class="battle-hp-name">YOU</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-player" class="battle-hp-bar-fill player" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-player-text" class="battle-hp-text">100 / 100</div>
        </div>
        <div class="battle-hp-box enemy">
          <div class="battle-hp-name" id="bc-enemy-name">OPPONENT</div>
          <div class="battle-hp-bar-bg">
            <div id="bc-hp-enemy" class="battle-hp-bar-fill enemy" style="width: 100%;"></div>
          </div>
          <div id="bc-hp-enemy-text" class="battle-hp-text">100 / 100</div>
        </div>
      </div>
      <!-- Battle text overlay -->
      <div class="battle-overlay-text" id="bc-overlay-text">
        <div class="battle-text" id="bc-text-inner">BATTLE!</div>
      </div>
      <!-- Mana bar (above action buttons) -->
      <div id="bc-mana-container" class="battle-mana-container">
        <div class="battle-mana-label">SPECIAL <span id="bc-mana-pct">0%</span></div>
        <div class="battle-mana-bar-bg">
          <div id="bc-mana-fill" class="battle-mana-bar-fill" style="width: 0%;"></div>
        </div>
      </div>
      <!-- Action buttons (overlaid at bottom-right) -->
      <div id="bc-action-container" class="battle-action-container">
        <button id="bc-block-btn" class="battle-action-btn battle-block-btn" ontouchstart="combatBlock(event)" onmousedown="combatBlock(event)">
          <span class="action-btn-icon">ğŸ›¡ï¸</span>
          <span class="action-btn-label">BLOCK</span>
        </button>
        <button id="bc-bash-btn" class="battle-bash-btn" ontouchstart="combatBash(event)" onmousedown="combatBash(event)">
          <span class="bash-icon">ğŸ‘Š</span>
          <span class="bash-label">BASH!</span>
          <div class="bash-progress-ring">
            <svg viewBox="0 0 60 60">
              <circle cx="30" cy="30" r="26" class="bash-ring-bg"/>
              <circle cx="30" cy="30" r="26" class="bash-ring-fill" id="bash-ring-fill"/>
            </svg>
          </div>
        </button>
        <button id="bc-fire-btn" class="battle-action-btn battle-fire-btn" ontouchstart="combatFire(event)" onmousedown="combatFire(event)">
          <span class="action-btn-icon">ğŸ”¥</span>
          <span class="action-btn-label">FIRE!</span>
        </button>
      </div>
    </div>
    <!-- Info Panel (below viewport) -->
    <div class="battle-info-panel" id="battle-info-panel">
      <div class="battle-info-title">Arena Battle Mode</div>
      <div class="battle-info-opponent" id="battle-info-opponent">
        <canvas id="battle-info-avatar" width="56" height="64"></canvas>
        <div class="battle-info-opponent-details">
          <div class="battle-info-opponent-name" id="bc-info-name">Opponent</div>
          <div class="battle-info-opponent-level" id="bc-info-level">Level ??</div>
          <div class="battle-info-stat-row" id="bc-info-stats">
            <div class="battle-info-stat"><span>STR</span> <span class="battle-info-stat-val" id="bc-info-str">?</span></div>
            <div class="battle-info-stat"><span>HP</span> <span class="battle-info-stat-val" id="bc-info-hp">?</span></div>
            <div class="battle-info-stat"><span>DEF</span> <span class="battle-info-stat-val" id="bc-info-def">?</span></div>
          </div>
        </div>
      </div>
      <div class="battle-info-round-row">
        <div class="battle-round-info">
          ROUND <span id="bc-round">1</span> / 3
          <span class="battle-round-score" id="bc-round-dots">
            <span class="round-dot" id="rd1"></span>
            <span class="round-dot" id="rd2"></span>
            <span class="round-dot" id="rd3"></span>
          </span>
        </div>
        <div class="battle-timer" id="bc-timer">30</div>
      </div>
    </div>
  </div>
  <div class="battle-result" id="battle-result"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME OVER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="gameover-overlay" id="gameover-overlay">
  <div class="gameover-place first" id="gameover-place">#1</div>
  <div class="gameover-label" id="gameover-label">Victory!</div>
  <div class="gameover-sub" id="gameover-sub">You outlasted everyone in the arena</div>
  <div class="gameover-rewards">
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-coins">+50</div>
      <div class="gameover-reward-label">Coins</div>
    </div>
    <div class="gameover-reward">
      <div class="gameover-reward-val" id="gameover-xp">+25</div>
      <div class="gameover-reward-label">XP</div>
    </div>
  </div>
  <button class="lobby-start-btn" onclick="returnToLobby()">Play Again</button>
  <button style="margin-top:10px;padding:10px 30px;border-radius:10px;background:var(--arena-surface);border:1px solid var(--arena-border);color:var(--arena-text);font-size:0.85rem;font-weight:600;cursor:pointer;" onclick="exitArena()">Exit</button>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FITGOTCHI ARENA - Battle Mode Proof of Concept
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ CONFIG â”€â”€
const ARENA_W = 4000;
const ARENA_H = 3000;
const TILE_SIZE = 60;
const PLAYER_RADIUS = 18;
const PLAYER_SPEED = 3;
const BOT_SPEED = 1.6;
const BATTLE_RANGE = 44;
const POWERUP_RADIUS = 14;

const BEAN_COLORS = [
  { name: 'Emerald',  body: '#10b981', dark: '#059669', visor: '#a7f3d0' },
  { name: 'Violet',   body: '#8b5cf6', dark: '#7c3aed', visor: '#c4b5fd' },
  { name: 'Coral',    body: '#ef4444', dark: '#dc2626', visor: '#fca5a5' },
  { name: 'Ocean',    body: '#3b82f6', dark: '#2563eb', visor: '#93c5fd' },
  { name: 'Amber',    body: '#f59e0b', dark: '#d97706', visor: '#fde68a' },
  { name: 'Rose',     body: '#ec4899', dark: '#db2777', visor: '#f9a8d4' },
  { name: 'Cyan',     body: '#06b6d4', dark: '#0891b2', visor: '#a5f3fc' },
  { name: 'Lime',     body: '#84cc16', dark: '#65a30d', visor: '#d9f99d' },
  { name: 'Slate',    body: '#64748b', dark: '#475569', visor: '#cbd5e1' },
  { name: 'White',    body: '#e2e8f0', dark: '#cbd5e1', visor: '#f8fafc' },
];

const POWERUP_TYPES = [
  { type: 'protein', icon: 'ğŸ¥¤', label: 'Protein Shake', effect: 'speed', duration: 6000, color: '#a78bfa' },
  { type: 'broccoli', icon: 'ğŸ¥¦', label: 'Shield Up', effect: 'shield', duration: 8000, color: '#10b981' },
  { type: 'dumbbell', icon: 'ğŸ‹ï¸', label: 'Power Up', effect: 'power', duration: 5000, color: '#ef4444' },
  { type: 'apple', icon: 'ğŸ', label: 'Heal', effect: 'heal', duration: 0, color: '#f59e0b' },
];

// Map obstacle tiles (1 = wall, 2 = table/equipment)
const MAP_OBSTACLES = [];

// â”€â”€ STATE â”€â”€
let canvas, ctx;
let gameState = 'lobby'; // lobby | playing | battle | gameover
let playerCount = 4;
let selectedColorIdx = 0;
let camera = { x: 0, y: 0 };
let player = null;
let bots = [];
let powerups = [];
let particles = [];
let battleState = null;
let inputDir = { x: 0, y: 0 };
let keys = {};
let joystickActive = false;
let joystickOrigin = { x: 0, y: 0 };
let frameCount = 0;
let lastTime = 0;
let eliminationOrder = [];

// Simulated fitness stats (would come from Supabase in prod)
// In production these are loaded from localStorage.battleStats + users table
let fitnessStats = {
  fitnessLevel: 65,
  energyLevel: 72,
  weeklyWorkoutCount: 4,
  level: 23,
  title: 'Growing',
  // Battle stats (STR/HP/MANA) - from the dashboard stat allocation system
  str: 15,   // Increases attack damage
  hp: 12,    // Increases max health pool (100 + hp*5)
  mana: 8,   // Reduces taps needed for special (max(10, 30 - mana/5))
};

// â”€â”€ INIT â”€â”€
function init() {
  canvas = document.getElementById('arena-canvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Read query params from dashboard launch
  const params = new URLSearchParams(window.location.search);
  if (params.get('players')) {
    playerCount = parseInt(params.get('players')) || 4;
    // Update lobby mode buttons
    document.querySelectorAll('.lobby-mode-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.textContent.trim() === playerCount + ' Players') btn.classList.add('selected');
    });
  }

  // Input
  window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.key] = false; });
  setupJoystick();

  // Color picker
  buildColorPicker();
  drawLobbyAvatar();

  // Generate map obstacles
  generateMap();

  // Start loop
  requestAnimationFrame(gameLoop);
}

function resizeCanvas() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

// â”€â”€ ROOM DEFINITIONS â”€â”€
const WALL = 16;
const DOOR = 100; // doorway gap size
const ROOMS = [
  { name: 'Kitchen',     x: 40,   y: 40,   w: 1200, h: 940,  floor: '#1a1f14', accent: '#2d4a1e', wallColor: '#2a3d1e', wallHighlight: '#3a5530', floorType: 'checker-tile', tileColor1: '#1e2818', tileColor2: '#242e1c', trimColor: '#4a6a35' },
  { name: 'Cafeteria',   x: 1300, y: 40,   w: 1400, h: 940,  floor: '#1a1420', accent: '#3d1e4a', wallColor: '#2e1a3a', wallHighlight: '#42284e', floorType: 'linoleum', tileColor1: '#1e1628', tileColor2: '#221a2c', trimColor: '#6a3a8a' },
  { name: 'Living Room', x: 2760, y: 40,   w: 1200, h: 940,  floor: '#1a1a28', accent: '#1e2d4a', wallColor: '#1e2540', wallHighlight: '#283558', floorType: 'wood', tileColor1: '#1e1e30', tileColor2: '#222238', trimColor: '#3a5088' },
  { name: 'Bathroom',    x: 40,   y: 1040, w: 900,  h: 920,  floor: '#141a1a', accent: '#1e3a4a', wallColor: '#1a2e35', wallHighlight: '#244048', floorType: 'small-tile', tileColor1: '#182224', tileColor2: '#1c2628', trimColor: '#2a5a6a' },
  { name: 'Hallway',     x: 1000, y: 1040, w: 2000, h: 920,  floor: '#18181f', accent: '#333340', wallColor: '#252530', wallHighlight: '#353545', floorType: 'metal', tileColor1: '#1a1a24', tileColor2: '#1e1e28', trimColor: '#555568' },
  { name: 'Bedroom',     x: 3060, y: 1040, w: 900,  h: 920,  floor: '#201a1a', accent: '#4a1e2d', wallColor: '#381a28', wallHighlight: '#4c2838', floorType: 'carpet', tileColor1: '#241c1c', tileColor2: '#281e1e', trimColor: '#7a3050' },
  { name: 'Gym',         x: 40,   y: 2020, w: 1200, h: 940,  floor: '#1f1a14', accent: '#4a3a1e', wallColor: '#352a18', wallHighlight: '#4a3a24', floorType: 'rubber', tileColor1: '#221c14', tileColor2: '#282018', trimColor: '#7a5a2a' },
  { name: 'Garden',      x: 1300, y: 2020, w: 1400, h: 940,  floor: '#142014', accent: '#1e4a28', wallColor: '#1a3018', wallHighlight: '#264524', floorType: 'grass', tileColor1: '#162216', tileColor2: '#1a2a1a', trimColor: '#3a7a40' },
  { name: 'Garage',      x: 2760, y: 2020, w: 1200, h: 940,  floor: '#1a1a1a', accent: '#3a3a3a', wallColor: '#282828', wallHighlight: '#383838', floorType: 'concrete', tileColor1: '#1e1e1e', tileColor2: '#222222', trimColor: '#555555' },
];

// â”€â”€ NON-COLLISION FLOOR DECORATIONS â”€â”€
const FLOOR_DECORATIONS = [];

// â”€â”€ MAP GENERATION â”€â”€
function generateMap() {
  MAP_OBSTACLES.length = 0;

  // Helper: add a wall segment
  function wall(x, y, w, h) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'wall' });
  }
  // Helper: add furniture
  function furniture(x, y, w, h, icon, label) {
    MAP_OBSTACLES.push({ x, y, w, h, type: 'furniture', icon, label });
  }

  // â”€â”€â”€ ROOM WALLS (with doorways) â”€â”€â”€

  // Kitchen walls
  wall(40, 40, 1200, WALL);              // top
  wall(40, 40, WALL, 940);               // left
  wall(40, 980 - WALL, 500, WALL);       // bottom-left
  wall(500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(1240 - WALL, 40, WALL, 400);      // right-top
  wall(1240 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Cafeteria walls
  wall(1300, 40, 1400, WALL);            // top
  wall(1300, 980 - WALL, 600, WALL);     // bottom-left
  wall(1300 + 600 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right
  wall(2700 - WALL, 40, WALL, 400);      // right-top
  wall(2700 - WALL, 400 + DOOR, WALL, 540 - DOOR); // right-bottom

  // Living Room walls
  wall(2760, 40, 1200, WALL);            // top
  wall(3960 - WALL, 40, WALL, 940);      // right
  wall(2760, 980 - WALL, 500, WALL);     // bottom-left
  wall(2760 + 500 + DOOR, 980 - WALL, 700 - DOOR, WALL); // bottom-right

  // Bathroom walls
  wall(40, 1040, WALL, 920);             // left
  wall(40, 1040, 900, WALL);             // top (shared)
  wall(40, 1960 - WALL, 400, WALL);      // bottom-left
  wall(400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right
  wall(940 - WALL, 1040, WALL, 400);     // right-top
  wall(940 - WALL, 1040 + 400 + DOOR, WALL, 520 - DOOR - WALL); // right-bottom

  // Hallway (open area, just top/bottom walls with doorways)
  wall(1000, 1040, 800, WALL);           // top-left section
  wall(1000 + 800 + DOOR, 1040, 1100 - DOOR, WALL); // top-right section
  wall(1000, 1960 - WALL, 700, WALL);    // bottom-left
  wall(1000 + 700 + DOOR, 1960 - WALL, 1200 - DOOR, WALL); // bottom-right

  // Bedroom walls
  wall(3060, 1040, 900, WALL);           // top
  wall(3960 - WALL, 1040, WALL, 920);    // right
  wall(3060, 1960 - WALL, 400, WALL);    // bottom-left
  wall(3060 + 400 + DOOR, 1960 - WALL, 500 - DOOR, WALL); // bottom-right

  // Gym walls
  wall(40, 2020, WALL, 940);             // left
  wall(40, 2020, 1200, WALL);            // top
  wall(40, 2960 - WALL, 1200, WALL);     // bottom
  wall(1240 - WALL, 2020, WALL, 400);    // right-top
  wall(1240 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garden walls
  wall(1300, 2020, 600, WALL);           // top-left
  wall(1300 + 600 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(1300, 2960 - WALL, 1400, WALL);   // bottom
  wall(2700 - WALL, 2020, WALL, 400);    // right-top
  wall(2700 - WALL, 2020 + 400 + DOOR, WALL, 540 - DOOR - WALL); // right-bottom

  // Garage walls
  wall(2760, 2020, 500, WALL);           // top-left
  wall(2760 + 500 + DOOR, 2020, 700 - DOOR, WALL); // top-right
  wall(3960 - WALL, 2020, WALL, 940);    // right
  wall(2760, 2960 - WALL, 1200, WALL);   // bottom

  // â”€â”€â”€ FURNITURE â”€â”€â”€

  // Kitchen (much more detailed)
  furniture(100, 100, 200, 60, 'ğŸ³', 'Stove');
  furniture(100, 200, 70, 140, 'ğŸ§Š', 'Fridge');
  furniture(350, 100, 300, 50, 'ğŸ”ª', 'Counter');
  furniture(750, 100, 120, 50, 'ğŸ½ï¸', 'Sink');
  furniture(950, 100, 100, 50, 'ğŸ”ª', 'Counter');
  furniture(500, 480, 200, 110, 'ğŸª‘', 'Table');
  furniture(900, 400, 80, 80, 'ğŸ—‘ï¸', 'Bin');
  furniture(100, 400, 100, 60, 'ğŸ§Š', 'Dishwasher');
  furniture(250, 100, 80, 50, 'ğŸ½ï¸', 'Microwave');
  furniture(100, 700, 60, 80, 'ğŸ“‹', 'Pantry');
  furniture(800, 700, 120, 50, 'ğŸ”ª', 'Counter');
  furniture(400, 750, 100, 60, 'ğŸ“‹', 'Spice Rack');
  furniture(700, 300, 80, 60, 'ğŸ§¹', 'Mop Bucket');

  // Cafeteria (more tables, food service area)
  furniture(1450, 180, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 180, 200, 80, 'ğŸª‘', 'Table');
  furniture(1450, 450, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 450, 200, 80, 'ğŸª‘', 'Table');
  furniture(2050, 300, 200, 80, 'ğŸª‘', 'Table');
  furniture(1450, 720, 200, 80, 'ğŸª‘', 'Table');
  furniture(1750, 720, 200, 80, 'ğŸª‘', 'Table');
  furniture(2350, 150, 80, 200, 'ğŸ¥¤', 'Vending');
  furniture(2500, 150, 80, 200, 'ğŸ¥¤', 'Vending');
  furniture(2050, 100, 200, 50, 'ğŸ½ï¸', 'Food Counter');
  furniture(2350, 600, 100, 60, 'ğŸ—‘ï¸', 'Bin');
  furniture(1350, 100, 80, 50, 'ğŸ“‹', 'Menu Board');
  furniture(2100, 700, 80, 80, 'ğŸ§¹', 'Mop Bucket');
  furniture(2500, 700, 60, 60, 'ğŸ’¡', 'Lamp');

  // Living Room (cozy, full of stuff)
  furniture(2900, 180, 300, 70, 'ğŸ›‹ï¸', 'Couch');
  furniture(3350, 80, 140, 100, 'ğŸ“º', 'TV');
  furniture(2880, 480, 130, 70, 'ğŸª‘', 'Armchair');
  furniture(3100, 420, 120, 70, 'â˜•', 'Coffee Table');
  furniture(3550, 480, 80, 140, 'ğŸ“š', 'Bookshelf');
  furniture(3700, 180, 60, 60, 'ğŸª´', 'Plant');
  furniture(3550, 80, 80, 60, 'ğŸ”Š', 'Speaker');
  furniture(2830, 80, 50, 50, 'ğŸ’¡', 'Lamp');
  furniture(3300, 500, 100, 60, 'ğŸª‘', 'Armchair');
  furniture(3100, 700, 180, 100, 'ğŸ“‹', 'Rug Display');
  furniture(2900, 700, 80, 60, 'ğŸ“‹', 'Side Table');
  furniture(3700, 400, 60, 60, 'ğŸª´', 'Plant');
  furniture(3680, 700, 80, 80, 'ğŸ“¦', 'Storage Ottoman');

  // Bathroom (more fixtures)
  furniture(100, 1120, 120, 100, 'ğŸš¿', 'Shower');
  furniture(100, 1380, 80, 60, 'ğŸª¥', 'Sink');
  furniture(350, 1120, 60, 60, 'ğŸš½', 'Toilet');
  furniture(570, 1100, 140, 70, 'ğŸ›', 'Bathtub');
  furniture(570, 1600, 70, 70, 'ğŸ§º', 'Laundry');
  furniture(350, 1300, 60, 60, 'ğŸ§»', 'Toilet Paper');
  furniture(100, 1550, 70, 100, 'ğŸ“‹', 'Medicine Cabinet');
  furniture(250, 1700, 80, 60, 'ğŸ§¹', 'Mop Bucket');
  furniture(700, 1350, 60, 60, 'ğŸª', 'Mirror');
  furniture(500, 1700, 70, 70, 'ğŸ§º', 'Laundry');
  furniture(350, 1500, 50, 50, 'ğŸ§¹', 'Plunger');

  // Hallway (industrial feel, signs, vents, panels)
  furniture(1150, 1180, 60, 60, 'ğŸª´', 'Plant');
  furniture(1700, 1320, 120, 50, 'ğŸ–¼ï¸', 'Bench');
  furniture(2350, 1180, 60, 60, 'ğŸª´', 'Plant');
  furniture(1450, 1580, 80, 80, 'ğŸ—„ï¸', 'Cabinet');
  furniture(2000, 1130, 60, 60, 'ğŸ’¡', 'Lamp');
  furniture(1300, 1600, 60, 60, 'ğŸ“‹', 'Fire Extinguisher');
  furniture(2600, 1600, 80, 60, 'ğŸ“‹', 'Wall Panel');
  furniture(1900, 1600, 60, 60, 'ğŸ—‘ï¸', 'Bin');
  furniture(2700, 1300, 80, 60, 'ğŸ“‹', 'Control Panel');
  furniture(1600, 1180, 70, 50, 'ğŸ“‹', 'Sign Post');
  furniture(2200, 1580, 60, 60, 'ğŸ’¡', 'Lamp');
  furniture(1100, 1450, 60, 60, 'ğŸ“‹', 'Emergency Light');
  furniture(2800, 1450, 60, 60, 'ğŸ“‹', 'Emergency Light');

  // Bedroom (lived-in feel)
  furniture(3200, 1130, 220, 130, 'ğŸ›ï¸', 'Bed');
  furniture(3620, 1130, 110, 80, 'ğŸ’»', 'Desk');
  furniture(3620, 1480, 90, 130, 'ğŸ‘”', 'Wardrobe');
  furniture(3130, 1480, 60, 60, 'ğŸª´', 'Plant');
  furniture(3770, 1330, 60, 60, 'ğŸª', 'Mirror');
  furniture(3130, 1130, 50, 50, 'ğŸ“‹', 'Nightstand');
  furniture(3450, 1130, 50, 50, 'ğŸ“‹', 'Nightstand');
  furniture(3750, 1130, 60, 50, 'ğŸ“‹', 'Bookshelf Small');
  furniture(3450, 1500, 80, 60, 'ğŸ“¦', 'Boxes');
  furniture(3200, 1700, 80, 60, 'ğŸ§º', 'Laundry');
  furniture(3500, 1700, 60, 60, 'ğŸ’¡', 'Lamp');

  // Gym (packed with equipment)
  furniture(180, 2130, 150, 65, 'ğŸ‹ï¸', 'Bench Press');
  furniture(480, 2130, 110, 65, 'ğŸ‹ï¸', 'Weights');
  furniture(180, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(360, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(550, 2420, 65, 150, 'ğŸƒ', 'Treadmill');
  furniture(680, 2260, 130, 65, 'ğŸ’ª', 'Dumbbells');
  furniture(900, 2460, 85, 85, 'ğŸ¥Š', 'Punching Bag');
  furniture(680, 2620, 110, 55, 'ğŸ§˜', 'Yoga Mat');
  furniture(900, 2130, 100, 65, 'ğŸ‹ï¸', 'Weights');
  furniture(1050, 2300, 80, 80, 'ğŸ’ª', 'Kettlebells');
  furniture(180, 2700, 100, 60, 'ğŸ“‹', 'Gym Mirror');
  furniture(400, 2700, 80, 80, 'ğŸ“‹', 'Water Cooler');
  furniture(1050, 2500, 80, 60, 'ğŸ“‹', 'Foam Roller');
  furniture(850, 2700, 110, 55, 'ğŸ§˜', 'Yoga Mat');

  // Garden (lush and full)
  furniture(1420, 2180, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(1780, 2120, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(2180, 2380, 110, 110, 'ğŸŒ³', 'Tree');
  furniture(2450, 2600, 100, 100, 'ğŸŒ³', 'Tree');
  furniture(1480, 2530, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(1950, 2580, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(2350, 2200, 90, 65, 'ğŸŒ¿', 'Bush');
  furniture(1680, 2380, 130, 80, 'â›²', 'Fountain');
  furniture(2450, 2180, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(1400, 2400, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(2100, 2150, 65, 65, 'ğŸŒ»', 'Flowers');
  furniture(1600, 2700, 80, 80, 'ğŸ“‹', 'Garden Bench');
  furniture(2300, 2700, 80, 80, 'ğŸ“‹', 'Bird Bath');
  furniture(1350, 2750, 80, 60, 'ğŸŒ¿', 'Bush');
  furniture(2550, 2450, 60, 60, 'ğŸª´', 'Plant');
  furniture(2000, 2250, 80, 60, 'ğŸ“‹', 'Flower Pot');

  // Garage (workshop feel)
  furniture(2880, 2180, 240, 130, 'ğŸš—', 'Car');
  furniture(3280, 2130, 90, 210, 'ğŸ”§', 'Workbench');
  furniture(3530, 2130, 130, 65, 'ğŸ§°', 'Toolbox');
  furniture(2880, 2530, 110, 90, 'ğŸ›¢ï¸', 'Barrel');
  furniture(3180, 2580, 110, 90, 'ğŸ“¦', 'Boxes');
  furniture(3620, 2480, 65, 110, 'ğŸªœ', 'Ladder');
  furniture(3530, 2350, 100, 60, 'ğŸ§°', 'Toolbox');
  furniture(2880, 2750, 100, 80, 'ğŸ›¢ï¸', 'Barrel');
  furniture(3450, 2750, 80, 60, 'ğŸ“¦', 'Boxes');
  furniture(3700, 2130, 80, 60, 'ğŸ“‹', 'Shelving');
  furniture(3700, 2300, 80, 80, 'ğŸ“‹', 'Oil Can');
  furniture(3200, 2800, 80, 50, 'ğŸ“‹', 'Floor Jack');

  // â”€â”€â”€ FLOOR DECORATIONS (non-collision) â”€â”€â”€
  FLOOR_DECORATIONS.length = 0;
  function decor(x, y, w, h, type, extra) {
    FLOOR_DECORATIONS.push({ x, y, w, h, type, ...extra });
  }

  // Kitchen floor decorations
  decor(300, 600, 200, 150, 'rug', { color: 'rgba(80,120,60,0.1)', border: 'rgba(100,140,80,0.08)' });
  decor(700, 600, 40, 20, 'vent', {});

  // Cafeteria vents and floor marks
  decor(1600, 350, 50, 30, 'vent', {});
  decor(2200, 250, 50, 30, 'vent', {});
  decor(1400, 850, 100, 8, 'floor-mark', { color: 'rgba(255,200,0,0.04)' });
  decor(2400, 850, 100, 8, 'floor-mark', { color: 'rgba(255,200,0,0.04)' });

  // Living Room rug
  decor(2950, 350, 250, 180, 'rug', { color: 'rgba(60,60,120,0.12)', border: 'rgba(80,80,150,0.1)' });
  decor(3400, 350, 80, 20, 'cable', { color: 'rgba(40,40,40,0.15)' });

  // Bathroom puddle and drain
  decor(280, 1250, 60, 40, 'puddle', {});
  decor(500, 1500, 20, 20, 'drain', {});
  decor(200, 1700, 100, 60, 'mat', { color: 'rgba(60,100,100,0.12)' });

  // Hallway: vents, warning stripes, cables
  decor(1100, 1350, 60, 30, 'vent', {});
  decor(1500, 1250, 60, 30, 'vent', {});
  decor(2100, 1350, 60, 30, 'vent', {});
  decor(2600, 1250, 60, 30, 'vent', {});
  decor(1050, 1700, 200, 12, 'warning-stripes', {});
  decor(2700, 1700, 200, 12, 'warning-stripes', {});
  decor(1350, 1300, 80, 40, 'cable', { color: 'rgba(200,50,50,0.08)' });
  decor(2300, 1400, 100, 30, 'cable', { color: 'rgba(50,100,200,0.08)' });
  decor(1800, 1150, 100, 10, 'floor-mark', { color: 'rgba(255,200,0,0.03)' });

  // Bedroom rug
  decor(3200, 1320, 200, 140, 'rug', { color: 'rgba(100,40,60,0.1)', border: 'rgba(130,60,80,0.08)' });

  // Gym floor markings
  decor(100, 2350, 1100, 8, 'floor-mark', { color: 'rgba(255,255,255,0.02)' });
  decor(600, 2100, 8, 600, 'floor-mark', { color: 'rgba(255,255,255,0.02)' });
  decor(300, 2350, 80, 50, 'mat', { color: 'rgba(60,30,80,0.12)' });
  decor(700, 2500, 40, 20, 'vent', {});

  // Garden path stones (some extra)
  decor(1500, 2450, 60, 40, 'mat', { color: 'rgba(100,90,80,0.08)' });
  decor(2100, 2500, 60, 40, 'mat', { color: 'rgba(100,90,80,0.08)' });

  // Garage: tire marks, oil, warning stripes
  decor(2850, 2400, 200, 300, 'tire-marks', {});
  decor(2800, 2900, 400, 14, 'warning-stripes', {});
  decor(3500, 2600, 50, 30, 'vent', {});
  decor(3300, 2450, 60, 40, 'mat', { color: 'rgba(40,40,40,0.15)' });
}

// â”€â”€ COLOR PICKER â”€â”€
function buildColorPicker() {
  const container = document.getElementById('color-picker');
  container.innerHTML = BEAN_COLORS.map((c, i) => `
    <button class="lobby-color-btn ${i === 0 ? 'selected' : ''}"
      style="background:${c.body};"
      onclick="selectColor(${i})"
      title="${c.name}"></button>
  `).join('');
}

function selectColor(idx) {
  selectedColorIdx = idx;
  document.querySelectorAll('.lobby-color-btn').forEach((btn, i) => {
    btn.classList.toggle('selected', i === idx);
  });
  drawLobbyAvatar();
}

function selectMode(btn, count) {
  playerCount = count;
  document.querySelectorAll('.lobby-mode-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
}

// â”€â”€ DRAW BEAN CHARACTER â”€â”€
function drawBean(ctx, x, y, color, scale = 1, facingLeft = false, name = '', isShielded = false, isPowered = false) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);
  if (facingLeft) ctx.scale(-1, 1);

  // Walking bob animation
  const time = frameCount / 60;
  const isMoving = Math.abs(inputDir.x) > 0.1 || Math.abs(inputDir.y) > 0.1;
  const walkBob = isMoving ? Math.sin(time * 12) * 1.5 : 0;
  const legPhase = isMoving ? Math.sin(time * 12) * 3 : 0;

  // Ground shadow (dynamic size based on movement)
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(0, 24, 16 + (isMoving ? 1 : 0), 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Shield glow (enhanced with pulsing)
  if (isShielded) {
    const shieldPulse = Math.sin(time * 4) * 0.15 + 0.85;
    ctx.strokeStyle = `rgba(16,185,129,${0.5 * shieldPulse})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, -2, 28, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = `rgba(16,185,129,${0.15 * shieldPulse})`;
    ctx.lineWidth = 8;
    ctx.stroke();
    // Shield hexagon pattern
    ctx.strokeStyle = `rgba(16,185,129,${0.1 * shieldPulse})`;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 6; i++) {
      const a1 = (i / 6) * Math.PI * 2;
      const a2 = ((i + 1) / 6) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a1) * 26, -2 + Math.sin(a1) * 26);
      ctx.lineTo(Math.cos(a2) * 26, -2 + Math.sin(a2) * 26);
      ctx.stroke();
    }
  }

  // Power glow (enhanced with particles effect)
  if (isPowered) {
    ctx.shadowColor = 'rgba(239,68,68,0.6)';
    ctx.shadowBlur = 18;
    // Power aura
    ctx.fillStyle = 'rgba(239,68,68,0.06)';
    ctx.beginPath();
    ctx.arc(0, -2, 24, 0, Math.PI * 2);
    ctx.fill();
  }

  // Apply walk bob to whole character
  ctx.translate(0, walkBob * 0.5);

  // Backpack (Among Us style - more detailed)
  ctx.fillStyle = color.dark;
  ctx.beginPath();
  ctx.roundRect(-22, -10, 12, 24, 5);
  ctx.fill();
  // Backpack detail line
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(-22, -2); ctx.lineTo(-10, -2);
  ctx.stroke();
  // Backpack highlight
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(-21, -9, 3, 10);

  // Body (bean shape - enhanced with gradient)
  const bodyGrd = ctx.createLinearGradient(-14, -24, 14, 24);
  bodyGrd.addColorStop(0, color.body);
  bodyGrd.addColorStop(0.7, color.body);
  bodyGrd.addColorStop(1, color.dark);
  ctx.fillStyle = bodyGrd;
  ctx.beginPath();
  ctx.moveTo(-14, 20);
  ctx.lineTo(-14, -8);
  ctx.quadraticCurveTo(-14, -24, 0, -24);
  ctx.quadraticCurveTo(14, -24, 14, -8);
  ctx.lineTo(14, 20);
  ctx.quadraticCurveTo(14, 24, 8, 24);
  ctx.lineTo(3, 24);
  ctx.lineTo(3, 20);
  ctx.lineTo(-3, 20);
  ctx.lineTo(-3, 24);
  ctx.lineTo(-8, 24);
  ctx.quadraticCurveTo(-14, 24, -14, 20);
  ctx.fill();

  // Body outline
  ctx.strokeStyle = color.dark;
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-14, 20);
  ctx.lineTo(-14, -8);
  ctx.quadraticCurveTo(-14, -24, 0, -24);
  ctx.quadraticCurveTo(14, -24, 14, -8);
  ctx.lineTo(14, 20);
  ctx.stroke();

  // Body highlight (left side shine)
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.moveTo(-12, 10);
  ctx.lineTo(-12, -6);
  ctx.quadraticCurveTo(-12, -20, -4, -22);
  ctx.lineTo(-8, -20);
  ctx.quadraticCurveTo(-10, -16, -10, -4);
  ctx.lineTo(-10, 10);
  ctx.closePath();
  ctx.fill();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // Visor (Among Us style - enhanced with depth)
  // Visor shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(6, -5, 10.5, 8.5, 0.15, 0, Math.PI * 2);
  ctx.fill();
  // Visor main
  const visorGrd = ctx.createRadialGradient(8, -8, 2, 6, -6, 10);
  visorGrd.addColorStop(0, '#fff');
  visorGrd.addColorStop(0.3, color.visor);
  visorGrd.addColorStop(1, color.dark);
  ctx.fillStyle = visorGrd;
  ctx.beginPath();
  ctx.ellipse(6, -6, 10, 8, 0.15, 0, Math.PI * 2);
  ctx.fill();

  // Visor shine (two spots for realism)
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.beginPath();
  ctx.ellipse(9, -9, 3.5, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath();
  ctx.ellipse(4, -3, 2, 1.5, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Legs (with walking animation)
  ctx.fillStyle = color.dark;
  ctx.fillRect(-10, 20 - legPhase * 0.3, 6, 6 + Math.abs(legPhase) * 0.2);
  ctx.fillRect(4, 20 + legPhase * 0.3, 6, 6 + Math.abs(legPhase) * 0.2);

  // Feet (with walking step)
  ctx.fillStyle = color.body;
  ctx.beginPath();
  ctx.roundRect(-12, 24 - legPhase * 0.3, 10, 5, [0, 0, 3, 3]);
  ctx.fill();
  ctx.beginPath();
  ctx.roundRect(2, 24 + legPhase * 0.3, 10, 5, [0, 0, 3, 3]);
  ctx.fill();

  // Bone (belly marking - subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-4, 6); ctx.lineTo(4, 6);
  ctx.stroke();

  if (facingLeft) ctx.scale(-1, 1);

  // Name tag (enhanced with background)
  if (name) {
    ctx.font = '600 9px Inter, sans-serif';
    ctx.textAlign = 'center';
    const tw = ctx.measureText(name).width;
    // Name background
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(-tw / 2 - 4, -37, tw + 8, 13, 3);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText(name, 0, -28);
  }

  ctx.restore();
}

function drawLobbyAvatar() {
  const c = document.getElementById('lobby-avatar');
  const lctx = c.getContext('2d');
  lctx.clearRect(0, 0, c.width, c.height);
  drawBean(lctx, 70, 90, BEAN_COLORS[selectedColorIdx], 2.5, false, '');
}

// â”€â”€ GAME START â”€â”€
function startGame() {
  document.getElementById('lobby').classList.add('hidden');
  document.getElementById('hud').style.display = '';
  document.getElementById('players-alive').style.display = '';
  document.getElementById('action-zone').style.display = '';
  document.getElementById('dpad-hint').style.display = '';
  gameState = 'playing';

  // Create player
  player = {
    x: ARENA_W / 2,
    y: ARENA_H / 2,
    color: BEAN_COLORS[selectedColorIdx],
    name: 'You',
    hp: 3,
    kills: 0,
    speed: PLAYER_SPEED,
    facingLeft: false,
    alive: true,
    powerups: [],
    invincibleUntil: 0,
  };

  // Create bots
  bots = [];
  const botNames = ['FitFrog', 'GymRat', 'IronChef', 'CardioKing', 'FlexBot', 'GainzGuru', 'RunBuddy', 'LiftLord'];
  const usedColors = [selectedColorIdx];

  for (let i = 0; i < playerCount - 1; i++) {
    let colorIdx;
    do { colorIdx = Math.floor(Math.random() * BEAN_COLORS.length); }
    while (usedColors.includes(colorIdx));
    usedColors.push(colorIdx);

    const angle = (Math.PI * 2 * i) / (playerCount - 1);
    const dist = 400 + Math.random() * 300;
    bots.push({
      x: ARENA_W / 2 + Math.cos(angle) * dist,
      y: ARENA_H / 2 + Math.sin(angle) * dist,
      color: BEAN_COLORS[colorIdx],
      name: botNames[i % botNames.length],
      hp: 3,
      alive: true,
      facingLeft: false,
      speed: BOT_SPEED,
      powerups: [],
      invincibleUntil: 0,
      // AI state
      ai: {
        targetX: 0, targetY: 0,
        nextDecision: 0,
        state: 'wander', // wander | chase | flee | powerup
        targetEntity: null,
      },
      fitnessLevel: 30 + Math.floor(Math.random() * 50),
    });
  }

  // Spawn powerups
  spawnPowerups(8);

  eliminationOrder = [];
  showNotification('Arena started! Find and battle opponents!');
}

function spawnPowerups(count) {
  for (let i = 0; i < count; i++) {
    const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    let x, y, valid;
    // Ensure powerup doesn't overlap obstacles
    do {
      x = 80 + Math.random() * (ARENA_W - 160);
      y = 80 + Math.random() * (ARENA_H - 160);
      valid = !MAP_OBSTACLES.some(o =>
        x > o.x - 20 && x < o.x + o.w + 20 &&
        y > o.y - 20 && y < o.y + o.h + 20
      );
    } while (!valid);

    powerups.push({
      x, y, ...type,
      bobPhase: Math.random() * Math.PI * 2,
      alive: true,
    });
  }
}

// â”€â”€ JOYSTICK â”€â”€
function setupJoystick() {
  const zone = document.getElementById('joystick-zone');
  const base = document.getElementById('joystick-base');
  const thumb = document.getElementById('joystick-thumb');
  const dpadHint = document.getElementById('dpad-hint');

  zone.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    const t = e.touches[0];
    joystickActive = true;
    joystickOrigin = { x: t.clientX, y: t.clientY };
    base.style.display = 'block';
    base.style.left = (t.clientX - 60) + 'px';
    base.style.top = (t.clientY - 60) + 'px';
    thumb.style.display = 'block';
    thumb.style.left = (t.clientX - 25) + 'px';
    thumb.style.top = (t.clientY - 25) + 'px';
    if (dpadHint) dpadHint.classList.add('active');
  }, { passive: false });

  zone.addEventListener('touchmove', e => {
    e.preventDefault();
    e.stopPropagation();
    if (!joystickActive) return;
    const t = e.touches[0];
    const dx = t.clientX - joystickOrigin.x;
    const dy = t.clientY - joystickOrigin.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    const maxDist = 50;
    const clampDist = Math.min(d, maxDist);
    const angle = Math.atan2(dy, dx);

    const thumbX = joystickOrigin.x + Math.cos(angle) * clampDist;
    const thumbY = joystickOrigin.y + Math.sin(angle) * clampDist;
    thumb.style.left = (thumbX - 25) + 'px';
    thumb.style.top = (thumbY - 25) + 'px';

    inputDir.x = (clampDist / maxDist) * Math.cos(angle);
    inputDir.y = (clampDist / maxDist) * Math.sin(angle);
  }, { passive: false });

  const endJoystick = () => {
    joystickActive = false;
    inputDir = { x: 0, y: 0 };
    base.style.display = 'none';
    thumb.style.display = 'none';
    if (dpadHint) dpadHint.classList.remove('active');
  };
  zone.addEventListener('touchend', endJoystick);
  zone.addEventListener('touchcancel', endJoystick);

  // Also listen on canvas itself for taps on right side â†’ tap-to-move
  canvas.addEventListener('touchstart', e => {
    if (gameState !== 'playing' || !player) return;
    const t = e.touches[0];
    // Only if tapping right half (joystick zone is left half)
    if (t.clientX > window.innerWidth * 0.5) {
      e.preventDefault();
      const worldX = t.clientX + camera.x;
      const worldY = t.clientY + camera.y;
      // Set a move target the player walks toward
      player._moveTarget = { x: worldX, y: worldY };
    }
  }, { passive: false });
}

// â”€â”€ GAME LOOP â”€â”€
function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 16.67, 3); // normalize to ~60fps
  lastTime = timestamp;
  frameCount++;

  if (gameState === 'playing') {
    updateInput();
    updatePlayer(dt);
    updateBots(dt);
    checkCollisions();
    updatePowerups(dt);
    updateParticles(dt);
    updateCamera();
    checkGameOver();
  }

  render();
  requestAnimationFrame(gameLoop);
}

// â”€â”€ INPUT â”€â”€
function updateInput() {
  if (joystickActive) return; // joystick takes priority

  inputDir = { x: 0, y: 0 };
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) inputDir.x = -1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) inputDir.x = 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) inputDir.y = -1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) inputDir.y = 1;

  // Normalize
  const len = Math.sqrt(inputDir.x ** 2 + inputDir.y ** 2);
  if (len > 1) {
    inputDir.x /= len;
    inputDir.y /= len;
  }
}

// â”€â”€ PLAYER UPDATE â”€â”€
function updatePlayer(dt) {
  if (!player || !player.alive) return;

  let moveX = inputDir.x;
  let moveY = inputDir.y;

  // Tap-to-move: walk toward target if no joystick/keyboard input
  if (moveX === 0 && moveY === 0 && player._moveTarget) {
    const dx = player._moveTarget.x - player.x;
    const dy = player._moveTarget.y - player.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > 5) {
      moveX = dx / d;
      moveY = dy / d;
    } else {
      player._moveTarget = null;
    }
  }

  const speed = player.speed * (hasActivePowerup(player, 'speed') ? 1.6 : 1) * dt;
  let nx = player.x + moveX * speed;
  let ny = player.y + moveY * speed;

  // Facing direction
  if (moveX < -0.1) player.facingLeft = true;
  if (moveX > 0.1) player.facingLeft = false;

  // Bounds
  nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
  ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

  // Obstacle collision
  if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
    player.x = nx;
    player.y = ny;
  } else if (!collidesWithObstacle(nx, player.y, PLAYER_RADIUS)) {
    player.x = nx;
  } else if (!collidesWithObstacle(player.x, ny, PLAYER_RADIUS)) {
    player.y = ny;
  }

  // Cancel tap-to-move on manual input
  if (inputDir.x !== 0 || inputDir.y !== 0) player._moveTarget = null;

  // Powerup expiry
  player.powerups = player.powerups.filter(p => Date.now() < p.expires);
  updatePowerupUI(player);
}

// â”€â”€ BOT AI â”€â”€
function updateBots(dt) {
  const now = Date.now();
  bots.forEach(bot => {
    if (!bot.alive) return;

    const ai = bot.ai;

    // Decision timer
    if (now > ai.nextDecision) {
      ai.nextDecision = now + 1500 + Math.random() * 2000;

      // Find nearest alive entity
      let nearestBot = null;
      let nearestDist = Infinity;
      const allTargets = [player, ...bots].filter(e => e !== bot && e.alive);

      allTargets.forEach(target => {
        const d = dist(bot, target);
        if (d < nearestDist) {
          nearestDist = d;
          nearestBot = target;
        }
      });

      // Find nearest powerup
      let nearestPU = null;
      let nearestPUDist = Infinity;
      powerups.forEach(pu => {
        if (!pu.alive) return;
        const d = dist(bot, pu);
        if (d < nearestPUDist) {
          nearestPUDist = d;
          nearestPU = pu;
        }
      });

      // Decide behavior
      if (bot.hp <= 1 && nearestDist < 200) {
        // Low HP - flee from nearest
        ai.state = 'flee';
        ai.targetEntity = nearestBot;
      } else if (nearestPU && nearestPUDist < 300 && bot.powerups.length === 0) {
        // Go for nearby powerup
        ai.state = 'powerup';
        ai.targetX = nearestPU.x;
        ai.targetY = nearestPU.y;
      } else if (nearestBot && nearestDist < 350) {
        // Chase nearby opponent
        ai.state = 'chase';
        ai.targetEntity = nearestBot;
      } else {
        // Wander
        ai.state = 'wander';
        ai.targetX = 100 + Math.random() * (ARENA_W - 200);
        ai.targetY = 100 + Math.random() * (ARENA_H - 200);
      }
    }

    // Move based on AI state
    let tx, ty;
    if (ai.state === 'flee' && ai.targetEntity && ai.targetEntity.alive) {
      const dx = bot.x - ai.targetEntity.x;
      const dy = bot.y - ai.targetEntity.y;
      const d = Math.sqrt(dx * dx + dy * dy) || 1;
      tx = bot.x + (dx / d) * 200;
      ty = bot.y + (dy / d) * 200;
    } else if (ai.state === 'chase' && ai.targetEntity && ai.targetEntity.alive) {
      tx = ai.targetEntity.x;
      ty = ai.targetEntity.y;
    } else {
      tx = ai.targetX;
      ty = ai.targetY;
    }

    const dx = tx - bot.x;
    const dy = ty - bot.y;
    const d = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = bot.speed * (hasActivePowerup(bot, 'speed') ? 1.5 : 1) * dt;

    if (d > 5) {
      let nx = bot.x + (dx / d) * speed;
      let ny = bot.y + (dy / d) * speed;

      nx = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_W - PLAYER_RADIUS - 20, nx));
      ny = Math.max(PLAYER_RADIUS + 20, Math.min(ARENA_H - PLAYER_RADIUS - 20, ny));

      if (!collidesWithObstacle(nx, ny, PLAYER_RADIUS)) {
        bot.x = nx;
        bot.y = ny;
      } else if (!collidesWithObstacle(nx, bot.y, PLAYER_RADIUS)) {
        bot.x = nx;
      } else if (!collidesWithObstacle(bot.x, ny, PLAYER_RADIUS)) {
        bot.y = ny;
      }

      bot.facingLeft = dx < 0;
    }

    // Bot powerup expiry
    bot.powerups = bot.powerups.filter(p => Date.now() < p.expires);
  });
}

// â”€â”€ COLLISIONS â”€â”€
function checkCollisions() {
  if (!player || !player.alive) return;
  const now = Date.now();

  // Player vs bots
  bots.forEach(bot => {
    if (!bot.alive) return;
    if (now < player.invincibleUntil || now < bot.invincibleUntil) return;

    const d = dist(player, bot);
    if (d < BATTLE_RANGE) {
      startBattle(bot);
    }
  });

  // Bot vs bot
  for (let i = 0; i < bots.length; i++) {
    for (let j = i + 1; j < bots.length; j++) {
      if (!bots[i].alive || !bots[j].alive) continue;
      if (now < bots[i].invincibleUntil || now < bots[j].invincibleUntil) continue;
      const d = dist(bots[i], bots[j]);
      if (d < BATTLE_RANGE) {
        resolveBotBattle(bots[i], bots[j]);
      }
    }
  }

  // Player vs powerups
  powerups.forEach(pu => {
    if (!pu.alive) return;
    const d = dist(player, pu);
    if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
      collectPowerup(player, pu);
    }
  });

  // Bots vs powerups
  bots.forEach(bot => {
    if (!bot.alive) return;
    powerups.forEach(pu => {
      if (!pu.alive) return;
      const d = dist(bot, pu);
      if (d < PLAYER_RADIUS + POWERUP_RADIUS) {
        collectPowerup(bot, pu);
      }
    });
  });
}

function collidesWithObstacle(x, y, r) {
  return MAP_OBSTACLES.some(o =>
    x + r > o.x && x - r < o.x + o.w &&
    y + r > o.y && y - r < o.y + o.h
  );
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

// â”€â”€ POWERUPS â”€â”€
function collectPowerup(entity, pu) {
  pu.alive = false;

  if (pu.effect === 'heal') {
    entity.hp = Math.min(entity.hp + 1, 5);
    if (entity === player) {
      showNotification(`${pu.icon} Health restored!`);
      document.getElementById('hud-hp').textContent = player.hp;
    }
  } else {
    entity.powerups.push({
      type: pu.effect,
      icon: pu.icon,
      label: pu.label,
      expires: Date.now() + pu.duration,
    });
    if (entity === player) {
      showNotification(`${pu.icon} ${pu.label} activated!`);
    }
  }

  // Spawn particles
  for (let i = 0; i < 8; i++) {
    particles.push({
      x: pu.x, y: pu.y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 1,
      color: pu.color,
      size: 3 + Math.random() * 3,
    });
  }

  // Respawn a new powerup after delay
  setTimeout(() => {
    if (gameState === 'playing') spawnPowerups(1);
  }, 5000 + Math.random() * 5000);
}

function hasActivePowerup(entity, type) {
  return entity.powerups.some(p => p.type === type && Date.now() < p.expires);
}

function updatePowerups(dt) {
  // Bob animation handled in render
}

function updatePowerupUI(entity) {
  if (entity !== player) return;
  const container = document.getElementById('powerup-active');
  const active = entity.powerups.filter(p => Date.now() < p.expires);
  container.innerHTML = active.map(p => {
    const remaining = Math.ceil((p.expires - Date.now()) / 1000);
    return `<div class="powerup-badge">${p.icon} ${p.label} ${remaining}s</div>`;
  }).join('');
}

function updateParticles(dt) {
  particles = particles.filter(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= 0.03 * dt;
    p.vy += 0.1 * dt;
    return p.life > 0;
  });
}

// â”€â”€ BATTLE SYSTEM (Exact match to dashboard.html) â”€â”€
// Uses model-viewer, fireball.png sprites, dojo background

const ROUND_DURATION = 30000;
const BASH_THRESHOLD_BASE = 30;
const AUTO_ATTACK_INTERVAL = 2500;
const BLOCK_WINDOW = 400;

let combat = null;

function startBattle(opponent) {
  if (gameState !== 'playing') return;
  gameState = 'battle';

  // Hide movement controls during battle
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';

  const overlay = document.getElementById('battle-overlay');
  overlay.classList.add('active');

  // Load model for battle viewport
  setupBattleModel();

  // VS screen
  const vsDiv = document.getElementById('battle-vs');
  vsDiv.innerHTML = `
    <div class="battle-fighter">
      <canvas id="battle-player-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${player.color.body}">You</div>
      <div class="battle-fighter-stats">STR ${fitnessStats.str || 10} / HP ${fitnessStats.hp || 10} / MANA ${fitnessStats.mana || 5}</div>
    </div>
    <div class="battle-vs-text">VS</div>
    <div class="battle-fighter">
      <canvas id="battle-opponent-canvas" width="80" height="90"></canvas>
      <div class="battle-fighter-name" style="color:${opponent.color.body}">${opponent.name}</div>
      <div class="battle-fighter-stats">Lv.${opponent.fitnessLevel || '??'}</div>
    </div>
  `;

  setTimeout(() => {
    const pc = document.getElementById('battle-player-canvas');
    const oc = document.getElementById('battle-opponent-canvas');
    if (pc) drawBean(pc.getContext('2d'), 40, 50, player.color, 1.5);
    if (oc) drawBean(oc.getContext('2d'), 40, 50, opponent.color, 1.5, true);
  }, 50);

  battleState = { opponent, phase: 'intro' };

  // After VS intro, start combat
  setTimeout(() => {
    if (battleState) {
      vsDiv.style.display = 'none';
      initCombat(opponent);
    }
  }, 1500);
}

function initCombat(opponent) {
  const stats = fitnessStats;
  const playerSTR = stats.str || 10;
  const playerHP_stat = stats.hp || 10;
  const playerMANA = stats.mana || 5;

  const botLevel = opponent.fitnessLevel || 40;
  const botSTR = Math.floor(botLevel * 0.3);
  const botHP_stat = Math.floor(botLevel * 0.25);

  const playerMaxHP = 100 + (playerHP_stat * 5);
  const enemyMaxHP = 100 + (botHP_stat * 5);

  combat = {
    opponent,
    round: 1,
    playerRoundWins: 0,
    enemyRoundWins: 0,
    playerHP: playerMaxHP,
    playerMaxHP,
    enemyHP: enemyMaxHP,
    enemyMaxHP,
    playerSTR,
    enemySTR: botSTR,
    playerMANA,
    bashCount: 0,
    bashThreshold: Math.max(10, BASH_THRESHOLD_BASE - Math.floor(playerMANA / 5)),
    superReady: false,
    blockReady: false,
    blockSuccess: false,
    roundOver: false,
    timerEnd: Date.now() + ROUND_DURATION,
    autoAttackTimer: null,
    botAttackTimer: null,
    timerInterval: null,
  };

  // Show combat UI
  document.getElementById('battle-combat-zone').style.display = '';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Show HP bars + action container (mana bar hidden like dashboard)
  document.getElementById('bc-hp-container').classList.add('active');
  document.getElementById('bc-action-container').classList.add('active');

  // Play battle model animation
  const mv = document.getElementById('arena-battle-model');
  if (mv && mv.availableAnimations && mv.availableAnimations.length > 0) {
    const anims = mv.availableAnimations;
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a)) || anims[0];
    mv.animationName = attackAnim;
    mv.play({ repetitions: Infinity });
  }

  // Show BASH! overlay briefly
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.textContent = 'BASH!';
  overlayText.classList.add('active');
  setTimeout(() => overlayText.classList.remove('active'), 1000);

  // Update UI
  document.getElementById('bc-enemy-name').textContent = opponent.name.toUpperCase();
  updateCombatUI();
  updateRoundDots();

  // Populate info panel
  document.getElementById('bc-info-name').textContent = opponent.name;
  document.getElementById('bc-info-level').textContent = `Level ${botLevel}`;
  document.getElementById('bc-info-str').textContent = botSTR;
  document.getElementById('bc-info-hp').textContent = botHP_stat;
  document.getElementById('bc-info-def').textContent = Math.floor(botLevel * 0.2);
  // Draw opponent avatar in info panel
  const infoCanvas = document.getElementById('battle-info-avatar');
  if (infoCanvas && opponent.color) {
    drawBean(infoCanvas.getContext('2d'), 28, 36, opponent.color, 1.2, true);
  }

  // Start timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);

  // Player auto-attacks (fires normal fireballs)
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  // Bot attacks
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);

    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

function combatBash(e) {
  e.preventDefault();
  if (!combat || combat.roundOver) return;

  combat.bashCount++;
  if (navigator.vibrate) navigator.vibrate(30);

  // Bash button feedback
  const btn = document.getElementById('bc-bash-btn');
  btn.style.transform = 'scale(0.88)';
  setTimeout(() => { if (btn) btn.style.transform = ''; }, 50);

  // Update mana/charge bar + SVG ring
  const progress = Math.min(1, combat.bashCount / combat.bashThreshold);
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = (progress * 100) + '%';
  manaPct.textContent = Math.floor(progress * 100) + '%';

  // Update SVG ring (circumference = 2 * PI * 26 = 163.36)
  if (ringFill) {
    ringFill.style.strokeDashoffset = 163.36 * (1 - progress);
  }

  if (progress >= 1) {
    manaFill.classList.add('full');
    btn.classList.add('attack-ready');
  }

  // Check if super is charged
  if (combat.bashCount >= combat.bashThreshold && !combat.superReady) {
    combat.superReady = true;
    const fireBtn = document.getElementById('bc-fire-btn');
    fireBtn.classList.add('visible');
    if (navigator.vibrate) navigator.vibrate([50, 30, 50]);

    // Auto-reset if not fired in 2s
    combat.superTimeout = setTimeout(() => {
      if (combat && combat.superReady) {
        combat.superReady = false;
        combat.bashCount = 0;
        fireBtn.classList.remove('visible');
        manaFill.classList.remove('full');
        btn.classList.remove('attack-ready');
        manaFill.style.width = '0%';
        manaPct.textContent = '0%';
        if (ringFill) ringFill.style.strokeDashoffset = 163.36;
      }
    }, 2000);
  }
}

function combatFire(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.superReady) return;

  combat.superReady = false;
  combat.bashCount = 0;
  clearTimeout(combat.superTimeout);

  // Fire damage (full power) + triple fireball
  const dmg = Math.floor((10 + combat.playerSTR) * 1.0);
  dealDamageToEnemy(dmg, true);

  // Play attack animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv) {
    const anims = mv.availableAnimations || [];
    const attackAnim = anims.find(a => /boxing|punch|attack|fight/i.test(a));
    if (attackAnim) {
      mv.animationName = attackAnim;
      mv.play({ repetitions: 1 });
    }
  }

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const manaPct = document.getElementById('bc-mana-pct');
  const fireBtn = document.getElementById('bc-fire-btn');
  const bashBtn = document.getElementById('bc-bash-btn');
  const ringFill = document.getElementById('bash-ring-fill');

  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  manaPct.textContent = '0%';
  fireBtn.classList.remove('visible');
  bashBtn.classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;

  if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
}

function combatBlock(e) {
  e.preventDefault();
  if (!combat || combat.roundOver || !combat.blockReady) return;

  combat.blockSuccess = true;
  combat.blockReady = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.remove('visible');

  showHitFlash('blocked');
  if (navigator.vibrate) navigator.vibrate([30, 20, 30]);
}

function showBlockPrompt() {
  if (!combat || combat.roundOver) return;
  combat.blockReady = true;
  combat.blockSuccess = false;
  const blockBtn = document.getElementById('bc-block-btn');
  blockBtn.classList.add('visible');

  setTimeout(() => {
    if (combat) {
      combat.blockReady = false;
      blockBtn.classList.remove('visible');
    }
  }, BLOCK_WINDOW + 100);
}

function dealDamageToEnemy(dmg, isSuper) {
  if (!combat || combat.roundOver) return;
  combat.enemyHP = Math.max(0, combat.enemyHP - dmg);
  updateCombatUI();

  // Spawn fireball in viewport (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnTripleFireball(viewport);
  } else {
    spawnNormalFireball(viewport);
  }

  if (isSuper) {
    showHitFlash('super-hit');
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.enemyHP <= 0) {
    endRound(true);
  }
}

function dealDamageToPlayer(dmg, isSuper) {
  if (!combat || combat.roundOver) return;

  const blockMult = combat.blockSuccess ? 0.5 : 1.0;
  const actualDmg = Math.floor(dmg * blockMult);
  combat.playerHP = Math.max(0, combat.playerHP - actualDmg);
  const wasBlocked = combat.blockSuccess;
  combat.blockSuccess = false;
  updateCombatUI();

  // Spawn incoming fireball (same as dashboard)
  const viewport = document.getElementById('battle-viewport');
  if (isSuper) {
    spawnIncomingTripleFireball(viewport);
  } else {
    spawnIncomingBattleFireball(viewport);
  }

  // Play hit animation on model
  const mv = document.getElementById('arena-battle-model');
  if (mv && !wasBlocked) {
    const anims = mv.availableAnimations || [];
    const hitAnim = anims.find(a => /hit|hurt|damage|flinch/i.test(a));
    if (hitAnim) {
      mv.animationName = hitAnim;
      mv.play({ repetitions: 1 });
    }
  }

  showHitFlash(wasBlocked ? 'blocked' : isSuper ? 'super-hit' : '');

  if (isSuper && !wasBlocked) {
    document.getElementById('battle-overlay').classList.add('battle-shake');
    setTimeout(() => document.getElementById('battle-overlay').classList.remove('battle-shake'), 300);
  }

  if (combat.playerHP <= 0) {
    endRound(false);
  }
}

function showHitFlash(type) {
  const flash = document.createElement('div');
  flash.className = 'battle-hit-flash ' + type;
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 400);
}

function updateCombatUI() {
  if (!combat) return;
  const { playerHP, playerMaxHP, enemyHP, enemyMaxHP } = combat;

  const playerPct = Math.max(0, (playerHP / playerMaxHP) * 100);
  const enemyPct = Math.max(0, (enemyHP / enemyMaxHP) * 100);

  document.getElementById('bc-hp-player').style.width = playerPct + '%';
  document.getElementById('bc-hp-enemy').style.width = enemyPct + '%';
  document.getElementById('bc-hp-player-text').textContent = `${Math.max(0,playerHP)} / ${playerMaxHP}`;
  document.getElementById('bc-hp-enemy-text').textContent = `${Math.max(0,enemyHP)} / ${enemyMaxHP}`;
}

function updateCombatTimer() {
  if (!combat) return;
  const remaining = Math.max(0, Math.ceil((combat.timerEnd - Date.now()) / 1000));
  document.getElementById('bc-timer').textContent = remaining;
  if (remaining <= 0 && !combat.roundOver) {
    // Time's up - higher HP% wins
    const playerPct = combat.playerHP / combat.playerMaxHP;
    const enemyPct = combat.enemyHP / combat.enemyMaxHP;
    endRound(playerPct >= enemyPct);
  }
}

function updateRoundDots() {
  if (!combat) return;
  for (let i = 1; i <= 3; i++) {
    const dot = document.getElementById('rd' + i);
    dot.className = 'round-dot';
    if (i <= combat.playerRoundWins) dot.classList.add('player-win');
  }
  // Show enemy wins on the other end conceptually via color
  document.getElementById('bc-round').textContent = combat.round;
}

function endRound(playerWon) {
  if (!combat || combat.roundOver) return;
  combat.roundOver = true;

  clearInterval(combat.autoAttackTimer);
  clearInterval(combat.botAttackTimer);
  clearInterval(combat.timerInterval);
  clearTimeout(combat.superTimeout);

  if (playerWon) {
    combat.playerRoundWins++;
  } else {
    combat.enemyRoundWins++;
  }

  updateRoundDots();

  // Check match result (best of 3)
  if (combat.playerRoundWins >= 2 || combat.enemyRoundWins >= 2) {
    const matchWon = combat.playerRoundWins >= 2;
    setTimeout(() => showBattleResult(matchWon,
      `${combat.playerRoundWins} - ${combat.enemyRoundWins}`), 800);
  } else {
    // Next round after brief pause
    showNotification(playerWon ? 'Round won!' : 'Round lost!');
    setTimeout(() => startNextRound(), 1500);
  }
}

function startNextRound() {
  if (!combat) return;
  combat.round++;
  combat.playerHP = combat.playerMaxHP;
  combat.enemyHP = combat.enemyMaxHP;
  combat.bashCount = 0;
  combat.superReady = false;
  combat.blockReady = false;
  combat.roundOver = false;
  combat.timerEnd = Date.now() + ROUND_DURATION;

  // Clear any remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Show round transition
  const overlayText = document.getElementById('bc-overlay-text');
  const textInner = document.getElementById('bc-text-inner');
  textInner.innerHTML = `<div style="animation:roundTextPop 0.5s ease-out;">ROUND ${combat.round}</div>` +
    `<div style="font-size:0.6em;margin-top:8px;opacity:0.9;">${combat.playerRoundWins} - ${combat.enemyRoundWins}</div>`;
  overlayText.style.color = '#FFD700';
  overlayText.classList.add('active');
  setTimeout(() => { overlayText.classList.remove('active'); overlayText.style.color = ''; }, 1500);

  // Reset UI
  const manaFill = document.getElementById('bc-mana-fill');
  const ringFill = document.getElementById('bash-ring-fill');
  manaFill.style.width = '0%';
  manaFill.classList.remove('full');
  document.getElementById('bc-mana-pct').textContent = '0%';
  document.getElementById('bc-fire-btn').classList.remove('visible');
  document.getElementById('bc-block-btn').classList.remove('visible');
  document.getElementById('bc-bash-btn').classList.remove('attack-ready');
  if (ringFill) ringFill.style.strokeDashoffset = 163.36;
  updateCombatUI();
  updateRoundDots();

  // Restart timers
  combat.timerInterval = setInterval(updateCombatTimer, 100);
  combat.autoAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    const dmg = Math.floor((10 + combat.playerSTR) * 0.2);
    dealDamageToEnemy(dmg, false);
  }, AUTO_ATTACK_INTERVAL);

  const botLevel = combat.opponent.fitnessLevel || 40;
  const botSpeed = Math.max(1800, 4500 - botLevel * 40);
  let botAttackCount = 0;
  combat.botAttackTimer = setInterval(() => {
    if (!combat || combat.roundOver) return;
    botAttackCount++;
    const isSuper = botAttackCount % 4 === 0;
    const dmg = isSuper
      ? Math.floor((10 + combat.enemySTR) * 1.0)
      : Math.floor((10 + combat.enemySTR) * 0.2);
    if (isSuper) {
      showBlockPrompt();
      setTimeout(() => {
        if (!combat || combat.roundOver) return;
        dealDamageToPlayer(dmg, isSuper);
      }, BLOCK_WINDOW);
    } else {
      dealDamageToPlayer(dmg, false);
    }
  }, botSpeed);
}

// â”€â”€ FIREBALL SYSTEM (matches dashboard exactly) â”€â”€

function spawnNormalFireball(container) {
  const fb = document.createElement('div');
  fb.className = 'fireball';
  fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px;filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
  fb.style.cssText = 'position:absolute; left:150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
  container.appendChild(fb);
  let posX = 150;
  function move() {
    posX += 5;
    fb.style.left = posX + 'px';
    if (posX > container.clientWidth) fb.remove();
    else requestAnimationFrame(move);
  }
  move();
}

function spawnTripleFireball(container) {
  const offsets = [-80, 0, 80];
  offsets.forEach((yOff, i) => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;filter:drop-shadow(0 0 30px gold) brightness(1.3);">`;
    fb.style.cssText = `position:absolute; left:150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
    container.appendChild(fb);
    let posX = 150;
    const speed = 5 + i;
    function move() {
      posX += speed;
      fb.style.left = posX + 'px';
      if (posX > container.clientWidth) fb.remove();
      else requestAnimationFrame(move);
    }
    setTimeout(() => move(), i * 60);
  });
}

function spawnIncomingBattleFireball(container) {
  return new Promise(resolve => {
    const fb = document.createElement('div');
    fb.className = 'fireball';
    fb.innerHTML = `<img src="./assets/fireball.png" style="width:140px;height:140px; transform:scaleX(-1); filter:drop-shadow(0 0 22px orange);" onerror="this.style.background='radial-gradient(circle, orange, red)'; this.style.borderRadius='50%';">`;
    fb.style.cssText = 'position:absolute; right:-150px; top:50%; transform:translateY(-50%); z-index:100; pointer-events:none;';
    container.appendChild(fb);
    let posX = container.clientWidth;
    const targetX = container.clientWidth / 2;
    const speed = 4;
    function move() {
      posX -= speed;
      fb.style.left = posX + 'px';
      if (posX <= targetX) { fb.remove(); resolve(); }
      else requestAnimationFrame(move);
    }
    move();
  });
}

function spawnIncomingTripleFireball(container) {
  return new Promise(resolve => {
    const offsets = [-60, 0, 60];
    let resolved = false;
    offsets.forEach((yOff, i) => {
      const fb = document.createElement('div');
      fb.className = 'fireball';
      fb.innerHTML = `<img src="./assets/special.png" style="width:140px;height:140px;border-radius:50%;transform:scaleX(-1);filter:drop-shadow(0 0 30px cyan) brightness(1.3);">`;
      fb.style.cssText = `position:absolute; right:-150px; top:calc(50% + ${yOff}px); transform:translateY(-50%); z-index:100; pointer-events:none;`;
      container.appendChild(fb);
      let posX = container.clientWidth;
      const targetX = container.clientWidth / 2;
      const speed = 4 + i;
      function move() {
        posX -= speed;
        fb.style.left = posX + 'px';
        if (posX <= targetX) {
          fb.remove();
          if (!resolved) { resolved = true; resolve(); }
        }
        else requestAnimationFrame(move);
      }
      setTimeout(() => move(), i * 60);
    });
  });
}

// Setup battle model from localStorage (same source as tamagotchi)
function setupBattleModel() {
  const mv = document.getElementById('arena-battle-model');
  if (!mv) return;
  const src = localStorage.getItem('fitgotchi_model_src') ||
    'https://f005.backblazeb2.com/file/shannonsvideos/baby_full_animations.glb';
  mv.setAttribute('src', src);
  mv.removeAttribute('auto-rotate');
  mv.removeAttribute('camera-controls');
  const savedOrbit = localStorage.getItem('fitgotchi_camera_orbit');
  if (savedOrbit) {
    // Extract distance from saved orbit, use 0deg 85deg for battle
    const match = savedOrbit.match(/([\d.]+m)$/);
    const dist = match ? match[1] : '22m';
    mv.setAttribute('camera-orbit', `0deg 85deg ${dist}`);
  }
}

function showBattleResult(won, detail = '') {
  // Hide combat zone
  document.getElementById('battle-combat-zone').style.display = 'none';

  // Hide battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');

  // Clear remaining fireballs
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clean up combat timers
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
  }

  const resultDiv = document.getElementById('battle-result');
  resultDiv.classList.add('active');

  if (won) {
    resultDiv.innerHTML = `
      <div class="battle-result-text win">Victory!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-warning);margin:4px 0;">${detail}</div>
      <div class="battle-reward">+15 Coins  +10 XP</div>
      <button class="battle-continue-btn" onclick="endBattle(true)">Continue</button>
    `;
    battleState.opponent.hp -= 1;
    if (battleState.opponent.hp <= 0) {
      battleState.opponent.alive = false;
      player.kills++;
      eliminationOrder.push(battleState.opponent.name);
      document.getElementById('hud-kills').textContent = player.kills;
    }
  } else {
    resultDiv.innerHTML = `
      <div class="battle-result-text lose">Defeated!</div>
      <div style="font-size:1.2rem;font-weight:900;color:var(--arena-muted);margin:4px 0;">${detail}</div>
      <button class="battle-continue-btn" style="background:linear-gradient(135deg,var(--arena-secondary),#7c3aed);" onclick="endBattle(false)">Continue</button>
    `;
    player.hp -= 1;
    document.getElementById('hud-hp').textContent = player.hp;
    if (player.hp <= 0) {
      player.alive = false;
    }
  }

  updateAliveCount();
}

function endBattle(won) {
  const overlay = document.getElementById('battle-overlay');
  overlay.classList.remove('active');

  // Reset VS display for next battle
  document.getElementById('battle-vs').style.display = '';
  document.getElementById('battle-combat-zone').style.display = 'none';
  document.getElementById('battle-result').classList.remove('active');
  document.getElementById('battle-result').innerHTML = '';

  // Reset battle UI overlays
  document.getElementById('bc-hp-container').classList.remove('active');
  document.getElementById('bc-mana-container').classList.remove('active');
  document.getElementById('bc-action-container').classList.remove('active');
  document.querySelectorAll('#battle-viewport .fireball').forEach(f => f.remove());

  // Clear model src to free memory
  const mv = document.getElementById('arena-battle-model');
  if (mv) mv.removeAttribute('src');

  // Brief invincibility after battle
  const now = Date.now();
  player.invincibleUntil = now + 2000;
  if (battleState && battleState.opponent) {
    battleState.opponent.invincibleUntil = now + 2000;
  }

  // Cleanup all combat state
  if (combat) {
    clearInterval(combat.autoAttackTimer);
    clearInterval(combat.botAttackTimer);
    clearInterval(combat.timerInterval);
    clearTimeout(combat.superTimeout);
    combat = null;
  }
  battleState = null;

  if (!player.alive) {
    gameState = 'gameover';
    showGameOver();
  } else {
    gameState = 'playing';
    document.getElementById('dpad-hint').style.display = '';
    document.getElementById('action-zone').style.display = '';
  }
}

function resolveBotBattle(bot1, bot2) {
  // Simple resolution based on fitness levels
  const score1 = (bot1.fitnessLevel || 50) + Math.random() * 40;
  const score2 = (bot2.fitnessLevel || 50) + Math.random() * 40;

  const winner = score1 > score2 ? bot1 : bot2;
  const loser = score1 > score2 ? bot2 : bot1;

  loser.hp -= 1;
  if (loser.hp <= 0) {
    loser.alive = false;
    eliminationOrder.push(loser.name);
  }

  // Invincibility
  const now = Date.now();
  bot1.invincibleUntil = now + 2000;
  bot2.invincibleUntil = now + 2000;

  // Particles at battle site
  for (let i = 0; i < 6; i++) {
    particles.push({
      x: (bot1.x + bot2.x) / 2,
      y: (bot1.y + bot2.y) / 2,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      life: 1,
      color: '#fbbf24',
      size: 3 + Math.random() * 2,
    });
  }

  updateAliveCount();
}

function updateAliveCount() {
  const alive = 1 + bots.filter(b => b.alive).length;
  document.getElementById('alive-count').textContent = alive;
}

// â”€â”€ CAMERA â”€â”€
function updateCamera() {
  if (!player) return;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  camera.x = player.x - vw / 2;
  camera.y = player.y - vh / 2;
  camera.x = Math.max(0, Math.min(ARENA_W - vw, camera.x));
  camera.y = Math.max(0, Math.min(ARENA_H - vh, camera.y));
}

// â”€â”€ GAME OVER â”€â”€
function checkGameOver() {
  if (!player || !player.alive) return;
  const aliveCount = bots.filter(b => b.alive).length;
  if (aliveCount === 0) {
    gameState = 'gameover';
    showGameOver();
  }
}

function showGameOver() {
  const overlay = document.getElementById('gameover-overlay');
  overlay.classList.add('active');

  const aliveCount = bots.filter(b => b.alive).length;
  const place = player.alive ? 1 : aliveCount + 2;
  const totalPlayers = playerCount;

  document.getElementById('gameover-place').textContent = `#${place}`;
  document.getElementById('gameover-place').className = `gameover-place ${place === 1 ? 'first' : ''}`;

  const labels = {
    1: 'Victory!',
    2: 'So Close!',
    3: 'Good Fight!',
  };
  document.getElementById('gameover-label').textContent = labels[place] || 'Eliminated';
  document.getElementById('gameover-sub').textContent = place === 1
    ? `You dominated the arena with ${player.kills} knockouts!`
    : `Eliminated in ${place}${place===2?'nd':place===3?'rd':'th'} place`;

  const coinReward = place === 1 ? 50 : place === 2 ? 25 : 10;
  const xpReward = place === 1 ? 25 : place === 2 ? 15 : 5;
  document.getElementById('gameover-coins').textContent = `+${coinReward}`;
  document.getElementById('gameover-xp').textContent = `+${xpReward}`;
}

function returnToLobby() {
  document.getElementById('gameover-overlay').classList.remove('active');
  document.getElementById('lobby').classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('players-alive').style.display = 'none';
  document.getElementById('action-zone').style.display = 'none';
  document.getElementById('dpad-hint').style.display = 'none';
  document.getElementById('powerup-active').innerHTML = '';
  gameState = 'lobby';
  player = null;
  bots = [];
  powerups = [];
  particles = [];
}

function exitArena() {
  if (window.history.length > 1) {
    window.history.back();
  } else {
    window.location.href = 'dashboard.html';
  }
}

// â”€â”€ ACTION BUTTON â”€â”€
function handleAction() {
  if (gameState !== 'playing' || !player || !player.alive) return;

  // Find nearest alive bot
  let nearest = null;
  let nearestDist = Infinity;
  bots.forEach(bot => {
    if (!bot.alive) return;
    const d = dist(player, bot);
    if (d < nearestDist) {
      nearestDist = d;
      nearest = bot;
    }
  });

  if (nearest && nearestDist < 120) {
    showNotification(`${nearest.name} is nearby! Get closer to battle!`);
  } else {
    // Scan - reveal nearest player direction briefly
    if (nearest) {
      const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      const dirs = ['East', 'South', 'West', 'North'];
      const dirIdx = Math.round(((angle + Math.PI) / (Math.PI * 2)) * 4) % 4;
      showNotification(`Nearest fighter: ${Math.round(nearestDist)}m to the ${dirs[dirIdx]}`);
    }
  }
}

// â”€â”€ NOTIFICATIONS â”€â”€
function showNotification(text) {
  // Remove existing
  document.querySelectorAll('.arena-notification').forEach(n => n.remove());

  const notif = document.createElement('div');
  notif.className = 'arena-notification';
  notif.textContent = text;
  document.body.appendChild(notif);
  setTimeout(() => notif.remove(), 3000);
}

// â”€â”€ RENDER â”€â”€
function render() {
  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

  if (gameState === 'lobby') return;

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  drawArenaBackground();
  drawObstacles();
  drawPowerups();
  drawEntities();
  drawParticles();

  // Mini-map
  ctx.restore();
  drawMinimap();

  // Update action button state
  updateActionButton();
}

function drawArenaBackground() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  // Dark void outside rooms - space/stars feel
  ctx.fillStyle = '#050810';
  ctx.fillRect(vx, vy, vw, vh);

  // Subtle star-like dots in the void (seeded by position for consistency)
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  const starSpacing = 80;
  const sx0 = Math.floor(vx / starSpacing) * starSpacing;
  const sy0 = Math.floor(vy / starSpacing) * starSpacing;
  for (let sy = sy0; sy < vy + vh; sy += starSpacing) {
    for (let sx = sx0; sx < vx + vw; sx += starSpacing) {
      // Only draw outside rooms
      const inRoom = ROOMS.some(rm => sx >= rm.x && sx <= rm.x + rm.w && sy >= rm.y && sy <= rm.y + rm.h);
      if (!inRoom) {
        const hash = ((sx * 7919 + sy * 6271) & 0xFFFF) / 65535;
        if (hash < 0.35) {
          ctx.beginPath();
          ctx.arc(sx + hash * 30, sy + hash * 20, 0.5 + hash, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Draw room floors with per-room patterns
  ROOMS.forEach(rm => {
    // Skip if off-screen
    if (rm.x + rm.w < vx || rm.x > vx + vw || rm.y + rm.h < vy || rm.y > vy + vh) return;

    // Base room floor
    ctx.fillStyle = rm.floor;
    ctx.fillRect(rm.x, rm.y, rm.w, rm.h);

    // Per-room floor pattern
    const TILE = 40;
    const startCol = Math.max(0, Math.floor((vx - rm.x) / TILE));
    const endCol = Math.min(Math.ceil(rm.w / TILE), Math.ceil((vx + vw - rm.x) / TILE) + 1);
    const startRow = Math.max(0, Math.floor((vy - rm.y) / TILE));
    const endRow = Math.min(Math.ceil(rm.h / TILE), Math.ceil((vy + vh - rm.y) / TILE) + 1);

    switch (rm.floorType) {
      case 'checker-tile': {
        // Kitchen: large checkered tiles with grout lines
        for (let r = startRow; r < endRow; r++) {
          for (let c = startCol; c < endCol; c++) {
            const tx = rm.x + c * TILE, ty = rm.y + r * TILE;
            const tw = Math.min(TILE, rm.x + rm.w - tx), th = Math.min(TILE, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            ctx.fillStyle = (r + c) % 2 === 0 ? rm.tileColor1 : rm.tileColor2;
            ctx.fillRect(tx, ty, tw, th);
            // Grout lines
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(tx, ty, tw, th);
          }
        }
        // Subtle floor shine
        ctx.fillStyle = 'rgba(255,255,255,0.008)';
        ctx.fillRect(rm.x, rm.y, rm.w * 0.6, rm.h * 0.4);
        break;
      }
      case 'linoleum': {
        // Cafeteria: smooth speckled linoleum
        for (let r = startRow; r < endRow; r++) {
          for (let c = startCol; c < endCol; c++) {
            const tx = rm.x + c * TILE, ty = rm.y + r * TILE;
            const tw = Math.min(TILE, rm.x + rm.w - tx), th = Math.min(TILE, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            ctx.fillStyle = (r + c) % 2 === 0 ? rm.tileColor1 : rm.tileColor2;
            ctx.fillRect(tx, ty, tw, th);
            // Speckles
            const hash = ((c * 3917 + r * 2741) & 0xFFFF) / 65535;
            ctx.fillStyle = 'rgba(200,180,255,0.015)';
            for (let s = 0; s < 3; s++) {
              const spx = tx + ((hash * 1000 + s * 13) % TILE);
              const spy = ty + ((hash * 700 + s * 17) % TILE);
              ctx.fillRect(spx, spy, 2, 2);
            }
          }
        }
        break;
      }
      case 'wood': {
        // Living Room: hardwood plank flooring
        const plankW = 80, plankH = 20;
        const pc0 = Math.max(0, Math.floor((vx - rm.x) / plankW));
        const pc1 = Math.min(Math.ceil(rm.w / plankW), Math.ceil((vx + vw - rm.x) / plankW) + 1);
        const pr0 = Math.max(0, Math.floor((vy - rm.y) / plankH));
        const pr1 = Math.min(Math.ceil(rm.h / plankH), Math.ceil((vy + vh - rm.y) / plankH) + 1);
        for (let r = pr0; r < pr1; r++) {
          for (let c = pc0; c < pc1; c++) {
            const offset = (r % 2) * (plankW / 2);
            const tx = rm.x + c * plankW + offset, ty = rm.y + r * plankH;
            if (tx + plankW < rm.x || tx > rm.x + rm.w) continue;
            const clampX = Math.max(tx, rm.x);
            const clampW = Math.min(tx + plankW, rm.x + rm.w) - clampX;
            const clampY = Math.max(ty, rm.y);
            const clampH = Math.min(ty + plankH, rm.y + rm.h) - clampY;
            if (clampW <= 0 || clampH <= 0) continue;
            const hash = ((c * 5119 + r * 3331) & 0xFF) / 255;
            const shade = 0.02 + hash * 0.02;
            ctx.fillStyle = (r + c) % 3 === 0 ? rm.tileColor1 : rm.tileColor2;
            ctx.fillRect(clampX, clampY, clampW, clampH);
            // Wood grain line
            ctx.strokeStyle = `rgba(255,255,255,${shade})`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(clampX + 2, clampY + plankH * 0.5);
            ctx.lineTo(clampX + clampW - 2, clampY + plankH * 0.5);
            ctx.stroke();
            // Plank gap
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(clampX, clampY, clampW, clampH);
          }
        }
        break;
      }
      case 'small-tile': {
        // Bathroom: small hexagonal-feel tiles
        const sTile = 24;
        const sc2 = Math.max(0, Math.floor((vx - rm.x) / sTile));
        const ec2 = Math.min(Math.ceil(rm.w / sTile), Math.ceil((vx + vw - rm.x) / sTile) + 1);
        const sr2 = Math.max(0, Math.floor((vy - rm.y) / sTile));
        const er2 = Math.min(Math.ceil(rm.h / sTile), Math.ceil((vy + vh - rm.y) / sTile) + 1);
        for (let r = sr2; r < er2; r++) {
          for (let c = sc2; c < ec2; c++) {
            const tx = rm.x + c * sTile, ty = rm.y + r * sTile;
            const tw = Math.min(sTile, rm.x + rm.w - tx), th = Math.min(sTile, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            const isAlt = (r + c) % 3 === 0;
            ctx.fillStyle = isAlt ? '#1a2a2c' : rm.tileColor1;
            ctx.fillRect(tx, ty, tw, th);
            ctx.strokeStyle = 'rgba(100,180,200,0.04)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(tx, ty, tw, th);
          }
        }
        // Wet floor reflections
        ctx.fillStyle = 'rgba(100,200,255,0.01)';
        ctx.beginPath();
        ctx.ellipse(rm.x + rm.w * 0.3, rm.y + rm.h * 0.6, 80, 40, 0.2, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'metal': {
        // Hallway: industrial metal grate feel
        const mTile = 50;
        const mc0 = Math.max(0, Math.floor((vx - rm.x) / mTile));
        const mc1 = Math.min(Math.ceil(rm.w / mTile), Math.ceil((vx + vw - rm.x) / mTile) + 1);
        const mr0 = Math.max(0, Math.floor((vy - rm.y) / mTile));
        const mr1 = Math.min(Math.ceil(rm.h / mTile), Math.ceil((vy + vh - rm.y) / mTile) + 1);
        for (let r = mr0; r < mr1; r++) {
          for (let c = mc0; c < mc1; c++) {
            const tx = rm.x + c * mTile, ty = rm.y + r * mTile;
            const tw = Math.min(mTile, rm.x + rm.w - tx), th = Math.min(mTile, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            ctx.fillStyle = (r + c) % 2 === 0 ? rm.tileColor1 : rm.tileColor2;
            ctx.fillRect(tx, ty, tw, th);
            // Metal plate rivets at corners
            ctx.fillStyle = 'rgba(255,255,255,0.04)';
            ctx.beginPath(); ctx.arc(tx + 4, ty + 4, 1.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(tx + tw - 4, ty + 4, 1.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(tx + 4, ty + th - 4, 1.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(tx + tw - 4, ty + th - 4, 1.5, 0, Math.PI * 2); ctx.fill();
            // Plate seams
            ctx.strokeStyle = 'rgba(255,255,255,0.02)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(tx + 1, ty + 1, tw - 2, th - 2);
          }
        }
        // Floor stripe markings
        ctx.fillStyle = 'rgba(255,200,0,0.04)';
        ctx.fillRect(rm.x + 30, rm.y + rm.h / 2 - 15, rm.w - 60, 30);
        ctx.strokeStyle = 'rgba(255,200,0,0.06)';
        ctx.lineWidth = 1;
        ctx.setLineDash([20, 15]);
        ctx.beginPath();
        ctx.moveTo(rm.x + 40, rm.y + rm.h / 2);
        ctx.lineTo(rm.x + rm.w - 40, rm.y + rm.h / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        break;
      }
      case 'carpet': {
        // Bedroom: soft carpet texture
        ctx.fillStyle = rm.tileColor1;
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        // Carpet texture dots
        ctx.fillStyle = 'rgba(255,255,255,0.01)';
        const dotSpacing = 8;
        const dx0 = Math.floor((vx - rm.x) / dotSpacing) * dotSpacing;
        const dy0 = Math.floor((vy - rm.y) / dotSpacing) * dotSpacing;
        for (let dy = Math.max(0, dy0); dy < Math.min(rm.h, vy + vh - rm.y); dy += dotSpacing) {
          for (let dx = Math.max(0, dx0); dx < Math.min(rm.w, vx + vw - rm.x); dx += dotSpacing) {
            ctx.fillRect(rm.x + dx, rm.y + dy, 1, 1);
          }
        }
        // Carpet edge border
        ctx.strokeStyle = rm.trimColor + '30';
        ctx.lineWidth = 4;
        ctx.strokeRect(rm.x + 20, rm.y + 20, rm.w - 40, rm.h - 40);
        break;
      }
      case 'rubber': {
        // Gym: rubber mat flooring with diamond pattern
        const rTile = 36;
        const rc0 = Math.max(0, Math.floor((vx - rm.x) / rTile));
        const rc1 = Math.min(Math.ceil(rm.w / rTile), Math.ceil((vx + vw - rm.x) / rTile) + 1);
        const rr0 = Math.max(0, Math.floor((vy - rm.y) / rTile));
        const rr1 = Math.min(Math.ceil(rm.h / rTile), Math.ceil((vy + vh - rm.y) / rTile) + 1);
        for (let r = rr0; r < rr1; r++) {
          for (let c = rc0; c < rc1; c++) {
            const tx = rm.x + c * rTile, ty = rm.y + r * rTile;
            const tw = Math.min(rTile, rm.x + rm.w - tx), th = Math.min(rTile, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            ctx.fillStyle = (r + c) % 2 === 0 ? rm.tileColor1 : rm.tileColor2;
            ctx.fillRect(tx, ty, tw, th);
            // Diamond grip pattern
            ctx.strokeStyle = 'rgba(255,200,100,0.02)';
            ctx.lineWidth = 0.5;
            const mid = rTile / 2;
            ctx.beginPath();
            ctx.moveTo(tx + mid, ty + 2); ctx.lineTo(tx + rTile - 2, ty + mid);
            ctx.lineTo(tx + mid, ty + rTile - 2); ctx.lineTo(tx + 2, ty + mid);
            ctx.closePath(); ctx.stroke();
          }
        }
        break;
      }
      case 'grass': {
        // Garden: grass with dirt patches and flower spots
        ctx.fillStyle = rm.tileColor1;
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        // Grass blades (subtle texture)
        ctx.fillStyle = 'rgba(100,200,100,0.03)';
        const gSpacing = 12;
        const gx0 = Math.floor((vx - rm.x) / gSpacing) * gSpacing;
        const gy0 = Math.floor((vy - rm.y) / gSpacing) * gSpacing;
        for (let gy = Math.max(0, gy0); gy < Math.min(rm.h, vy + vh - rm.y); gy += gSpacing) {
          for (let gx = Math.max(0, gx0); gx < Math.min(rm.w, vx + vw - rm.x); gx += gSpacing) {
            const hash = ((gx * 7 + gy * 13) & 0xFF) / 255;
            if (hash < 0.4) {
              ctx.fillStyle = hash < 0.2 ? 'rgba(80,180,80,0.04)' : 'rgba(60,150,60,0.03)';
              ctx.fillRect(rm.x + gx, rm.y + gy, 2, 4 + hash * 4);
            }
          }
        }
        // Stone path down the middle
        ctx.fillStyle = 'rgba(120,110,100,0.08)';
        for (let py = 0; py < rm.h; py += 50) {
          const offset = (Math.floor(py / 50) % 2) * 15;
          ctx.beginPath();
          ctx.ellipse(rm.x + rm.w * 0.5 + offset, rm.y + py + 25, 22, 14, 0.1, 0, Math.PI * 2);
          ctx.fill();
        }
        // Dirt patches
        ctx.fillStyle = 'rgba(80,60,40,0.06)';
        ctx.beginPath(); ctx.ellipse(rm.x + rm.w * 0.2, rm.y + rm.h * 0.3, 50, 30, 0.3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(rm.x + rm.w * 0.8, rm.y + rm.h * 0.7, 40, 25, -0.2, 0, Math.PI * 2); ctx.fill();
        break;
      }
      case 'concrete': {
        // Garage: rough concrete with oil stains and cracks
        ctx.fillStyle = rm.tileColor1;
        ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
        // Concrete texture variation
        for (let r = startRow; r < endRow; r++) {
          for (let c = startCol; c < endCol; c++) {
            const tx = rm.x + c * TILE, ty = rm.y + r * TILE;
            const tw = Math.min(TILE, rm.x + rm.w - tx), th = Math.min(TILE, rm.y + rm.h - ty);
            if (tw <= 0 || th <= 0) continue;
            const hash = ((c * 6131 + r * 4217) & 0xFF) / 255;
            if (hash > 0.7) {
              ctx.fillStyle = 'rgba(255,255,255,0.01)';
              ctx.fillRect(tx, ty, tw, th);
            }
          }
        }
        // Oil stains
        ctx.fillStyle = 'rgba(30,20,10,0.12)';
        ctx.beginPath(); ctx.ellipse(rm.x + rm.w * 0.35, rm.y + rm.h * 0.5, 60, 35, 0.3, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(20,15,5,0.08)';
        ctx.beginPath(); ctx.ellipse(rm.x + rm.w * 0.7, rm.y + rm.h * 0.3, 45, 25, -0.4, 0, Math.PI * 2); ctx.fill();
        // Crack lines
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(rm.x + rm.w * 0.2, rm.y + rm.h * 0.1);
        ctx.lineTo(rm.x + rm.w * 0.25, rm.y + rm.h * 0.3);
        ctx.lineTo(rm.x + rm.w * 0.22, rm.y + rm.h * 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rm.x + rm.w * 0.6, rm.y + rm.h * 0.7);
        ctx.lineTo(rm.x + rm.w * 0.65, rm.y + rm.h * 0.85);
        ctx.lineTo(rm.x + rm.w * 0.7, rm.y + rm.h * 0.9);
        ctx.stroke();
        break;
      }
    }

    // Room label (larger, more atmospheric)
    ctx.save();
    ctx.font = '800 18px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.letterSpacing = '4px';
    ctx.fillText(rm.name.toUpperCase(), rm.x + rm.w / 2, rm.y + rm.h / 2);
    ctx.restore();

    // Room edge ambient glow (inner shadow)
    const glowGrad = ctx.createRadialGradient(
      rm.x + rm.w / 2, rm.y + rm.h / 2, Math.min(rm.w, rm.h) * 0.3,
      rm.x + rm.w / 2, rm.y + rm.h / 2, Math.max(rm.w, rm.h) * 0.6
    );
    glowGrad.addColorStop(0, 'rgba(0,0,0,0)');
    glowGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(rm.x, rm.y, rm.w, rm.h);
  });

  // Draw floor decorations (non-collision)
  drawFloorDecorations();

  // Draw ambient room details (pipes, wiring, wall decorations)
  drawAmbientDetails();

  // Outer arena border with glow
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 4;
  ctx.strokeRect(20, 20, ARENA_W - 40, ARENA_H - 40);
  ctx.strokeStyle = 'rgba(16,185,129,0.06)';
  ctx.lineWidth = 8;
  ctx.strokeRect(16, 16, ARENA_W - 32, ARENA_H - 32);
}

function drawFloorDecorations() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  FLOOR_DECORATIONS.forEach(d => {
    if (d.x + (d.w || 60) < vx - 20 || d.x > vx + vw + 20 ||
        d.y + (d.h || 60) < vy - 20 || d.y > vy + vh + 20) return;

    switch (d.type) {
      case 'rug': {
        ctx.fillStyle = d.color || 'rgba(100,50,50,0.15)';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 4); ctx.fill();
        // Rug border
        ctx.strokeStyle = d.border || 'rgba(150,80,80,0.12)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(d.x + 4, d.y + 4, d.w - 8, d.h - 8, 3); ctx.stroke();
        // Rug pattern - center diamond
        ctx.strokeStyle = d.border || 'rgba(150,80,80,0.08)';
        ctx.lineWidth = 1;
        const cx = d.x + d.w / 2, cy = d.y + d.h / 2;
        ctx.beginPath();
        ctx.moveTo(cx, d.y + 12); ctx.lineTo(d.x + d.w - 12, cy);
        ctx.lineTo(cx, d.y + d.h - 12); ctx.lineTo(d.x + 12, cy);
        ctx.closePath(); ctx.stroke();
        break;
      }
      case 'vent': {
        ctx.fillStyle = '#141418';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 3); ctx.fill();
        // Grate lines
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        const slats = Math.floor(d.w / 8);
        for (let i = 1; i < slats; i++) {
          ctx.beginPath();
          ctx.moveTo(d.x + i * (d.w / slats), d.y + 2);
          ctx.lineTo(d.x + i * (d.w / slats), d.y + d.h - 2);
          ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 3); ctx.stroke();
        // Screws
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath(); ctx.arc(d.x + 4, d.y + 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + d.w - 4, d.y + 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + 4, d.y + d.h - 4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(d.x + d.w - 4, d.y + d.h - 4, 2, 0, Math.PI * 2); ctx.fill();
        break;
      }
      case 'floor-mark': {
        ctx.fillStyle = d.color || 'rgba(255,200,0,0.05)';
        ctx.fillRect(d.x, d.y, d.w, d.h);
        break;
      }
      case 'puddle': {
        ctx.fillStyle = 'rgba(80,160,220,0.06)';
        ctx.beginPath();
        ctx.ellipse(d.x + d.w / 2, d.y + d.h / 2, d.w / 2, d.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        // Reflection highlight
        ctx.fillStyle = 'rgba(150,220,255,0.04)';
        ctx.beginPath();
        ctx.ellipse(d.x + d.w * 0.4, d.y + d.h * 0.35, d.w * 0.2, d.h * 0.15, 0.3, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'mat': {
        ctx.fillStyle = d.color || 'rgba(60,60,60,0.15)';
        ctx.beginPath(); ctx.roundRect(d.x, d.y, d.w, d.h, 2); ctx.fill();
        break;
      }
      case 'drain': {
        ctx.fillStyle = '#101014';
        ctx.beginPath();
        ctx.arc(d.x + d.w / 2, d.y + d.h / 2, d.w / 2, 0, Math.PI * 2);
        ctx.fill();
        // Drain cross
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        const dcx = d.x + d.w / 2, dcy = d.y + d.h / 2, dr = d.w / 2 - 3;
        ctx.beginPath(); ctx.moveTo(dcx - dr, dcy); ctx.lineTo(dcx + dr, dcy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(dcx, dcy - dr); ctx.lineTo(dcx, dcy + dr); ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.beginPath(); ctx.arc(dcx, dcy, d.w / 2, 0, Math.PI * 2); ctx.stroke();
        break;
      }
      case 'cable': {
        ctx.strokeStyle = d.color || 'rgba(200,50,50,0.12)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.5, d.y + d.h, d.x + d.w, d.y + d.h * 0.3);
        ctx.stroke();
        break;
      }
      case 'tire-marks': {
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.3, d.y + d.h * 0.5, d.x + d.w, d.y + d.h);
        ctx.stroke();
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(d.x + 14, d.y);
        ctx.quadraticCurveTo(d.x + d.w * 0.3 + 14, d.y + d.h * 0.5, d.x + d.w + 14, d.y + d.h);
        ctx.stroke();
        break;
      }
      case 'warning-stripes': {
        ctx.save();
        ctx.beginPath();
        ctx.rect(d.x, d.y, d.w, d.h);
        ctx.clip();
        const stripeW = 12;
        ctx.fillStyle = 'rgba(255,200,0,0.06)';
        for (let sx = d.x - d.h; sx < d.x + d.w + d.h; sx += stripeW * 2) {
          ctx.beginPath();
          ctx.moveTo(sx, d.y + d.h);
          ctx.lineTo(sx + d.h, d.y);
          ctx.lineTo(sx + d.h + stripeW, d.y);
          ctx.lineTo(sx + stripeW, d.y + d.h);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
        break;
      }
    }
  });
}

function drawAmbientDetails() {
  const vx = camera.x, vy = camera.y;
  const vw = window.innerWidth, vh = window.innerHeight;

  ROOMS.forEach(rm => {
    if (rm.x + rm.w < vx - 20 || rm.x > vx + vw + 20 ||
        rm.y + rm.h < vy - 20 || rm.y > vy + vh + 20) return;

    ctx.save();
    // Clip to room bounds to keep details contained
    ctx.beginPath();
    ctx.rect(rm.x, rm.y, rm.w, rm.h);
    ctx.clip();

    switch (rm.name) {
      case 'Kitchen': {
        // Pipe along top wall
        ctx.strokeStyle = 'rgba(120,120,130,0.12)'; ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(rm.x + 20, rm.y + 30);
        ctx.lineTo(rm.x + rm.w - 20, rm.y + 30);
        ctx.stroke();
        // Pipe joints
        ctx.fillStyle = 'rgba(140,140,150,0.1)';
        for (let px = rm.x + 200; px < rm.x + rm.w; px += 300) {
          ctx.beginPath(); ctx.arc(px, rm.y + 30, 5, 0, Math.PI * 2); ctx.fill();
        }
        // Small floor tiles pattern highlight
        ctx.fillStyle = 'rgba(200,255,200,0.008)';
        ctx.fillRect(rm.x + 250, rm.y + 300, 400, 300);
        break;
      }
      case 'Cafeteria': {
        // Overhead light fixtures (circles on ceiling)
        ctx.fillStyle = 'rgba(255,240,200,0.025)';
        for (let lx = rm.x + 200; lx < rm.x + rm.w - 100; lx += 350) {
          ctx.beginPath(); ctx.arc(lx, rm.y + rm.h / 2, 80, 0, Math.PI * 2); ctx.fill();
        }
        // Serving line marking on floor
        ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.moveTo(rm.x + 100, rm.y + rm.h * 0.85);
        ctx.lineTo(rm.x + rm.w - 100, rm.y + rm.h * 0.85);
        ctx.stroke();
        ctx.setLineDash([]);
        break;
      }
      case 'Living Room': {
        // Picture frames on walls (simulated)
        const frameColors = ['rgba(180,140,80,0.06)', 'rgba(100,120,160,0.06)', 'rgba(160,100,80,0.06)'];
        for (let fi = 0; fi < 3; fi++) {
          ctx.fillStyle = frameColors[fi];
          ctx.beginPath();
          ctx.roundRect(rm.x + 80 + fi * 250, rm.y + 60, 50, 35, 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(180,140,80,0.08)'; ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(rm.x + 80 + fi * 250, rm.y + 60, 50, 35, 2);
          ctx.stroke();
        }
        // Warm light pool from lamp
        ctx.fillStyle = 'rgba(255,220,150,0.015)';
        ctx.beginPath();
        ctx.ellipse(rm.x + 80, rm.y + 120, 60, 60, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'Bathroom': {
        // Tile grout pattern on walls (lighter strip at top)
        ctx.fillStyle = 'rgba(100,200,220,0.01)';
        ctx.fillRect(rm.x, rm.y + 20, rm.w, 40);
        // Pipe running along bottom
        ctx.strokeStyle = 'rgba(160,160,170,0.08)'; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(rm.x + 20, rm.y + rm.h - 25);
        ctx.lineTo(rm.x + rm.w * 0.6, rm.y + rm.h - 25);
        ctx.stroke();
        // Pipe elbow
        ctx.beginPath();
        ctx.arc(rm.x + rm.w * 0.6, rm.y + rm.h - 45, 20, Math.PI * 0.5, Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rm.x + rm.w * 0.6 - 20, rm.y + rm.h - 45);
        ctx.lineTo(rm.x + rm.w * 0.6 - 20, rm.y + 60);
        ctx.stroke();
        break;
      }
      case 'Hallway': {
        // Overhead strip lights
        ctx.fillStyle = 'rgba(200,220,255,0.015)';
        ctx.fillRect(rm.x + 50, rm.y + rm.h * 0.45, rm.w - 100, rm.h * 0.1);
        // Conduit/wire run along ceiling
        ctx.strokeStyle = 'rgba(100,100,120,0.06)'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(rm.x + 20, rm.y + 25);
        ctx.lineTo(rm.x + rm.w - 20, rm.y + 25);
        ctx.stroke();
        // Pipe along bottom
        ctx.strokeStyle = 'rgba(120,120,130,0.06)'; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(rm.x + 20, rm.y + rm.h - 20);
        ctx.lineTo(rm.x + rm.w - 20, rm.y + rm.h - 20);
        ctx.stroke();
        // Arrow floor markings
        ctx.fillStyle = 'rgba(255,255,255,0.015)';
        for (let ax = rm.x + 300; ax < rm.x + rm.w - 200; ax += 400) {
          ctx.beginPath();
          ctx.moveTo(ax, rm.y + rm.h / 2 - 8);
          ctx.lineTo(ax + 20, rm.y + rm.h / 2);
          ctx.lineTo(ax, rm.y + rm.h / 2 + 8);
          ctx.closePath(); ctx.fill();
        }
        break;
      }
      case 'Bedroom': {
        // Warm ambient glow from window (simulated)
        ctx.fillStyle = 'rgba(200,180,255,0.01)';
        ctx.beginPath();
        ctx.ellipse(rm.x + rm.w * 0.8, rm.y + rm.h * 0.3, 100, 80, 0, 0, Math.PI * 2);
        ctx.fill();
        // Wall poster (abstract)
        ctx.fillStyle = 'rgba(100,60,120,0.06)';
        ctx.beginPath(); ctx.roundRect(rm.x + rm.w * 0.1, rm.y + 50, 60, 45, 2); ctx.fill();
        ctx.strokeStyle = 'rgba(140,80,160,0.08)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.roundRect(rm.x + rm.w * 0.1, rm.y + 50, 60, 45, 2); ctx.stroke();
        break;
      }
      case 'Gym': {
        // Floor line markings for exercise zones
        ctx.strokeStyle = 'rgba(255,200,0,0.03)'; ctx.lineWidth = 2;
        // Dashed boundary
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.roundRect(rm.x + 140, rm.y + 80, 500, 200, 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.roundRect(rm.x + 140, rm.y + 350, 500, 300, 4);
        ctx.stroke();
        ctx.setLineDash([]);
        // Zone labels
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.font = '10px Inter'; ctx.textAlign = 'center';
        ctx.fillText('WEIGHTS', rm.x + 390, rm.y + 180);
        ctx.fillText('CARDIO', rm.x + 390, rm.y + 500);
        // Rubber mat at entrance
        ctx.fillStyle = 'rgba(80,60,40,0.06)';
        ctx.beginPath(); ctx.roundRect(rm.x + rm.w - 80, rm.y + rm.h / 2 - 40, 70, 80, 3); ctx.fill();
        break;
      }
      case 'Garden': {
        // Sunlight dappling effect
        ctx.fillStyle = 'rgba(255,255,200,0.012)';
        for (let i = 0; i < 6; i++) {
          const gx2 = rm.x + 100 + (i * 197 % rm.w);
          const gy2 = rm.y + 100 + (i * 131 % rm.h);
          ctx.beginPath();
          ctx.ellipse(gx2, gy2, 30 + i * 8, 20 + i * 5, i * 0.3, 0, Math.PI * 2);
          ctx.fill();
        }
        // Garden border/fence posts (decorative)
        ctx.fillStyle = 'rgba(120,100,80,0.04)';
        for (let fp = rm.x + 60; fp < rm.x + rm.w - 40; fp += 80) {
          ctx.fillRect(fp, rm.y + 25, 4, 20);
        }
        // Fence rail
        ctx.strokeStyle = 'rgba(120,100,80,0.04)'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(rm.x + 60, rm.y + 35);
        ctx.lineTo(rm.x + rm.w - 40, rm.y + 35);
        ctx.stroke();
        break;
      }
      case 'Garage': {
        // Overhead fluorescent light
        ctx.fillStyle = 'rgba(255,255,240,0.015)';
        ctx.fillRect(rm.x + rm.w * 0.2, rm.y + 30, rm.w * 0.6, 6);
        // Light pool
        ctx.fillStyle = 'rgba(255,255,240,0.01)';
        ctx.beginPath();
        ctx.ellipse(rm.x + rm.w * 0.5, rm.y + rm.h * 0.5, rm.w * 0.3, rm.h * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();
        // Tool shadow on wall (implied pegboard)
        ctx.fillStyle = 'rgba(80,80,80,0.03)';
        ctx.fillRect(rm.x + rm.w - 100, rm.y + 25, 80, 60);
        // Small dots (pegboard holes)
        ctx.fillStyle = 'rgba(0,0,0,0.03)';
        for (let py2 = rm.y + 30; py2 < rm.y + 80; py2 += 10) {
          for (let px2 = rm.x + rm.w - 95; px2 < rm.x + rm.w - 25; px2 += 10) {
            ctx.beginPath(); ctx.arc(px2, py2, 1, 0, Math.PI * 2); ctx.fill();
          }
        }
        break;
      }
    }

    ctx.restore();
  });
}

function getWallRoomColor(ox, oy) {
  // Find which room this wall belongs to based on proximity
  let best = null, bestDist = Infinity;
  ROOMS.forEach(rm => {
    const cx = rm.x + rm.w / 2, cy = rm.y + rm.h / 2;
    const d = Math.abs(ox + 8 - cx) + Math.abs(oy + 8 - cy);
    if (d < bestDist) { bestDist = d; best = rm; }
  });
  return best;
}

function drawObstacles() {
  MAP_OBSTACLES.forEach(o => {
    // Frustum culling
    if (o.x + o.w < camera.x - 20 || o.x > camera.x + window.innerWidth + 20 ||
        o.y + o.h < camera.y - 20 || o.y > camera.y + window.innerHeight + 20) return;

    if (o.type === 'wall') {
      const rm = getWallRoomColor(o.x, o.y);
      const wallBase = rm ? rm.wallColor : '#1e2538';
      const wallLight = rm ? rm.wallHighlight : '#2a3548';
      const trim = rm ? rm.trimColor : '#4a6a88';

      // Wall shadow (depth effect)
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.roundRect(o.x + 2, o.y + 2, o.w, o.h, 3);
      ctx.fill();

      // Main wall body
      ctx.fillStyle = wallBase;
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 3);
      ctx.fill();

      // Wall top highlight (3D depth)
      ctx.fillStyle = wallLight;
      if (o.h <= WALL + 2) {
        // Horizontal wall - top face
        ctx.fillRect(o.x + 1, o.y, o.w - 2, 3);
      } else {
        // Vertical wall - left face
        ctx.fillRect(o.x, o.y + 1, 3, o.h - 2);
      }

      // Trim/baseboard accent
      ctx.fillStyle = trim + '30';
      if (o.h <= WALL + 2) {
        // Horizontal wall trim line
        ctx.fillRect(o.x, o.y + o.h - 2, o.w, 2);
      } else {
        // Vertical wall trim
        ctx.fillRect(o.x + o.w - 2, o.y, 2, o.h);
      }

      // Subtle texture on longer walls
      if (o.w > 100 || o.h > 100) {
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 0.5;
        if (o.w > o.h) {
          // Horizontal wall - brick-like segments
          for (let bx = o.x + 30; bx < o.x + o.w - 10; bx += 40) {
            ctx.beginPath();
            ctx.moveTo(bx, o.y + 3);
            ctx.lineTo(bx, o.y + o.h - 3);
            ctx.stroke();
          }
        } else {
          // Vertical wall
          for (let by = o.y + 30; by < o.y + o.h - 10; by += 40) {
            ctx.beginPath();
            ctx.moveTo(o.x + 3, by);
            ctx.lineTo(o.x + o.w - 3, by);
            ctx.stroke();
          }
        }
      }

      // Edge outline
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.roundRect(o.x, o.y, o.w, o.h, 3);
      ctx.stroke();
    } else {
      drawFurnitureItem(o);
    }
  });
}

// â”€â”€ FURNITURE RENDERER (TOP-DOWN SVG) â”€â”€
function drawFurnitureItem(o) {
  const x = o.x, y = o.y, w = o.w, h = o.h;
  ctx.save();

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.roundRect(x + 3, y + 3, w, h, 6);
  ctx.fill();

  switch (o.label) {

  // â”€â”€â”€ KITCHEN â”€â”€â”€
  case 'Stove': {
    // Dark metal body
    ctx.fillStyle = '#2a2a2e';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Metal texture
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(x + 2, y + 2, w - 4, h * 0.15);
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.stroke();
    // 4 burners (2x2 grid) with flame glow
    const bx = [x + w * 0.28, x + w * 0.72];
    const by = [y + h * 0.32, y + h * 0.72];
    bx.forEach((bcx, bi) => by.forEach((bcy, bj) => {
      // Burner grate
      ctx.strokeStyle = '#555'; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.arc(bcx, bcy, 12, 0, Math.PI * 2); ctx.stroke();
      // Inner ring
      ctx.strokeStyle = '#4a4a50'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(bcx, bcy, 7, 0, Math.PI * 2); ctx.stroke();
      // Flame glow (on first burner)
      if (bi === 0 && bj === 0) {
        ctx.fillStyle = 'rgba(100,150,255,0.08)';
        ctx.beginPath(); ctx.arc(bcx, bcy, 14, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(80,130,255,0.12)';
        ctx.beginPath(); ctx.arc(bcx, bcy, 8, 0, Math.PI * 2); ctx.fill();
      }
      ctx.fillStyle = '#3a3a40';
      ctx.beginPath(); ctx.arc(bcx, bcy, 3, 0, Math.PI * 2); ctx.fill();
      // Grate cross
      ctx.strokeStyle = '#505055'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(bcx - 10, bcy); ctx.lineTo(bcx + 10, bcy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(bcx, bcy - 10); ctx.lineTo(bcx, bcy + 10); ctx.stroke();
    }));
    // Control panel area
    ctx.fillStyle = '#222228';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h - 14, w - 8, 10, 2); ctx.fill();
    // Knobs with indicators
    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.arc(x + 18 + i * 22, y + h - 9, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#888';
      ctx.beginPath(); ctx.arc(x + 18 + i * 22, y + h - 9, 2, 0, Math.PI * 2); ctx.fill();
    }
    // Oven window
    ctx.fillStyle = '#1a1a20';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y + h - 12, w * 0.4, 8, 1); ctx.fill();
    break;
  }
  case 'Fridge': {
    // Tall silver body with gradient
    const frdGrd = ctx.createLinearGradient(x, y, x + w, y);
    frdGrd.addColorStop(0, '#b8c0c8');
    frdGrd.addColorStop(0.3, '#d0d8e0');
    frdGrd.addColorStop(0.7, '#c8d0d8');
    frdGrd.addColorStop(1, '#b0b8c0');
    ctx.fillStyle = frdGrd;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    // Door split (recessed line)
    ctx.strokeStyle = '#a0a0a0'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + 3, y + h * 0.4); ctx.lineTo(x + w - 3, y + h * 0.4); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x + 3, y + h * 0.4 + 1); ctx.lineTo(x + w - 3, y + h * 0.4 + 1); ctx.stroke();
    // Handles (sleek)
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.roundRect(x + w - 10, y + h * 0.15, 3, 20, 1); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 10, y + h * 0.55, 3, 20, 1); ctx.fill();
    // Top vent
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(x + 6, y + 3, w - 12, 2);
    // Fridge magnets (decorative)
    ctx.fillStyle = '#e53935';
    ctx.beginPath(); ctx.arc(x + 12, y + h * 0.2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#2196f3';
    ctx.beginPath(); ctx.roundRect(x + 8, y + h * 0.28, 12, 8, 1); ctx.fill();
    ctx.fillStyle = '#4caf50';
    ctx.beginPath(); ctx.arc(x + 18, y + h * 0.12, 3, 0, Math.PI * 2); ctx.fill();
    // Ice dispenser
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y + h * 0.5, w * 0.4, 10, 2); ctx.fill();
    ctx.fillStyle = '#666';
    ctx.beginPath(); ctx.roundRect(x + w * 0.35, y + h * 0.52, w * 0.3, 6, 1); ctx.fill();
    break;
  }
  case 'Counter': {
    // Wood top
    ctx.fillStyle = '#8B6914';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Surface highlight
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(x + 3, y + 3, w - 6, h * 0.3);
    ctx.strokeStyle = '#6B4F12'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    // Cabinet handles below
    for (let i = 0; i < Math.floor(w / 60); i++) {
      ctx.fillStyle = '#555';
      ctx.fillRect(x + 20 + i * 60, y + h - 8, 20, 3);
    }
    break;
  }
  case 'Sink': {
    // Counter body
    ctx.fillStyle = '#7a7a80';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Basin (dark oval)
    ctx.fillStyle = '#3a3a44';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h / 2, w * 0.32, h * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();
    // Faucet
    ctx.fillStyle = '#bbb';
    ctx.fillRect(x + w / 2 - 3, y + 4, 6, 12);
    ctx.beginPath(); ctx.arc(x + w / 2, y + 16, 4, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    break;
  }
  case 'Bin': {
    // Cylindrical bin
    ctx.fillStyle = '#4a4a4e';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, w * 0.3); ctx.fill();
    // Lid
    ctx.fillStyle = '#5a5a5e';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + 10, w * 0.42, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, w * 0.3); ctx.stroke();
    break;
  }

  // â”€â”€â”€ CAFETERIA â”€â”€â”€
  case 'Table': {
    // Wood table
    ctx.fillStyle = '#6B4F12';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 8); ctx.fill();
    // Surface
    ctx.fillStyle = '#8B6914';
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 6); ctx.fill();
    // Wood grain
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
      ctx.beginPath(); ctx.moveTo(x + 10, y + h * i / 4); ctx.lineTo(x + w - 10, y + h * i / 4); ctx.stroke();
    }
    // Chairs (small squares at sides)
    ctx.fillStyle = '#4a3a1a';
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y - 14, 20, 12, 3); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w * 0.6, y - 14, 20, 12, 3); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h + 2, 20, 12, 3); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w * 0.6, y + h + 2, 20, 12, 3); ctx.fill();
    break;
  }
  case 'Vending': {
    // Machine body
    ctx.fillStyle = '#b71c1c';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Glass panel with slight reflection
    const vgGrd = ctx.createLinearGradient(x + 8, y + 10, x + w - 8, y + 10);
    vgGrd.addColorStop(0, '#0d1b3e');
    vgGrd.addColorStop(0.5, '#152855');
    vgGrd.addColorStop(1, '#0d1b3e');
    ctx.fillStyle = vgGrd;
    ctx.beginPath(); ctx.roundRect(x + 6, y + 10, w - 12, h * 0.52, 3); ctx.fill();
    // Product rows with colorful items
    const vendColors = ['#e53935','#43a047','#1e88e5','#ffb300','#8e24aa','#00acc1'];
    for (let row = 0; row < 3; row++) {
      // Shelf
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(x + 10, y + 16 + row * 20, w - 20, 1);
      // Items
      for (let col = 0; col < 3; col++) {
        ctx.fillStyle = vendColors[(row * 3 + col) % vendColors.length];
        ctx.beginPath(); ctx.roundRect(x + 12 + col * 18, y + 18 + row * 20, 12, 14, 2); ctx.fill();
        // Label
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(x + 14 + col * 18, y + 24 + row * 20, 8, 3);
      }
    }
    // Selection buttons
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x + w - 18, y + 14, 10, h * 0.48, 2); ctx.fill();
    for (let i = 0; i < 5; i++) {
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.arc(x + w - 13, y + 22 + i * 12, 3, 0, Math.PI * 2); ctx.fill();
    }
    // Dispenser slot
    ctx.fillStyle = '#0a0a0a';
    ctx.beginPath(); ctx.roundRect(x + 10, y + h * 0.68, w - 20, 22, 4); ctx.fill();
    // Dispenser flap
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath(); ctx.roundRect(x + 14, y + h * 0.7, w - 28, 18, 2); ctx.fill();
    // Brand name area
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x + 8, y + h - 24, w - 16, 16, 2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 6px Inter'; ctx.textAlign = 'center';
    ctx.fillText('SNACKS', x + w / 2, y + h - 14);
    // Coin slot
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.roundRect(x + w - 16, y + h * 0.62, 6, 10, 2); ctx.fill();
    ctx.strokeStyle = '#8b0000'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.stroke();
    break;
  }

  // â”€â”€â”€ LIVING ROOM â”€â”€â”€
  case 'Couch': {
    // Base
    ctx.fillStyle = '#5c3d2e';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 10); ctx.fill();
    // Cushions
    ctx.fillStyle = '#7a4f3a';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w - 12, h - 16, 8); ctx.fill();
    // Back rest
    ctx.fillStyle = '#6a4232';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h - 14, w - 8, 12, 4); ctx.fill();
    // Cushion lines
    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
    const seats = 3;
    for (let i = 1; i < seats; i++) {
      ctx.beginPath(); ctx.moveTo(x + (w / seats) * i, y + 8); ctx.lineTo(x + (w / seats) * i, y + h - 18); ctx.stroke();
    }
    // Arm rests
    ctx.fillStyle = '#503020';
    ctx.beginPath(); ctx.roundRect(x, y, 10, h, 5); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 10, y, 10, h, 5); ctx.fill();
    break;
  }
  case 'TV': {
    // Screen glow on floor
    ctx.fillStyle = 'rgba(60,120,200,0.04)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h + 20, w * 0.8, 30, 0, 0, Math.PI * 2);
    ctx.fill();
    // Stand
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x + w * 0.45, y + h - 14, w * 0.1, 10);
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x + w * 0.25, y + h - 6, w * 0.5, 6, 2); ctx.fill();
    // Screen bezel
    ctx.fillStyle = '#0a0a0a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h - 10, 5); ctx.fill();
    // Screen with content
    const tvGrd = ctx.createLinearGradient(x, y, x + w, y + h * 0.7);
    tvGrd.addColorStop(0, '#102840');
    tvGrd.addColorStop(0.3, '#1a4060');
    tvGrd.addColorStop(0.7, '#0e2a48');
    tvGrd.addColorStop(1, '#081828');
    ctx.fillStyle = tvGrd;
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 18, 3); ctx.fill();
    // Fake scene content on TV
    ctx.fillStyle = 'rgba(80,160,80,0.1)';
    ctx.fillRect(x + 8, y + h * 0.5, w - 16, h * 0.2);
    ctx.fillStyle = 'rgba(200,150,80,0.06)';
    ctx.beginPath(); ctx.arc(x + w * 0.7, y + h * 0.3, 8, 0, Math.PI * 2); ctx.fill();
    // Screen reflection
    ctx.fillStyle = 'rgba(150,200,255,0.06)';
    ctx.beginPath();
    ctx.moveTo(x + 6, y + 6); ctx.lineTo(x + (w - 12) * 0.5, y + 6);
    ctx.lineTo(x + 6, y + (h - 22) * 0.5);
    ctx.closePath(); ctx.fill();
    // Power LED
    ctx.fillStyle = '#00ff44';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h - 14, 1.5, 0, Math.PI * 2); ctx.fill();
    // LED glow
    ctx.fillStyle = 'rgba(0,255,68,0.15)';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h - 14, 4, 0, Math.PI * 2); ctx.fill();
    break;
  }
  case 'Armchair': {
    ctx.fillStyle = '#5c3d2e';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 12); ctx.fill();
    // Cushion
    ctx.fillStyle = '#7a4f3a';
    ctx.beginPath(); ctx.roundRect(x + 10, y + 8, w - 20, h - 20, 8); ctx.fill();
    // Arms
    ctx.fillStyle = '#503020';
    ctx.beginPath(); ctx.roundRect(x, y + 4, 12, h - 8, 6); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 12, y + 4, 12, h - 8, 6); ctx.fill();
    break;
  }
  case 'Coffee Table': {
    ctx.fillStyle = '#5a4020';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    ctx.fillStyle = '#7a5a30';
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w - 6, h - 6, 4); ctx.fill();
    // Magazine
    ctx.fillStyle = '#ddd';
    ctx.save(); ctx.translate(x + w * 0.6, y + h * 0.3); ctx.rotate(0.2);
    ctx.fillRect(-10, -7, 20, 14); ctx.restore();
    break;
  }
  case 'Bookshelf': {
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Shelves
    const shelves = 4;
    for (let i = 0; i < shelves; i++) {
      const sy = y + (h / shelves) * i;
      const sh = h / shelves;
      // Shelf line
      ctx.fillStyle = '#4a2a10';
      ctx.fillRect(x + 2, sy + sh - 3, w - 4, 3);
      // Books (colored rectangles)
      const colors = ['#c62828','#1565c0','#2e7d32','#f9a825','#6a1b9a','#e65100'];
      let bx = x + 4;
      while (bx < x + w - 8) {
        const bw = 5 + Math.random() * 7;
        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
        ctx.fillRect(bx, sy + 4, bw, sh - 8);
        bx += bw + 1;
      }
    }
    ctx.strokeStyle = '#3a2210'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Plant': {
    // Pot
    ctx.fillStyle = '#8B4513';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.2, y + h * 0.5);
    ctx.lineTo(x + w * 0.3, y + h);
    ctx.lineTo(x + w * 0.7, y + h);
    ctx.lineTo(x + w * 0.8, y + h * 0.5);
    ctx.closePath(); ctx.fill();
    // Pot rim
    ctx.fillStyle = '#a0522d';
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y + h * 0.45, w * 0.7, 8, 3); ctx.fill();
    // Leaves
    ctx.fillStyle = '#2d8a3e';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.3, w * 0.35, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#3da54e';
    ctx.beginPath(); ctx.arc(x + w * 0.4, y + h * 0.22, w * 0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + w * 0.65, y + h * 0.25, w * 0.18, 0, Math.PI * 2); ctx.fill();
    break;
  }

  // â”€â”€â”€ BATHROOM â”€â”€â”€
  case 'Shower': {
    // Tray with tile pattern
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Tile grid on floor
    ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.lineWidth = 0.5;
    for (let tx2 = x + 10; tx2 < x + w - 5; tx2 += 12) {
      ctx.beginPath(); ctx.moveTo(tx2, y + 5); ctx.lineTo(tx2, y + h - 5); ctx.stroke();
    }
    for (let ty2 = y + 10; ty2 < y + h - 5; ty2 += 12) {
      ctx.beginPath(); ctx.moveTo(x + 5, ty2); ctx.lineTo(x + w - 5, ty2); ctx.stroke();
    }
    // Drain
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.65, 7, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#666';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.65, 4, 0, Math.PI * 2); ctx.fill();
    // Drain slots
    ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * Math.PI;
      ctx.beginPath();
      ctx.moveTo(x + w / 2 + Math.cos(angle) * 2, y + h * 0.65 + Math.sin(angle) * 2);
      ctx.lineTo(x + w / 2 + Math.cos(angle) * 5, y + h * 0.65 + Math.sin(angle) * 5);
      ctx.stroke();
    }
    // Glass door panels
    ctx.strokeStyle = 'rgba(150,200,255,0.35)'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x + w - 5, y + 5); ctx.lineTo(x + w - 5, y + h - 5); ctx.stroke();
    ctx.strokeStyle = 'rgba(150,200,255,0.2)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + w - 10, y + 5); ctx.lineTo(x + w - 10, y + h - 5); ctx.stroke();
    // Glass reflection
    ctx.fillStyle = 'rgba(200,230,255,0.04)';
    ctx.fillRect(x + w - 12, y + 10, 8, h - 20);
    // Shower head (detailed)
    ctx.fillStyle = '#ccc';
    ctx.beginPath(); ctx.roundRect(x + w * 0.4, y + 4, w * 0.2, 6, 2); ctx.fill();
    ctx.fillStyle = '#bbb';
    ctx.beginPath();
    ctx.ellipse(x + w * 0.5, y + 12, w * 0.14, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    // Shower arm
    ctx.strokeStyle = '#bbb'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x + w * 0.5, y + 7); ctx.lineTo(x + w * 0.7, y + 5); ctx.stroke();
    // Water drops (seeded positions so they don't flicker)
    ctx.fillStyle = 'rgba(100,180,255,0.12)';
    for (let i = 0; i < 8; i++) {
      const hash = ((i * 7919 + 3) & 0xFF) / 255;
      const dpx = x + w * 0.25 + hash * w * 0.5;
      const dpy = y + 22 + (i * 37 % (h - 35));
      ctx.beginPath(); ctx.arc(dpx, dpy, 1.5 + hash, 0, Math.PI * 2); ctx.fill();
    }
    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.stroke();
    break;
  }
  case 'Toilet': {
    // Base
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.42, h * 0.38, 0, 0, Math.PI * 2);
    ctx.fill();
    // Seat
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.32, h * 0.28, 0, 0, Math.PI * 2);
    ctx.stroke();
    // Tank
    ctx.fillStyle = '#e8e8e8';
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y, w * 0.7, h * 0.3, 4); ctx.fill();
    // Flush button
    ctx.fillStyle = '#ccc';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.12, 4, 0, Math.PI * 2); ctx.fill();
    break;
  }
  case 'Bathtub': {
    // Tub
    ctx.fillStyle = '#f5f5f5';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 10); ctx.fill();
    // Inside
    ctx.fillStyle = '#e0e8f0';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w - 12, h - 12, 8); ctx.fill();
    // Faucet end
    ctx.fillStyle = '#bbb';
    ctx.beginPath(); ctx.roundRect(x + w - 16, y + h * 0.3, 12, 16, 3); ctx.fill();
    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 10); ctx.stroke();
    break;
  }
  case 'Laundry': {
    // Basket
    ctx.fillStyle = '#8d6e63';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 8); ctx.fill();
    // Weave lines
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1;
    for (let i = 1; i < 5; i++) {
      ctx.beginPath(); ctx.moveTo(x + 4, y + i * h / 5); ctx.lineTo(x + w - 4, y + i * h / 5); ctx.stroke();
    }
    // Clothes peeking out
    ctx.fillStyle = '#e53935';
    ctx.beginPath(); ctx.arc(x + w * 0.3, y + 6, 8, Math.PI, 0); ctx.fill();
    ctx.fillStyle = '#1e88e5';
    ctx.beginPath(); ctx.arc(x + w * 0.65, y + 4, 7, Math.PI, 0); ctx.fill();
    break;
  }

  // â”€â”€â”€ BEDROOM â”€â”€â”€
  case 'Bed': {
    // Frame
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Mattress
    ctx.fillStyle = '#f5f5f0';
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 4); ctx.fill();
    // Blanket
    ctx.fillStyle = '#3949ab';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h * 0.35, w - 8, h * 0.6, 4); ctx.fill();
    // Blanket fold
    ctx.fillStyle = '#303f9f';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h * 0.35, w - 8, 8, 2); ctx.fill();
    // Pillow
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.roundRect(x + 12, y + 10, w * 0.35, h * 0.22, 6); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w * 0.52, y + 10, w * 0.35, h * 0.22, 6); ctx.fill();
    break;
  }
  case 'Desk': {
    // Surface
    ctx.fillStyle = '#6d5030';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    ctx.fillStyle = '#8a6840';
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w - 6, h - 6, 3); ctx.fill();
    // Monitor
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y + 6, w * 0.4, h * 0.35, 2); ctx.fill();
    ctx.fillStyle = '#2a4a6a';
    ctx.beginPath(); ctx.roundRect(x + w * 0.33, y + 8, w * 0.34, h * 0.27, 1); ctx.fill();
    // Keyboard
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.55, w * 0.6, h * 0.2, 2); ctx.fill();
    break;
  }
  case 'Wardrobe': {
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Doors
    ctx.fillStyle = '#6d4a2a';
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w / 2 - 5, h - 6, 3); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w / 2 + 2, y + 3, w / 2 - 5, h - 6, 3); ctx.fill();
    // Handles
    ctx.fillStyle = '#aa8844';
    ctx.beginPath(); ctx.arc(x + w / 2 - 6, y + h / 2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + w / 2 + 6, y + h / 2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#4a2a10'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Mirror': {
    // Frame
    ctx.fillStyle = '#aa8844';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Glass
    const grd = ctx.createLinearGradient(x, y, x + w, y + h);
    grd.addColorStop(0, '#a0c0d8');
    grd.addColorStop(0.5, '#d0e8f5');
    grd.addColorStop(1, '#90b0c8');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 4); ctx.fill();
    // Shine
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.beginPath(); ctx.roundRect(x + 8, y + 8, w * 0.3, h * 0.4, 2); ctx.fill();
    break;
  }

  // â”€â”€â”€ HALLWAY â”€â”€â”€
  case 'Bench': {
    ctx.fillStyle = '#5a4020';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    ctx.fillStyle = '#7a5a30';
    ctx.beginPath(); ctx.roundRect(x + 2, y + 2, w - 4, h - 4, 3); ctx.fill();
    // Slats
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
      ctx.beginPath(); ctx.moveTo(x + 6, y + h * i / 4); ctx.lineTo(x + w - 6, y + h * i / 4); ctx.stroke();
    }
    break;
  }
  case 'Cabinet': {
    ctx.fillStyle = '#4a3520';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Doors
    ctx.fillStyle = '#5a4530';
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w / 2 - 5, h - 6, 2); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w / 2 + 2, y + 3, w / 2 - 5, h - 6, 2); ctx.fill();
    // Handles
    ctx.fillStyle = '#888';
    ctx.fillRect(x + w / 2 - 7, y + h / 2 - 2, 4, 4);
    ctx.fillRect(x + w / 2 + 3, y + h / 2 - 2, 4, 4);
    break;
  }
  case 'Lamp': {
    // Base
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.8, w * 0.3, h * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    // Pole
    ctx.fillStyle = '#555';
    ctx.fillRect(x + w / 2 - 2, y + h * 0.25, 4, h * 0.55);
    // Shade
    ctx.fillStyle = '#f5e6b8';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.2, w * 0.4, h * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
    // Glow
    ctx.fillStyle = 'rgba(255,240,180,0.08)';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.2, w * 0.7, 0, Math.PI * 2); ctx.fill();
    break;
  }

  // â”€â”€â”€ GYM â”€â”€â”€
  case 'Bench Press': {
    // Bench
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.3, w, h * 0.4, 4); ctx.fill();
    // Padding
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.roundRect(x + 8, y + h * 0.35, w - 16, h * 0.3, 3); ctx.fill();
    // Bar rack
    ctx.fillStyle = '#888';
    ctx.fillRect(x + 4, y, 6, h);
    ctx.fillRect(x + w - 10, y, 6, h);
    // Bar
    ctx.fillStyle = '#aaa';
    ctx.fillRect(x - 10, y + 6, w + 20, 4);
    // Weights
    ctx.fillStyle = '#555';
    ctx.beginPath(); ctx.roundRect(x - 16, y, 10, 16, 2); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w + 6, y, 10, 16, 2); ctx.fill();
    break;
  }
  case 'Weights': {
    // Rack
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Dumbbell pairs
    const colors = ['#666','#555','#777','#888'];
    for (let i = 0; i < 3; i++) {
      const dy = y + 8 + i * (h / 3 - 2);
      ctx.fillStyle = colors[i];
      // Left weight
      ctx.beginPath(); ctx.roundRect(x + 8, dy, 12, 14, 3); ctx.fill();
      // Bar
      ctx.fillStyle = '#aaa';
      ctx.fillRect(x + 20, dy + 5, w - 40, 4);
      // Right weight
      ctx.fillStyle = colors[i];
      ctx.beginPath(); ctx.roundRect(x + w - 20, dy, 12, 14, 3); ctx.fill();
    }
    break;
  }
  case 'Treadmill': {
    // Body
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    // Belt
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h * 0.25, w - 8, h * 0.6, 4); ctx.fill();
    // Belt lines
    ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 1;
    for (let i = 1; i < 6; i++) {
      const ly = y + h * 0.25 + (h * 0.6 / 6) * i;
      ctx.beginPath(); ctx.moveTo(x + 8, ly); ctx.lineTo(x + w - 8, ly); ctx.stroke();
    }
    // Console
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 4, w - 12, h * 0.15, 3); ctx.fill();
    // Screen
    ctx.fillStyle = '#1a4a2a';
    ctx.beginPath(); ctx.roundRect(x + 12, y + 6, w - 24, h * 0.1, 2); ctx.fill();
    // Handles
    ctx.fillStyle = '#666';
    ctx.fillRect(x, y + 4, 5, h * 0.4);
    ctx.fillRect(x + w - 5, y + 4, 5, h * 0.4);
    break;
  }
  case 'Dumbbells': {
    // Floor mat
    ctx.fillStyle = '#2a2a30';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Two dumbbells
    for (let d = 0; d < 2; d++) {
      const dy = y + 10 + d * 28;
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.roundRect(x + 10, dy, 16, 14, 4); ctx.fill();
      ctx.beginPath(); ctx.roundRect(x + w - 26, dy, 16, 14, 4); ctx.fill();
      ctx.fillStyle = '#aaa';
      ctx.fillRect(x + 26, dy + 5, w - 52, 4);
    }
    break;
  }
  case 'Punching Bag': {
    // Shadow on floor
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.85, w * 0.35, h * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();
    // Chain
    ctx.strokeStyle = '#777'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x + w / 2, y); ctx.lineTo(x + w / 2, y + h * 0.15); ctx.stroke();
    // Bag
    const bgrd = ctx.createLinearGradient(x, y + h * 0.15, x + w, y + h * 0.15);
    bgrd.addColorStop(0, '#8b2020'); bgrd.addColorStop(0.5, '#c62828'); bgrd.addColorStop(1, '#8b2020');
    ctx.fillStyle = bgrd;
    ctx.beginPath();
    ctx.roundRect(x + w * 0.15, y + h * 0.15, w * 0.7, h * 0.65, w * 0.25);
    ctx.fill();
    // Stitch line
    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + w / 2, y + h * 0.2); ctx.lineTo(x + w / 2, y + h * 0.75); ctx.stroke();
    break;
  }
  case 'Yoga Mat': {
    ctx.fillStyle = '#7b1fa2';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    ctx.fillStyle = '#9c27b0';
    ctx.beginPath(); ctx.roundRect(x + 2, y + 2, w - 4, h - 4, 3); ctx.fill();
    // Texture lines
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      ctx.beginPath(); ctx.moveTo(x + 6 + i * 20, y + 2); ctx.lineTo(x + 6 + i * 20, y + h - 2); ctx.stroke();
    }
    break;
  }

  // â”€â”€â”€ GARDEN â”€â”€â”€
  case 'Tree': {
    // Trunk
    ctx.fillStyle = '#5d4037';
    ctx.fillRect(x + w * 0.38, y + h * 0.5, w * 0.24, h * 0.5);
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.9, w * 0.45, h * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();
    // Canopy layers
    ctx.fillStyle = '#1b5e20';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.35, w * 0.48, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#2e7d32';
    ctx.beginPath(); ctx.arc(x + w * 0.4, y + h * 0.28, w * 0.3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#388e3c';
    ctx.beginPath(); ctx.arc(x + w * 0.62, y + h * 0.3, w * 0.25, 0, Math.PI * 2); ctx.fill();
    break;
  }
  case 'Bush': {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.85, w * 0.45, h * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    // Bush body
    ctx.fillStyle = '#2e7d32';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.5, w * 0.48, h * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#43a047';
    ctx.beginPath(); ctx.arc(x + w * 0.35, y + h * 0.4, w * 0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + w * 0.65, y + h * 0.4, w * 0.18, 0, Math.PI * 2); ctx.fill();
    break;
  }
  case 'Fountain': {
    // Water glow on ground
    ctx.fillStyle = 'rgba(80,200,255,0.04)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.6, h * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    // Outer basin rim
    ctx.fillStyle = '#607d8b';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.62, w * 0.5, h * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Inner basin
    ctx.fillStyle = '#78909c';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.46, h * 0.36, 0, 0, Math.PI * 2);
    ctx.fill();
    // Water surface
    const wGrd = ctx.createRadialGradient(x + w / 2, y + h * 0.6, 5, x + w / 2, y + h * 0.6, w * 0.4);
    wGrd.addColorStop(0, '#81d4fa');
    wGrd.addColorStop(0.5, '#4fc3f7');
    wGrd.addColorStop(1, '#29b6f6');
    ctx.fillStyle = wGrd;
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.4, h * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    // Water ripples
    ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.25, h * 0.18, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.6, w * 0.15, h * 0.1, 0, 0, Math.PI * 2);
    ctx.stroke();
    // Center pillar (ornate)
    ctx.fillStyle = '#90a4ae';
    ctx.fillRect(x + w / 2 - 6, y + h * 0.18, 12, h * 0.42);
    // Pillar detail
    ctx.fillStyle = '#a0b0b8';
    ctx.fillRect(x + w / 2 - 8, y + h * 0.35, 16, 4);
    // Top bowl with water
    ctx.fillStyle = '#78909c';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.18, 16, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(100,200,255,0.4)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.17, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Water streams falling
    ctx.strokeStyle = 'rgba(100,200,255,0.2)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + w / 2 - 10, y + h * 0.2); ctx.lineTo(x + w / 2 - 18, y + h * 0.4); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + w / 2 + 10, y + h * 0.2); ctx.lineTo(x + w / 2 + 18, y + h * 0.4); ctx.stroke();
    // Top finial
    ctx.fillStyle = '#a0b0b8';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.1, 4, 0, Math.PI * 2); ctx.fill();
    break;
  }
  case 'Flowers': {
    // Soil
    ctx.fillStyle = '#4e342e';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.5, w, h * 0.5, 4); ctx.fill();
    // Flowers
    const flowerColors = ['#e53935','#fdd835','#e91e63','#ff9800'];
    for (let i = 0; i < 4; i++) {
      const fx = x + 8 + i * 13, fy = y + 10 + (i % 2) * 8;
      // Stem
      ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(fx, fy + 8); ctx.lineTo(fx, y + h * 0.55); ctx.stroke();
      // Petals
      ctx.fillStyle = flowerColors[i];
      ctx.beginPath(); ctx.arc(fx, fy, 5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff59d';
      ctx.beginPath(); ctx.arc(fx, fy, 2, 0, Math.PI * 2); ctx.fill();
    }
    break;
  }

  // â”€â”€â”€ GARAGE â”€â”€â”€
  case 'Car': {
    // Ground shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.95, w * 0.52, h * 0.08, 0, 0, Math.PI * 2);
    ctx.fill();
    // Body with metallic gradient
    const carGrd = ctx.createLinearGradient(x, y, x + w, y);
    carGrd.addColorStop(0, '#0d47a1');
    carGrd.addColorStop(0.3, '#1976d2');
    carGrd.addColorStop(0.7, '#1565c0');
    carGrd.addColorStop(1, '#0d47a1');
    ctx.fillStyle = carGrd;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 12); ctx.fill();
    // Body panels lines
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x + 10, y + h * 0.45); ctx.lineTo(x + w - 10, y + h * 0.45); ctx.stroke();
    // Roof (darker)
    ctx.fillStyle = '#0d47a1';
    ctx.beginPath(); ctx.roundRect(x + w * 0.18, y + h * 0.18, w * 0.64, h * 0.54, 10); ctx.fill();
    // Windshield (front)
    const wshGrd = ctx.createLinearGradient(x + w * 0.2, y + h * 0.2, x + w * 0.8, y + h * 0.2);
    wshGrd.addColorStop(0, 'rgba(120,180,240,0.35)');
    wshGrd.addColorStop(0.5, 'rgba(180,220,255,0.25)');
    wshGrd.addColorStop(1, 'rgba(120,180,240,0.35)');
    ctx.fillStyle = wshGrd;
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.19, w * 0.6, h * 0.16, 5); ctx.fill();
    // Rear window
    ctx.fillStyle = 'rgba(120,180,240,0.28)';
    ctx.beginPath(); ctx.roundRect(x + w * 0.22, y + h * 0.56, w * 0.56, h * 0.14, 4); ctx.fill();
    // Side windows
    ctx.fillStyle = 'rgba(120,180,240,0.2)';
    ctx.beginPath(); ctx.roundRect(x + 4, y + h * 0.25, w * 0.12, h * 0.2, 2); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 4 - w * 0.12, y + h * 0.25, w * 0.12, h * 0.2, 2); ctx.fill();
    // Door handles
    ctx.fillStyle = '#0d47a1';
    ctx.beginPath(); ctx.roundRect(x + 6, y + h * 0.48, 10, 3, 1); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 16, y + h * 0.48, 10, 3, 1); ctx.fill();
    // Wheels with rims
    const wheelPositions = [
      [x - 5, y + h * 0.1], [x - 5, y + h * 0.62],
      [x + w - 7, y + h * 0.1], [x + w - 7, y + h * 0.62]
    ];
    wheelPositions.forEach(([wx2, wy2]) => {
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath(); ctx.roundRect(wx2, wy2, 12, 22, 4); ctx.fill();
      // Rim
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.arc(wx2 + 6, wy2 + 11, 5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#444';
      ctx.beginPath(); ctx.arc(wx2 + 6, wy2 + 11, 2, 0, Math.PI * 2); ctx.fill();
    });
    // Headlights with glow
    ctx.fillStyle = 'rgba(255,235,59,0.1)';
    ctx.beginPath(); ctx.arc(x + 12, y + 8, 10, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + w - 12, y + 8, 10, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff9c4';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 4, 12, 8, 3); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 18, y + 4, 12, 8, 3); ctx.fill();
    // Tail lights
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x + 6, y + h - 10, 10, 6, 2); ctx.fill();
    ctx.beginPath(); ctx.roundRect(x + w - 16, y + h - 10, 10, 6, 2); ctx.fill();
    // License plate
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.roundRect(x + w / 2 - 12, y + h - 8, 24, 6, 1); ctx.fill();
    ctx.fillStyle = '#333';
    ctx.font = '4px monospace'; ctx.textAlign = 'center';
    ctx.fillText('FIT-01', x + w / 2, y + h - 4);
    // Body highlight
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fillRect(x + 4, y + 4, w - 8, h * 0.2);
    break;
  }
  case 'Workbench': {
    // Table
    ctx.fillStyle = '#5d4037';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    ctx.fillStyle = '#6d5040';
    ctx.beginPath(); ctx.roundRect(x + 2, y + 2, w - 4, h - 4, 3); ctx.fill();
    // Tool pegboard (back wall feel)
    ctx.fillStyle = '#4a3525';
    ctx.beginPath(); ctx.roundRect(x + 2, y + 2, w - 4, h * 0.2, 2); ctx.fill();
    // Tools hanging
    ctx.fillStyle = '#aaa';
    ctx.fillRect(x + 10, y + 6, 3, 14);  // wrench
    ctx.fillRect(x + 22, y + 8, 3, 10);  // screwdriver
    ctx.fillRect(x + 34, y + 5, 8, 3);   // hammer head
    ctx.fillRect(x + 36, y + 8, 3, 12);  // hammer handle
    // Vice
    ctx.fillStyle = '#777';
    ctx.beginPath(); ctx.roundRect(x + w - 25, y + h * 0.5, 20, 16, 2); ctx.fill();
    break;
  }
  case 'Toolbox': {
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Lid line
    ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + 4, y + h * 0.35); ctx.lineTo(x + w - 4, y + h * 0.35); ctx.stroke();
    // Handle
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y + 3, w * 0.4, 8, 3); ctx.fill();
    // Latch
    ctx.fillStyle = '#fdd835';
    ctx.fillRect(x + w / 2 - 4, y + h * 0.35 - 3, 8, 6);
    ctx.strokeStyle = '#c62828'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    break;
  }
  case 'Barrel': {
    ctx.fillStyle = '#5d4037';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, w * 0.2); ctx.fill();
    // Metal bands
    ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x + 4, y + h * 0.25); ctx.lineTo(x + w - 4, y + h * 0.25); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + 4, y + h * 0.75); ctx.lineTo(x + w - 4, y + h * 0.75); ctx.stroke();
    // Top
    ctx.fillStyle = '#4e342e';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + 6, w * 0.42, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Wood grain
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + w * 0.3, y + 4); ctx.lineTo(x + w * 0.3, y + h - 4); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + w * 0.7, y + 4); ctx.lineTo(x + w * 0.7, y + h - 4); ctx.stroke();
    break;
  }
  case 'Boxes': {
    // Bottom box
    ctx.fillStyle = '#8d6e63';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.35, w, h * 0.65, 3); ctx.fill();
    ctx.strokeStyle = '#6d4c41'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.35, w, h * 0.65, 3); ctx.stroke();
    // Tape
    ctx.fillStyle = '#bcaaa4';
    ctx.fillRect(x + w * 0.4, y + h * 0.35, w * 0.2, h * 0.65);
    // Top box (smaller, rotated slightly)
    ctx.save(); ctx.translate(x + w * 0.5, y + h * 0.25); ctx.rotate(0.1);
    ctx.fillStyle = '#a1887f';
    ctx.beginPath(); ctx.roundRect(-w * 0.35, -h * 0.2, w * 0.7, h * 0.4, 3); ctx.fill();
    ctx.fillStyle = '#bcaaa4';
    ctx.fillRect(-w * 0.08, -h * 0.2, w * 0.16, h * 0.4);
    ctx.restore();
    break;
  }
  case 'Ladder': {
    // Side rails
    ctx.fillStyle = '#ff8f00';
    ctx.fillRect(x + 6, y, 5, h);
    ctx.fillRect(x + w - 11, y, 5, h);
    // Rungs
    ctx.fillStyle = '#ffa726';
    const rungs = 5;
    for (let i = 0; i < rungs; i++) {
      ctx.fillRect(x + 11, y + 8 + i * (h - 16) / (rungs - 1), w - 22, 4);
    }
    break;
  }

  // â”€â”€â”€ NEW KITCHEN ITEMS â”€â”€â”€
  case 'Dishwasher': {
    ctx.fillStyle = '#b0b8c0';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Door
    ctx.fillStyle = '#a0a8b0';
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 3); ctx.fill();
    // Handle
    ctx.fillStyle = '#888';
    ctx.fillRect(x + 10, y + h * 0.45, w - 20, 4);
    // Control panel
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x + 10, y + 6, w - 20, 12, 2); ctx.fill();
    // LED dots
    ctx.fillStyle = '#0f0';
    ctx.beginPath(); ctx.arc(x + 20, y + 12, 2, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#0a0';
    ctx.beginPath(); ctx.arc(x + 30, y + 12, 2, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    break;
  }
  case 'Microwave': {
    ctx.fillStyle = '#2a2a30';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Window
    ctx.fillStyle = '#111820';
    ctx.beginPath(); ctx.roundRect(x + 5, y + 6, w * 0.6, h - 12, 2); ctx.fill();
    // Interior glow
    ctx.fillStyle = 'rgba(255,200,100,0.05)';
    ctx.beginPath(); ctx.roundRect(x + 7, y + 8, w * 0.6 - 4, h - 16, 1); ctx.fill();
    // Control panel
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x + w * 0.68, y + 6, w * 0.26, h - 12, 2); ctx.fill();
    // Buttons
    ctx.fillStyle = '#555';
    for (let i = 0; i < 3; i++) {
      ctx.beginPath(); ctx.arc(x + w * 0.81, y + 14 + i * 10, 3, 0, Math.PI * 2); ctx.fill();
    }
    // Timer display
    ctx.fillStyle = '#0a3';
    ctx.font = '6px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('0:00', x + w * 0.81, y + h - 8);
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Pantry': {
    ctx.fillStyle = '#5a4020';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Shelves
    for (let i = 1; i <= 3; i++) {
      ctx.fillStyle = '#4a3018';
      ctx.fillRect(x + 3, y + (h / 4) * i - 2, w - 6, 3);
    }
    // Cans/jars on shelves
    const jarColors = ['#c62828','#2e7d32','#f9a825','#1565c0'];
    for (let i = 0; i < 3; i++) {
      let jx = x + 6;
      for (let j = 0; j < 3; j++) {
        ctx.fillStyle = jarColors[(i + j) % jarColors.length];
        ctx.beginPath(); ctx.roundRect(jx, y + (h / 4) * i + 4, 8, h / 4 - 8, 1); ctx.fill();
        jx += 12;
      }
    }
    ctx.strokeStyle = '#3a2510'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Spice Rack': {
    ctx.fillStyle = '#6d4a2a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Shelf
    ctx.fillStyle = '#5a3a1a';
    ctx.fillRect(x + 2, y + h * 0.5, w - 4, 3);
    // Spice bottles
    const spiceColors = ['#c62828','#f9a825','#4caf50','#ff6f00','#795548','#e91e63'];
    for (let r = 0; r < 2; r++) {
      let sx = x + 6;
      for (let i = 0; i < Math.floor((w - 12) / 12); i++) {
        ctx.fillStyle = spiceColors[(r * 3 + i) % spiceColors.length];
        const by = r === 0 ? y + 5 : y + h * 0.5 + 6;
        const bh = h * 0.4 - 8;
        ctx.beginPath(); ctx.roundRect(sx, by, 8, bh, 2); ctx.fill();
        // Cap
        ctx.fillStyle = '#333';
        ctx.fillRect(sx + 1, by, 6, 3);
        sx += 12;
      }
    }
    ctx.strokeStyle = '#4a2a10'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Mop Bucket': {
    // Bucket
    ctx.fillStyle = '#546e7a';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.15, y + h * 0.3);
    ctx.lineTo(x + w * 0.25, y + h);
    ctx.lineTo(x + w * 0.75, y + h);
    ctx.lineTo(x + w * 0.85, y + h * 0.3);
    ctx.closePath(); ctx.fill();
    // Water
    ctx.fillStyle = 'rgba(100,180,220,0.3)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.35, w * 0.32, h * 0.08, 0, 0, Math.PI * 2);
    ctx.fill();
    // Handle
    ctx.strokeStyle = '#777'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x + w / 2, y + h * 0.2, w * 0.25, Math.PI, 0);
    ctx.stroke();
    // Mop handle
    ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + w * 0.7, y + h * 0.3);
    ctx.lineTo(x + w * 0.8, y);
    ctx.stroke();
    break;
  }

  // â”€â”€â”€ NEW CAFETERIA ITEMS â”€â”€â”€
  case 'Food Counter': {
    // Steel counter
    ctx.fillStyle = '#b0b8c0';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Glass sneeze guard
    ctx.strokeStyle = 'rgba(150,200,255,0.3)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x + 10, y + 4); ctx.lineTo(x + w - 10, y + 4); ctx.stroke();
    // Food trays
    const trayColors = ['#c62828','#f9a825','#2e7d32'];
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = '#e0e0e0';
      ctx.beginPath(); ctx.roundRect(x + 10 + i * 60, y + 14, 50, h - 24, 2); ctx.fill();
      ctx.fillStyle = trayColors[i] + '60';
      ctx.beginPath(); ctx.roundRect(x + 14 + i * 60, y + 18, 42, h - 32, 1); ctx.fill();
    }
    ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Menu Board': {
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    // Text lines
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    for (let i = 0; i < 4; i++) {
      ctx.fillRect(x + 8, y + 8 + i * 10, w - 16 - (i % 2) * 15, 3);
    }
    // Frame
    ctx.strokeStyle = '#5a3a1a'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.stroke();
    break;
  }

  // â”€â”€â”€ NEW LIVING ROOM ITEMS â”€â”€â”€
  case 'Speaker': {
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Woofer
    ctx.strokeStyle = '#444'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.55, w * 0.3, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.55, w * 0.18, 0, Math.PI * 2); ctx.fill();
    // Tweeter
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.2, w * 0.15, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h * 0.2, w * 0.08, 0, Math.PI * 2); ctx.fill();
    // LED
    ctx.fillStyle = '#00ff88';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h - 8, 2, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    break;
  }
  case 'Side Table': {
    ctx.fillStyle = '#5a4020';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    ctx.fillStyle = '#6d5030';
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w - 6, h - 6, 4); ctx.fill();
    // Coaster
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(x + w * 0.6, y + h * 0.4, 8, 0, Math.PI * 2); ctx.stroke();
    break;
  }
  case 'Rug Display': {
    ctx.fillStyle = 'rgba(80,40,60,0.2)';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Pattern
    ctx.strokeStyle = 'rgba(200,150,100,0.1)'; ctx.lineWidth = 1;
    const cx2 = x + w / 2, cy2 = y + h / 2;
    ctx.beginPath();
    ctx.moveTo(cx2, y + 8); ctx.lineTo(x + w - 8, cy2);
    ctx.lineTo(cx2, y + h - 8); ctx.lineTo(x + 8, cy2);
    ctx.closePath(); ctx.stroke();
    // Border decoration
    ctx.strokeStyle = 'rgba(200,150,100,0.08)'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x + 5, y + 5, w - 10, h - 10, 3); ctx.stroke();
    ctx.beginPath(); ctx.roundRect(x + 10, y + 10, w - 20, h - 20, 2); ctx.stroke();
    break;
  }
  case 'Storage Ottoman': {
    ctx.fillStyle = '#5c3d2e';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 8); ctx.fill();
    // Cushion top
    ctx.fillStyle = '#7a4f3a';
    ctx.beginPath(); ctx.roundRect(x + 4, y + 4, w - 8, h - 8, 6); ctx.fill();
    // Button tufts
    ctx.fillStyle = '#503020';
    const ox = [w * 0.3, w * 0.7, w * 0.5];
    const oy = [h * 0.35, h * 0.35, h * 0.65];
    for (let i = 0; i < 3; i++) {
      ctx.beginPath(); ctx.arc(x + ox[i], y + oy[i], 3, 0, Math.PI * 2); ctx.fill();
    }
    break;
  }

  // â”€â”€â”€ NEW BATHROOM ITEMS â”€â”€â”€
  case 'Toilet Paper': {
    // Holder
    ctx.fillStyle = '#888';
    ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.8, 4);
    // Roll
    ctx.fillStyle = '#f5f5f0';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.5, w * 0.35, h * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    // Center hole
    ctx.fillStyle = '#ddd';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.5, w * 0.12, h * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();
    break;
  }
  case 'Medicine Cabinet': {
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Mirror door
    const mgrd = ctx.createLinearGradient(x, y, x + w, y + h);
    mgrd.addColorStop(0, '#b0c8d8'); mgrd.addColorStop(0.5, '#d0e4f0'); mgrd.addColorStop(1, '#a0b8c8');
    ctx.fillStyle = mgrd;
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w - 6, h - 6, 3); ctx.fill();
    // Shine
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w * 0.3, h * 0.35, 2); ctx.fill();
    // Handle
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.roundRect(x + w - 12, y + h / 2 - 8, 5, 16, 2); ctx.fill();
    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Plunger': {
    // Handle
    ctx.fillStyle = '#8d6e63';
    ctx.fillRect(x + w / 2 - 2, y, 4, h * 0.65);
    // Cup
    ctx.fillStyle = '#c62828';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.75, w * 0.35, h * 0.25, 0, 0, Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.75, w * 0.35, h * 0.08, 0, 0, Math.PI * 2);
    ctx.fill();
    break;
  }

  // â”€â”€â”€ NEW HALLWAY ITEMS â”€â”€â”€
  case 'Fire Extinguisher': {
    // Body
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.15, w * 0.6, h * 0.75, w * 0.2); ctx.fill();
    // Top
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y, w * 0.4, h * 0.2, 3); ctx.fill();
    // Handle
    ctx.fillStyle = '#555';
    ctx.fillRect(x + w * 0.55, y + h * 0.05, w * 0.25, 4);
    // Pressure gauge
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x + w * 0.5, y + h * 0.4, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#0a0';
    ctx.beginPath(); ctx.arc(x + w * 0.5, y + h * 0.4, 3, 0, Math.PI * 2); ctx.fill();
    // Label
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.roundRect(x + w * 0.28, y + h * 0.52, w * 0.44, h * 0.18, 1); ctx.fill();
    ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.15, w * 0.6, h * 0.75, w * 0.2); ctx.stroke();
    break;
  }
  case 'Wall Panel': {
    ctx.fillStyle = '#2a2a35';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Screen
    ctx.fillStyle = '#0a1a2a';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w - 12, h * 0.5, 2); ctx.fill();
    // Blinking status lights
    ctx.fillStyle = '#0f0';
    ctx.beginPath(); ctx.arc(x + 12, y + h * 0.7, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff0';
    ctx.beginPath(); ctx.arc(x + 24, y + h * 0.7, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.arc(x + 36, y + h * 0.7, 3, 0, Math.PI * 2); ctx.fill();
    // Buttons
    ctx.fillStyle = '#555';
    ctx.beginPath(); ctx.roundRect(x + w - 20, y + h * 0.65, 12, 8, 2); ctx.fill();
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }
  case 'Control Panel': {
    ctx.fillStyle = '#1a1a28';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.fill();
    // Main screen
    ctx.fillStyle = '#0a2040';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w - 12, h * 0.4, 2); ctx.fill();
    // Screen content (fake readout)
    ctx.fillStyle = '#0f4';
    ctx.font = '5px monospace'; ctx.textAlign = 'left';
    ctx.fillText('SYS OK', x + 10, y + 16);
    ctx.fillText('T:22.4C', x + 10, y + 24);
    // Buttons grid
    const btnColors = ['#d32f2f','#2e7d32','#1565c0','#f9a825'];
    for (let bi = 0; bi < 4; bi++) {
      ctx.fillStyle = btnColors[bi];
      ctx.beginPath();
      ctx.roundRect(x + 8 + (bi % 2) * 30, y + h * 0.55 + Math.floor(bi / 2) * 16, 22, 12, 2);
      ctx.fill();
    }
    // Knob
    ctx.fillStyle = '#666';
    ctx.beginPath(); ctx.arc(x + w - 14, y + h * 0.75, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(x + w - 14, y + h * 0.75, 3, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 5); ctx.stroke();
    break;
  }
  case 'Sign Post': {
    // Post
    ctx.fillStyle = '#666';
    ctx.fillRect(x + w / 2 - 3, y + h * 0.3, 6, h * 0.7);
    // Sign
    ctx.fillStyle = '#1565c0';
    ctx.beginPath(); ctx.roundRect(x, y, w, h * 0.35, 3); ctx.fill();
    // Arrow
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.7, y + h * 0.1);
    ctx.lineTo(x + w * 0.85, y + h * 0.175);
    ctx.lineTo(x + w * 0.7, y + h * 0.25);
    ctx.closePath(); ctx.fill();
    ctx.fillRect(x + w * 0.25, y + h * 0.155, w * 0.45, 4);
    break;
  }
  case 'Emergency Light': {
    // Base plate
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Light lens
    const elGrd = ctx.createRadialGradient(x + w / 2, y + h / 2, 2, x + w / 2, y + h / 2, w * 0.4);
    elGrd.addColorStop(0, '#ff6659');
    elGrd.addColorStop(0.5, '#d32f2f');
    elGrd.addColorStop(1, '#b71c1c');
    ctx.fillStyle = elGrd;
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w - 12, h - 12, 3); ctx.fill();
    // Glow effect
    ctx.fillStyle = 'rgba(255,50,50,0.06)';
    ctx.beginPath(); ctx.arc(x + w / 2, y + h / 2, w * 0.8, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.stroke();
    break;
  }

  // â”€â”€â”€ NEW BEDROOM ITEMS â”€â”€â”€
  case 'Nightstand': {
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    ctx.fillStyle = '#6d4a2a';
    ctx.beginPath(); ctx.roundRect(x + 2, y + 2, w - 4, h - 4, 3); ctx.fill();
    // Drawer line
    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x + 4, y + h * 0.55); ctx.lineTo(x + w - 4, y + h * 0.55); ctx.stroke();
    // Handle
    ctx.fillStyle = '#aa8844';
    ctx.fillRect(x + w / 2 - 5, y + h * 0.3, 10, 3);
    ctx.fillRect(x + w / 2 - 5, y + h * 0.7, 10, 3);
    // Alarm clock on top
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.roundRect(x + w * 0.3, y + 5, w * 0.4, 8, 2); ctx.fill();
    ctx.fillStyle = '#0a0';
    ctx.font = '4px monospace'; ctx.textAlign = 'center';
    ctx.fillText('7:30', x + w / 2, y + 11);
    break;
  }
  case 'Bookshelf Small': {
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    // Shelves
    ctx.fillStyle = '#4a2a10';
    ctx.fillRect(x + 2, y + h * 0.5 - 1, w - 4, 2);
    // Books
    const bkColors = ['#c62828','#1565c0','#2e7d32','#f9a825','#6a1b9a'];
    let bx2 = x + 4;
    for (let row = 0; row < 2; row++) {
      bx2 = x + 4;
      const by2 = row === 0 ? y + 4 : y + h * 0.5 + 3;
      const bh2 = h * 0.45 - 6;
      while (bx2 < x + w - 6) {
        const bw2 = 4 + Math.random() * 5;
        ctx.fillStyle = bkColors[Math.floor(Math.random() * bkColors.length)];
        ctx.fillRect(bx2, by2, bw2, bh2);
        bx2 += bw2 + 1;
      }
    }
    ctx.strokeStyle = '#3a2210'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.stroke();
    break;
  }

  // â”€â”€â”€ NEW GYM ITEMS â”€â”€â”€
  case 'Kettlebells': {
    // Mat underneath
    ctx.fillStyle = '#2a2a30';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
    // Kettlebells
    const kbSizes = [{cx: 0.3, cy: 0.55, r: 0.2, c: '#444'}, {cx: 0.7, cy: 0.55, r: 0.18, c: '#555'}, {cx: 0.5, cy: 0.5, r: 0.22, c: '#3a3a3a'}];
    kbSizes.forEach(kb => {
      // Ball
      ctx.fillStyle = kb.c;
      ctx.beginPath(); ctx.arc(x + w * kb.cx, y + h * kb.cy, w * kb.r, 0, Math.PI * 2); ctx.fill();
      // Handle
      ctx.strokeStyle = kb.c; ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w * kb.cx, y + h * kb.cy - w * kb.r * 0.8, w * kb.r * 0.6, Math.PI * 0.2, Math.PI * 0.8);
      ctx.stroke();
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath(); ctx.arc(x + w * kb.cx - 3, y + h * kb.cy - 3, w * kb.r * 0.3, 0, Math.PI * 2); ctx.fill();
    });
    break;
  }
  case 'Gym Mirror': {
    // Frame
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 3); ctx.fill();
    // Mirror surface
    const gmGrd = ctx.createLinearGradient(x, y, x + w, y + h);
    gmGrd.addColorStop(0, '#8aa8c0');
    gmGrd.addColorStop(0.3, '#b8d4e8');
    gmGrd.addColorStop(0.7, '#a0c0d8');
    gmGrd.addColorStop(1, '#90b0c0');
    ctx.fillStyle = gmGrd;
    ctx.beginPath(); ctx.roundRect(x + 3, y + 3, w - 6, h - 6, 2); ctx.fill();
    // Reflection shine
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(x + 6, y + 6, w * 0.25, h - 12, 1); ctx.fill();
    break;
  }
  case 'Water Cooler': {
    // Base
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y + h * 0.35, w * 0.7, h * 0.65, 4); ctx.fill();
    // Bottle
    ctx.fillStyle = 'rgba(100,180,255,0.3)';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.3, y + h * 0.35);
    ctx.lineTo(x + w * 0.35, y + h * 0.1);
    ctx.quadraticCurveTo(x + w / 2, y, x + w * 0.65, y + h * 0.1);
    ctx.lineTo(x + w * 0.7, y + h * 0.35);
    ctx.closePath(); ctx.fill();
    // Taps
    ctx.fillStyle = '#c62828';
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.5, 8, 6, 1); ctx.fill();
    ctx.fillStyle = '#1565c0';
    ctx.beginPath(); ctx.roundRect(x + w * 0.7 - 8, y + h * 0.5, 8, 6, 1); ctx.fill();
    // Drip tray
    ctx.fillStyle = '#ccc';
    ctx.beginPath(); ctx.roundRect(x + w * 0.2, y + h * 0.6, w * 0.6, 4, 1); ctx.fill();
    ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y + h * 0.35, w * 0.7, h * 0.65, 4); ctx.stroke();
    break;
  }
  case 'Foam Roller': {
    // Roller body
    ctx.fillStyle = '#1a237e';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.2, w, h * 0.6, h * 0.3); ctx.fill();
    // Texture bumps
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for (let i = 0; i < Math.floor(w / 12); i++) {
      for (let j = 0; j < 2; j++) {
        ctx.beginPath();
        ctx.arc(x + 8 + i * 12, y + h * 0.35 + j * h * 0.2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.strokeStyle = '#0d1257'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.2, w, h * 0.6, h * 0.3); ctx.stroke();
    break;
  }

  // â”€â”€â”€ NEW GARDEN ITEMS â”€â”€â”€
  case 'Garden Bench': {
    // Legs
    ctx.fillStyle = '#555';
    ctx.fillRect(x + 4, y + h * 0.6, 5, h * 0.4);
    ctx.fillRect(x + w - 9, y + h * 0.6, 5, h * 0.4);
    // Seat
    ctx.fillStyle = '#6d4a2a';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.45, w, 12, 3); ctx.fill();
    // Backrest slats
    ctx.fillStyle = '#5a3a1a';
    for (let i = 0; i < 4; i++) {
      ctx.beginPath(); ctx.roundRect(x + 4 + i * (w - 8) / 4, y, (w - 8) / 4 - 3, h * 0.48, 2); ctx.fill();
    }
    ctx.strokeStyle = '#4a2a10'; ctx.lineWidth = 0.5;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath(); ctx.roundRect(x + 4 + i * (w - 8) / 4, y, (w - 8) / 4 - 3, h * 0.48, 2); ctx.stroke();
    }
    break;
  }
  case 'Bird Bath': {
    // Pedestal
    ctx.fillStyle = '#78909c';
    ctx.fillRect(x + w * 0.35, y + h * 0.4, w * 0.3, h * 0.6);
    // Base
    ctx.fillStyle = '#607d8b';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.95, w * 0.4, h * 0.08, 0, 0, Math.PI * 2);
    ctx.fill();
    // Bowl
    ctx.fillStyle = '#90a4ae';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.38, w * 0.48, h * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    // Water
    ctx.fillStyle = 'rgba(100,200,255,0.3)';
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h * 0.38, w * 0.38, h * 0.1, 0, 0, Math.PI * 2);
    ctx.fill();
    break;
  }
  case 'Flower Pot': {
    // Large decorative pot
    ctx.fillStyle = '#8B4513';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.15, y + h * 0.35);
    ctx.lineTo(x + w * 0.25, y + h);
    ctx.lineTo(x + w * 0.75, y + h);
    ctx.lineTo(x + w * 0.85, y + h * 0.35);
    ctx.closePath(); ctx.fill();
    // Rim
    ctx.fillStyle = '#a0522d';
    ctx.beginPath(); ctx.roundRect(x + w * 0.1, y + h * 0.3, w * 0.8, 8, 3); ctx.fill();
    // Flowers (multiple colorful ones)
    const fpColors = ['#e53935','#ffb300','#e91e63','#ff7043','#ab47bc'];
    for (let i = 0; i < 5; i++) {
      const fx = x + w * 0.2 + i * w * 0.14;
      const fy = y + 8 + (i % 2) * 6;
      // Stem
      ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(fx, fy + 6); ctx.lineTo(fx, y + h * 0.35); ctx.stroke();
      // Flower
      ctx.fillStyle = fpColors[i];
      ctx.beginPath(); ctx.arc(fx, fy, 5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff59d';
      ctx.beginPath(); ctx.arc(fx, fy, 2, 0, Math.PI * 2); ctx.fill();
    }
    break;
  }

  // â”€â”€â”€ NEW GARAGE ITEMS â”€â”€â”€
  case 'Shelving': {
    // Metal frame
    ctx.fillStyle = '#555';
    ctx.fillRect(x, y, 3, h);
    ctx.fillRect(x + w - 3, y, 3, h);
    // Shelves
    for (let i = 0; i < 3; i++) {
      const sy2 = y + (h / 3) * i;
      ctx.fillStyle = '#666';
      ctx.fillRect(x, sy2, w, 3);
      // Items on shelves
      ctx.fillStyle = '#8d6e63';
      ctx.beginPath(); ctx.roundRect(x + 6, sy2 + 5, 12, h / 3 - 10, 1); ctx.fill();
      ctx.fillStyle = '#546e7a';
      ctx.beginPath(); ctx.roundRect(x + 22, sy2 + 5, 15, h / 3 - 10, 1); ctx.fill();
      ctx.fillStyle = '#795548';
      ctx.beginPath(); ctx.roundRect(x + 42, sy2 + 8, 10, h / 3 - 14, 1); ctx.fill();
    }
    break;
  }
  case 'Oil Can': {
    // Can body
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y + h * 0.15, w * 0.7, h * 0.7, w * 0.15); ctx.fill();
    // Label
    ctx.fillStyle = '#1565c0';
    ctx.beginPath(); ctx.roundRect(x + w * 0.22, y + h * 0.3, w * 0.56, h * 0.25, 2); ctx.fill();
    // Spout
    ctx.fillStyle = '#666';
    ctx.fillRect(x + w * 0.42, y, w * 0.16, h * 0.2);
    // Cap
    ctx.fillStyle = '#555';
    ctx.beginPath(); ctx.roundRect(x + w * 0.38, y - 2, w * 0.24, 6, 2); ctx.fill();
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x + w * 0.15, y + h * 0.15, w * 0.7, h * 0.7, w * 0.15); ctx.stroke();
    break;
  }
  case 'Floor Jack': {
    // Base
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath(); ctx.roundRect(x, y + h * 0.5, w, h * 0.5, 3); ctx.fill();
    // Arm
    ctx.fillStyle = '#c62828';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.1, y + h * 0.5);
    ctx.lineTo(x + w * 0.4, y + h * 0.15);
    ctx.lineTo(x + w * 0.6, y + h * 0.15);
    ctx.lineTo(x + w * 0.3, y + h * 0.5);
    ctx.closePath(); ctx.fill();
    // Pad
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.roundRect(x + w * 0.35, y, w * 0.3, h * 0.18, 2); ctx.fill();
    // Handle
    ctx.fillStyle = '#888';
    ctx.fillRect(x + w * 0.7, y + h * 0.35, w * 0.3, 4);
    // Wheels
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(x + 8, y + h - 3, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + w - 8, y + h - 3, 4, 0, Math.PI * 2); ctx.fill();
    break;
  }

  // â”€â”€â”€ DEFAULT FALLBACK â”€â”€â”€
  default: {
    ctx.fillStyle = '#2a3450';
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.stroke();
    break;
  }
  }

  ctx.restore();
}


function drawPowerups() {
  const time = frameCount / 60;
  powerups.forEach(pu => {
    if (!pu.alive) return;
    if (pu.x < camera.x - 40 || pu.x > camera.x + window.innerWidth + 40 ||
        pu.y < camera.y - 40 || pu.y > camera.y + window.innerHeight + 40) return;

    const bob = Math.sin(time * 3 + pu.bobPhase) * 5;
    const pulse = Math.sin(time * 4 + pu.bobPhase) * 0.15 + 0.85;
    const rotation = time * 0.5 + pu.bobPhase;

    // Ground shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(pu.x, pu.y + 10, POWERUP_RADIUS * 0.8, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Outer glow (pulsing)
    const glowGrd = ctx.createRadialGradient(pu.x, pu.y + bob, 2, pu.x, pu.y + bob, POWERUP_RADIUS + 14);
    glowGrd.addColorStop(0, pu.color + '30');
    glowGrd.addColorStop(0.5, pu.color + '10');
    glowGrd.addColorStop(1, pu.color + '00');
    ctx.fillStyle = glowGrd;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, (POWERUP_RADIUS + 14) * pulse, 0, Math.PI * 2);
    ctx.fill();

    // Spinning ring
    ctx.save();
    ctx.translate(pu.x, pu.y + bob);
    ctx.rotate(rotation);
    ctx.strokeStyle = pu.color + '25';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, POWERUP_RADIUS + 4, 0, Math.PI * 1.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, POWERUP_RADIUS + 4, Math.PI * 1.4, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // Main circle (gradient fill)
    const puGrd = ctx.createRadialGradient(pu.x - 3, pu.y + bob - 3, 2, pu.x, pu.y + bob, POWERUP_RADIUS);
    puGrd.addColorStop(0, pu.color + '70');
    puGrd.addColorStop(1, pu.color + '35');
    ctx.fillStyle = puGrd;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    // Circle border
    ctx.strokeStyle = pu.color + '90';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pu.x, pu.y + bob, POWERUP_RADIUS, 0, Math.PI * 2);
    ctx.stroke();

    // Inner highlight
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.arc(pu.x - 2, pu.y + bob - 3, POWERUP_RADIUS * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Icon
    ctx.font = '16px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pu.icon, pu.x, pu.y + bob);
  });
}

function drawEntities() {
  // Collect all alive entities and sort by Y for depth
  const entities = [];
  if (player && player.alive) entities.push({ ...player, isPlayer: true });
  bots.forEach(b => { if (b.alive) entities.push(b); });
  entities.sort((a, b) => a.y - b.y);

  entities.forEach(e => {
    if (e.x < camera.x - 40 || e.x > camera.x + window.innerWidth + 40 ||
        e.y < camera.y - 50 || e.y > camera.y + window.innerHeight + 50) return;

    const isShielded = hasActivePowerup(e, 'shield');
    const isPowered = hasActivePowerup(e, 'power');
    const isSpeed = hasActivePowerup(e, 'speed');

    // Invincibility flash
    if (Date.now() < e.invincibleUntil && Math.floor(Date.now() / 100) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }

    // Speed trail effect
    if (isSpeed) {
      ctx.globalAlpha = 0.08;
      drawBean(ctx, e.x - (e.facingLeft ? -8 : 8), e.y + 2, e.color, 0.95, e.facingLeft, '', false, false);
      ctx.globalAlpha = 0.04;
      drawBean(ctx, e.x - (e.facingLeft ? -16 : 16), e.y + 4, e.color, 0.9, e.facingLeft, '', false, false);
      ctx.globalAlpha = Date.now() < e.invincibleUntil && Math.floor(Date.now() / 100) % 2 === 0 ? 0.5 : 1;
    }

    drawBean(ctx, e.x, e.y, e.color, 1, e.facingLeft, e.isPlayer ? '' : e.name, isShielded, isPowered);

    // HP bar above player (replaces dots for better visibility)
    if (e.isPlayer) {
      const barW = 34;
      const barH = 4;
      const barX = e.x - barW / 2;
      const barY = e.y - 40;
      const maxHp = 5;

      // Bar background
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.roundRect(barX - 1, barY - 1, barW + 2, barH + 2, 2);
      ctx.fill();

      // HP segments
      const segW = barW / maxHp;
      for (let i = 0; i < maxHp; i++) {
        if (i < e.hp) {
          // Gradient from green to red based on HP
          const hpRatio = e.hp / maxHp;
          const r = Math.round(255 * (1 - hpRatio));
          const g = Math.round(200 * hpRatio);
          ctx.fillStyle = `rgb(${r},${g},60)`;
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
        }
        ctx.fillRect(barX + i * segW + 0.5, barY, segW - 1, barH);
      }

      // Bar shine
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(barX, barY, barW, 1);
    } else {
      // Bot HP dots (smaller, above name)
      const dotSpacing = 8;
      const totalWidth = (e.hp - 1) * dotSpacing;
      for (let i = 0; i < e.hp; i++) {
        ctx.fillStyle = i < e.hp ? '#ef4444' : 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.arc(e.x - totalWidth / 2 + i * dotSpacing, e.y - 42, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  const mapW = 140;
  const mapH = mapW * (ARENA_H / ARENA_W);
  const padding = 12;
  const mx = window.innerWidth - mapW - padding;
  const my = window.innerHeight - mapH - padding - 60;
  const scale = mapW / ARENA_W;

  // Background with subtle gradient
  const mmBg = ctx.createLinearGradient(mx, my, mx, my + mapH);
  mmBg.addColorStop(0, 'rgba(8,12,24,0.92)');
  mmBg.addColorStop(1, 'rgba(12,16,30,0.92)');
  ctx.fillStyle = mmBg;
  ctx.beginPath();
  ctx.roundRect(mx - 6, my - 18, mapW + 12, mapH + 24, 8);
  ctx.fill();

  // Title
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '600 7px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('MAP', mx + mapW / 2, my - 8);

  // Border glow
  ctx.strokeStyle = 'rgba(16,185,129,0.2)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.roundRect(mx - 6, my - 18, mapW + 12, mapH + 24, 8);
  ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.roundRect(mx - 5, my - 17, mapW + 10, mapH + 22, 7);
  ctx.stroke();

  // Room floors with room-specific colors
  ROOMS.forEach(rm => {
    // Room floor with accent tint
    ctx.fillStyle = rm.floor;
    ctx.fillRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
    // Subtle room accent overlay
    ctx.fillStyle = rm.accent + '10';
    ctx.fillRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
    // Room border
    ctx.strokeStyle = rm.trimColor + '20';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(mx + rm.x * scale, my + rm.y * scale, rm.w * scale, rm.h * scale);
  });

  // Walls (brighter, more visible)
  MAP_OBSTACLES.forEach(o => {
    if (o.type === 'wall') {
      ctx.fillStyle = 'rgba(200,210,230,0.35)';
      ctx.fillRect(mx + o.x * scale, my + o.y * scale, Math.max(1, o.w * scale), Math.max(1, o.h * scale));
    }
  });

  // Furniture (subtle dots)
  MAP_OBSTACLES.forEach(o => {
    if (o.type === 'furniture') {
      ctx.fillStyle = 'rgba(100,140,200,0.15)';
      ctx.fillRect(mx + o.x * scale, my + o.y * scale, Math.max(1, o.w * scale), Math.max(1, o.h * scale));
    }
  });

  // Powerup dots
  powerups.forEach(pu => {
    if (!pu.alive) return;
    ctx.fillStyle = pu.color + '60';
    ctx.beginPath();
    ctx.arc(mx + pu.x * scale, my + pu.y * scale, 1.5, 0, Math.PI * 2);
    ctx.fill();
  });

  // Bots with colored rings
  bots.forEach(b => {
    if (!b.alive) return;
    // Outer ring
    ctx.strokeStyle = b.color.body + '80';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(mx + b.x * scale, my + b.y * scale, 3.5, 0, Math.PI * 2);
    ctx.stroke();
    // Inner dot
    ctx.fillStyle = b.color.body;
    ctx.beginPath();
    ctx.arc(mx + b.x * scale, my + b.y * scale, 2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Player (pulsing white dot)
  if (player && player.alive) {
    const pulse = Math.sin(frameCount / 30 * Math.PI * 2) * 0.3 + 0.7;
    // Player glow
    ctx.fillStyle = `rgba(255,255,255,${0.15 * pulse})`;
    ctx.beginPath();
    ctx.arc(mx + player.x * scale, my + player.y * scale, 6, 0, Math.PI * 2);
    ctx.fill();
    // Player dot
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(mx + player.x * scale, my + player.y * scale, 3, 0, Math.PI * 2);
    ctx.fill();
    // Player direction indicator
    const dir = player.facingLeft ? -1 : 1;
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(mx + player.x * scale + dir * 5, my + player.y * scale);
    ctx.lineTo(mx + player.x * scale + dir * 2, my + player.y * scale - 2);
    ctx.lineTo(mx + player.x * scale + dir * 2, my + player.y * scale + 2);
    ctx.closePath();
    ctx.fill();

    // Camera viewport rectangle
    ctx.strokeStyle = 'rgba(16,185,129,0.25)';
    ctx.lineWidth = 0.8;
    ctx.strokeRect(
      mx + camera.x * scale,
      my + camera.y * scale,
      window.innerWidth * scale,
      window.innerHeight * scale
    );
  }
}

function updateActionButton() {
  if (!player || !player.alive) return;
  const btn = document.getElementById('action-btn');
  let nearestDist = Infinity;
  bots.forEach(b => {
    if (!b.alive) return;
    const d = dist(player, b);
    if (d < nearestDist) nearestDist = d;
  });

  if (nearestDist < BATTLE_RANGE + 30) {
    btn.classList.add('battle-ready');
    btn.textContent = 'BATTLE!';
  } else {
    btn.classList.remove('battle-ready');
    btn.textContent = 'SCAN';
  }
}

// â”€â”€ START â”€â”€
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
